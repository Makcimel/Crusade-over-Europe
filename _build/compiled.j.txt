// this script was compiled with wurst 1.8.0.0-jenkins-Wurst-1091
globals
group w=null
location u=null
integer array r
force s=null
location t=null
location i=null
location S=null
location c=null
rect o=null
rect O=null
group l=null
group b=null
location y=null
boolean array p
boolean array e
rect q=null
rect a=null
rect n=null
rect d=null
rect f=null
rect R=null
rect T=null
rect Y=null
rect G=null
rect g=null
rect h=null
rect F=null
rect k=null
rect j=null
rect x=null
rect v=null
rect m=null
rect Q=null
rect W=null
rect E=null
rect Z=null
rect U=null
rect I=null
rect P=null
rect A=null
rect D=null
rect H=null
rect J=null
rect K=null
rect L=null
rect X=null
rect C=null
rect V=null
rect B=null
rect N=null
rect M=null
rect ww=null
rect uw=null
rect rw=null
rect sw=null
rect tw=null
rect iw=null
rect Sw=null
rect cw=null
rect ow=null
rect Ow=null
rect lw=null
rect bw=null
rect yw=null
rect pw=null
rect ew=null
rect qw=null
rect aw=null
rect nw=null
rect dw=null
rect fw=null
rect Rw=null
rect Tw=null
rect Yw=null
rect Gw=null
rect gw=null
rect hw=null
rect Fw=null
rect kw=null
rect jw=null
rect xw=null
rect vw=null
rect mw=null
rect Qw=null
rect Ww=null
rect Ew=null
rect Zw=null
rect Uw=null
rect Iw=null
rect Pw=null
rect Aw=null
rect Dw=null
rect Hw=null
rect Jw=null
rect Kw=null
rect Lw=null
rect Xw=null
rect Cw=null
rect Vw=null
rect Bw=null
rect Nw=null
rect Mw=null
rect wu=null
rect uu=null
rect ru=null
rect su=null
rect tu=null
rect iu=null
rect Su=null
rect cu=null
rect ou=null
rect Ou=null
rect lu=null
rect bu=null
rect yu=null
rect pu=null
rect eu=null
rect qu=null
rect au=null
rect nu=null
rect du=null
rect fu=null
rect Ru=null
rect Tu=null
rect Yu=null
rect Gu=null
rect gu=null
rect hu=null
rect Fu=null
rect ku=null
rect ju=null
rect xu=null
rect vu=null
rect mu=null
rect Qu=null
rect Wu=null
rect Eu=null
rect Zu=null
rect Uu=null
rect Iu=null
rect Pu=null
rect Au=null
rect Du=null
rect Hu=null
rect Ju=null
rect Ku=null
rect Lu=null
rect Xu=null
rect Cu=null
rect Vu=null
rect Bu=null
rect Nu=null
rect Mu=null
rect wr=null
rect ur=null
rect rr=null
rect sr=null
rect tr=null
rect ir=null
rect Sr=null
rect cr=null
rect lr=null
rect br=null
rect yr=null
rect pr=null
rect er=null
rect qr=null
rect ar=null
rect nr=null
rect dr=null
rect fr=null
rect Rr=null
rect Tr=null
rect Yr=null
rect Gr=null
rect gr=null
rect hr=null
rect Fr=null
rect kr=null
rect jr=null
rect xr=null
rect vr=null
rect mr=null
rect Qr=null
rect Wr=null
rect Er=null
rect Zr=null
rect Ur=null
rect Ir=null
rect Pr=null
rect Ar=null
rect Dr=null
rect Hr=null
rect Jr=null
rect Kr=null
rect Lr=null
rect Xr=null
rect Cr=null
rect Vr=null
rect Br=null
rect Nr=null
rect Mr=null
rect ws=null
rect us=null
rect rs=null
rect ss=null
rect ts=null
rect is=null
rect Ss=null
rect cs=null
rect os=null
rect Os=null
rect ls=null
rect bs=null
rect ys=null
rect ps=null
rect es=null
rect qs=null
rect as=null
rect ns=null
rect ds=null
sound fs=null
trigger Rs=null
trigger Ts=null
trigger Ys=null
trigger Gs=null
trigger gs=null
trigger hs=null
trigger Fs=null
trigger ks=null
trigger js=null
trigger xs=null
trigger vs=null
trigger ms=null
trigger Qs=null
trigger Ws=null
trigger Es=null
trigger Zs=null
trigger Us=null
trigger Is=null
trigger Ps=null
trigger As=null
trigger Ds=null
trigger Hs=null
trigger Js=null
trigger Ks=null
trigger Ls=null
trigger Xs=null
trigger Cs=null
trigger Vs=null
trigger Bs=null
trigger Ns=null
trigger Ms=null
trigger wt=null
trigger ut=null
trigger rt=null
trigger st=null
trigger tt=null
trigger St=null
trigger ct=null
trigger ot=null
trigger Ot=null
trigger lt=null
trigger bt=null
trigger yt=null
trigger pt=null
trigger et=null
trigger qt=null
trigger at=null
trigger nt=null
trigger dt=null
trigger ft=null
trigger Rt=null
trigger Tt=null
trigger Yt=null
trigger Gt=null
trigger gt=null
trigger ht=null
trigger Ft=null
trigger kt=null
trigger jt=null
trigger xt=null
trigger vt=null
trigger mt=null
trigger Qt=null
trigger Wt=null
trigger Et=null
trigger Zt=null
trigger Ut=null
trigger It=null
trigger Pt=null
trigger At=null
trigger Dt=null
trigger Ht=null
trigger Jt=null
trigger Kt=null
trigger Lt=null
trigger Xt=null
trigger Ct=null
trigger Vt=null
trigger Bt=null
trigger Nt=null
trigger Mt=null
trigger wi=null
trigger ui=null
trigger ri=null
trigger si=null
trigger ti=null
trigger ii=null
trigger Si=null
trigger ci=null
trigger oi=null
trigger Oi=null
trigger li=null
trigger bi=null
trigger yi=null
trigger pi=null
trigger ei=null
trigger qi=null
trigger ai=null
trigger ni=null
trigger di=null
trigger fi=null
trigger Ri=null
trigger Ti=null
trigger Yi=null
trigger Gi=null
trigger gi=null
trigger hi=null
trigger Fi=null
trigger ki=null
trigger ji=null
trigger xi=null
trigger vi=null
trigger mi=null
trigger Qi=null
trigger Wi=null
trigger Ei=null
trigger Zi=null
trigger Ui=null
trigger Ii=null
trigger Pi=null
trigger Ai=null
trigger Di=null
trigger Hi=null
trigger Ji=null
trigger Ki=null
trigger Li=null
trigger Xi=null
trigger Ci=null
trigger Vi=null
trigger Bi=null
trigger Ni=null
trigger Mi=null
trigger wS=null
trigger uS=null
trigger rS=null
integer sS=0
player tS=null
integer iS=0
integer array SS
integer cS=0
integer oS=0
integer OS=0
integer lS=0
integer bS=0
integer yS=0
integer pS=0
integer eS=0
integer qS=0
integer aS=0
integer nS=0
real dS=0.
real array fS
integer array RS
real array TS
real array YS
real array GS
real array gS
integer array hS
playerevent FS=null
trigger kS=null
trigger jS=null
trigger xS=null
integer array vS
integer mS=0
integer QS=0
integer WS=0
integer array ES
integer array ZS
boolean US=false
group IS=null
integer array PS
integer AS=0
integer DS=0
integer HS=0
filterfunc JS=null
integer KS=0
integer array LS
integer array XS
integer array CS
string array VS
integer BS=0
real NS=0.
integer array MS
integer array wc
integer array uc
integer array rc
integer sc=0
hashtable tc=null
force ic=null
force Sc=null
force cc=null
force oc=null
force array Oc
integer array lc
integer array bc
integer array yc
timer pc=null
real ec=0.
group qc=null
hashtable ac=null
hashtable nc=null
hashtable dc=null
integer array fc
integer array Rc
integer Tc=0
boolean Yc=false
boolean Gc=false
boolean gc=false
timer hc=null
real Fc=0.
rect kc=null
rect jc=null
region xc=null
real vc=0.
real mc=0.
integer Qc=0
integer Wc=0
integer Ec=0
integer array Zc
integer array Uc
integer array Ic
integer array Pc
integer array Ac
integer array Dc
integer array Hc
integer array Jc
integer array Kc
multiboard array Lc
integer Xc=0
trigger Cc=null
group Vc=null
unit array Bc
integer Nc=0
integer array Mc
player array wo
player uo=null
playercolor ro=null
playercolor so=null
playercolor io=null
playercolor So=null
playercolor array co
group oo=null
unit Oo=null
integer lo=0
real bo=0.
trigger array yo
integer po=0
real array eo
integer qo=0
string array ao
string array no
string array do
string array fo
string array Ro
string array To
string array Yo
string array Go
string array go
string array ho
string array Fo
string array ko
string array jo
string array xo
string array vo
string array mo
string array Qo
hashtable Wo=null
timer array Eo
integer Zo=0
integer Uo=0
integer Io=0
trigger Po=null
trigger Ao=null
unit array Do
integer Ho=0
integer Jo=0
integer Ko=0
integer array Lo
integer Xo=0
integer Co=0
integer Vo=0
integer Bo=0
integer array No
integer Mo=0
integer array wO
integer array uO
integer rO=0
integer array sO
integer tO=0
integer iO=0
integer array SO
integer array cO
integer oO=0
integer OO=0
integer array lO
integer bO=0
integer yO=0
integer array pO
integer array eO
integer qO=0
integer aO=0
integer array nO
integer array dO
integer fO=0
integer RO=0
integer array TO
integer array YO
integer GO=0
integer gO=0
integer array hO
integer FO=0
integer array kO
integer array jO
integer xO=0
integer vO=0
integer array mO
integer array QO
integer WO=0
integer EO=0
integer array ZO
integer array UO
integer IO=0
integer PO=0
integer array AO
integer DO=0
integer HO=0
integer array JO
integer KO=0
integer LO=0
integer array XO
integer array CO
integer VO=0
integer BO=0
integer array NO
integer array MO
integer wl=0
integer ul=0
integer array rl
integer array sl
integer tl=0
integer il=0
integer array Sl
integer cl=0
integer ol=0
integer array Ol
integer ll=0
integer bl=0
integer array yl
integer array pl
integer el=0
integer ql=0
integer array al
integer nl=0
integer dl=0
integer array fl
real array Rl
real array Tl
boolean array Yl
real array Gl
integer array gl
real array hl
real array Fl
string array kl
string array jl
unit array xl
string array vl
integer array ml
integer array Ql
integer array Wl
real array El
real array Zl
integer array Ul
integer array Il
real array Pl
real array Al
real array Dl
real array Hl
integer array Jl
real array Kl
integer array Ll
integer array Xl
integer array Cl
integer array Vl
integer array Bl
integer array Nl
integer array Ml
integer array wb
integer array ub
integer array rb
integer array sb
integer array tb
integer array ib
integer array Sb
unit array cb
timer array ob
real array Ob
integer array lb
integer array bb
integer array yb
integer array pb
integer array eb
integer array qb
integer array ab
unit array nb
unit array db
integer array fb
integer array Rb
integer array Tb
integer array Yb
integer array Gb
integer array gb
integer array hb
boolean array Fb
integer array kb
integer array jb
player array xb
unit array vb
integer array mb
unit array Qb
integer array Wb
real array Eb
real array Zb
unit array Ub
integer array Ib
player array Pb
boolean array Ab
integer array Db
integer array Hb
boolean array Jb
unit array Kb
unit array Lb
integer Xb=0
string array Cb
integer Vb=0
integer Bb=0
integer Nb=0
integer array Mb
integer array wy
integer array uy
integer array ry
integer array sy
integer array ty
integer array iy
integer array Sy
integer array cy
integer array oy
integer array Oy
integer array ly
integer array by
integer array yy
integer array py
integer array ey
integer array qy
integer array ay
integer array ny
integer array dy
integer array fy
integer array Ry
integer array Ty
integer array Yy
code Gy=null
code gy=null
code hy=null
code Fy=null
code ky=null
code jy=null
code xy=null
code vy=null
code my=null
code Qy=null
code Wy=null
code Ey=null
code Zy=null
code Uy=null
code Iy=null
code Py=null
code Ay=null
code Dy=null
code Hy=null
code Jy=null
code Ky=null
code Ly=null
code Xy=null
code Cy=null
code Vy=null
code By=null
code Ny=null
code My=null
code wp=null
code up=null
code rp=null
code sp=null
code tp=null
code ip=null
code Sp=null
code cp=null
code op=null
code Op=null
code lp=null
code bp=null
code yp=null
code pp=null
code ep=null
code qp=null
code ap=null
code np=null
code dp=null
code fp=null
code Rp=null
code Tp=null
code Yp=null
code Gp=null
code gp=null
code hp=null
code Fp=null
code kp=null
code jp=null
code xp=null
code vp=null
code mp=null
code Qp=null
code Wp=null
code Ep=null
code Zp=null
code Up=null
code Ip=null
code Pp=null
code Ap=null
code Dp=null
code Hp=null
code Jp=null
code Kp=null
code Lp=null
code Xp=null
code Cp=null
code Vp=null
code Bp=null
code Np=null
code Mp=null
code we=null
code ue=null
code re=null
code se=null
code te=null
code ie=null
code Se=null
code ce=null
code oe=null
code Oe=null
code le=null
code be=null
code ye=null
code pe=null
code ee=null
code qe=null
code ae=null
code ne=null
code de=null
code fe=null
code Re=null
code Te=null
code Ye=null
code Ge=null
code ge=null
code he=null
code Fe=null
code ke=null
code je=null
code xe=null
code ve=null
code me=null
code Qe=null
code We=null
code Ee=null
code Ze=null
code Ue=null
code Ie=null
code Pe=null
code Ae=null
code De=null
code He=null
code Je=null
code Ke=null
code Le=null
code Xe=null
code Ce=null
code Ve=null
code Be=null
code Ne=null
code Me=null
code wq=null
code uq=null
code rq=null
code sq=null
code tq=null
code iq=null
code Sq=null
code cq=null
code oq=null
code Oq=null
code lq=null
code bq=null
code yq=null
code pq=null
code eq=null
code qq=null
code aq=null
code nq=null
code dq=null
code fq=null
code Rq=null
code Tq=null
code Yq=null
code Gq=null
code gq=null
code hq=null
code Fq=null
code kq=null
code jq=null
code xq=null
code vq=null
code mq=null
code Qq=null
code Wq=null
code Eq=null
code Zq=null
code Uq=null
code Iq=null
code Pq=null
code Aq=null
code Dq=null
code Hq=null
code Jq=null
code Kq=null
code Lq=null
code Xq=null
code Cq=null
code Vq=null
code Bq=null
code Nq=null
code Mq=null
code wa=null
code ua=null
code ra=null
code sa=null
code ta=null
code ia=null
code Sa=null
code ca=null
code oa=null
code Oa=null
code la=null
code ba=null
code ya=null
code pa=null
code ea=null
code qa=null
code aa=null
code na=null
code da=null
code fa=null
code Ra=null
code Ta=null
code Ya=null
code Ga=null
code ga=null
code ha=null
code Fa=null
code ka=null
code ja=null
code xa=null
code va=null
code ma=null
code Qa=null
code Wa=null
code Ea=null
code Za=null
code Ua=null
code Ia=null
code Pa=null
code Aa=null
code Da=null
code Ha=null
code Ja=null
code Ka=null
code La=null
code Xa=null
code Ca=null
code Va=null
code Ba=null
code Na=null
code Ma=null
code wn=null
code un=null
code rn=null
code sn=null
code tn=null
code Sn=null
code cn=null
code on=null
code On=null
code ln=null
code bn=null
code yn=null
code pn=null
code en=null
code qn=null
code an=null
code nn=null
code dn=null
code fn=null
code Rn=null
code Tn=null
code Yn=null
code Gn=null
code gn=null
code hn=null
code Fn=null
code kn=null
code jn=null
code xn=null
code vn=null
code mn=null
code Qn=null
code Wn=null
code En=null
code Zn=null
code Un=null
code In=null
code Pn=null
code An=null
code Dn=null
code Hn=null
code Jn=null
code Kn=null
code Ln=null
code Xn=null
code Cn=null
code Vn=null
code Bn=null
code Nn=null
code Mn=null
code wd=null
code ud=null
code rd=null
code sd=null
code td=null
code id=null
code Sd=null
code cd=null
code od=null
code Od=null
code ld=null
code bd=null
code yd=null
code pd=null
code ed=null
code qd=null
code ad=null
code nd=null
code dd=null
code fd=null
code Rd=null
code Td=null
code Yd=null
code Gd=null
code gd=null
code hd=null
code Fd=null
code kd=null
code jd=null
code xd=null
code vd=null
code md=null
code Qd=null
code Wd=null
code Ed=null
code Zd=null
code Ud=null
code Id=null
code Pd=null
code Ad=null
code Dd=null
code Hd=null
code Jd=null
code Kd=null
code Ld=null
code Xd=null
code Cd=null
code Vd=null
code Bd=null
code Nd=null
code Md=null
code wf=null
code uf=null
code rf=null
code sf=null
code tf=null
code Sf=null
code cf=null
code of=null
code Of=null
code lf=null
code bf=null
code yf=null
code pf=null
code ef=null
code qf=null
code af=null
code nf=null
code df=null
code ff=null
code Rf=null
code Tf=null
code Yf=null
code Gf=null
code gf=null
code hf=null
code Ff=null
code kf=null
code jf=null
code xf=null
code vf=null
code mf=null
code Qf=null
code Wf=null
code Ef=null
code Zf=null
code Uf=null
code If=null
code Pf=null
code Af=null
code Df=null
code Hf=null
code Jf=null
code Kf=null
code Lf=null
code Xf=null
code Cf=null
code Vf=null
code Bf=null
code Nf=null
code Mf=null
code wR=null
code uR=null
code rR=null
code sR=null
code tR=null
code iR=null
unit SR=null
multiboard cR=null
timer oR=null
unit OR=null
trigger lR=null
rect bR=null
endglobals
function FR takes nothing returns nothing
local player gR=Player(3)
local unit hR=CreateUnit(gR,1211118391,-30468.2,30345.3,270.516)
call SetHeroLevel(hR,15,false)
call SetUnitState(hR,UNIT_STATE_MANA,85.)
set hR=CreateUnit(gR,1211118406,-30252.3,29576.9,270.316)
call SetHeroLevel(hR,15,false)
set gR=null
set hR=null
endfunction
function FT takes nothing returns nothing
local player gT=Player(22)
local unit hT=CreateUnit(gT,1211118391,-29948.2,29831.1,270.025)
call SetHeroLevel(hT,15,false)
call SetUnitState(hT,UNIT_STATE_MANA,85.)
set hT=CreateUnit(gT,1211118406,-29699.3,29565.4,269.787)
call SetHeroLevel(hT,15,false)
set gT=null
set hT=null
endfunction
function GR takes nothing returns nothing
local player TR=Player(2)
local unit YR=CreateUnit(TR,1211118391,-30324.4,30466.1,270.380)
call SetHeroLevel(YR,15,false)
call SetUnitState(YR,UNIT_STATE_MANA,85.)
set YR=CreateUnit(TR,1211118406,-30346.6,29573.7,270.406)
call SetHeroLevel(YR,15,false)
set TR=null
set YR=null
endfunction
function GT takes nothing returns nothing
local player TT=Player(19)
local unit YT=CreateUnit(TT,1211118391,-29820.0,29950.4,269.903)
call SetHeroLevel(YT,15,false)
call SetUnitState(YT,UNIT_STATE_MANA,85.)
set YT=CreateUnit(TT,1211118406,-29707.1,29309.8,269.793)
call SetHeroLevel(YT,15,false)
set TT=null
set YT=null
endfunction
function HR takes nothing returns nothing
local player AR=Player(8)
local unit DR=CreateUnit(AR,1211118391,-29946.0,30342.9,270.023)
call SetHeroLevel(DR,15,false)
call SetUnitState(DR,UNIT_STATE_MANA,85.)
set DR=CreateUnit(AR,1211118406,-30137.9,29561.1,270.206)
call SetHeroLevel(DR,15,false)
set AR=null
set DR=null
endfunction
function LR takes nothing returns nothing
local player JR=Player(9)
local unit KR=CreateUnit(JR,1211118391,-29693.5,30338.3,269.785)
call SetHeroLevel(KR,15,false)
call SetUnitState(KR,UNIT_STATE_MANA,85.)
set KR=CreateUnit(JR,1211118406,-30045.2,29554.8,270.118)
call SetHeroLevel(KR,15,false)
set JR=null
set KR=null
endfunction
function MR takes nothing returns nothing
local player BR=Player(11)
local unit NR=CreateUnit(BR,1211118391,-29827.0,30210.1,269.911)
call SetHeroLevel(NR,15,false)
call SetUnitState(NR,UNIT_STATE_MANA,85.)
set NR=CreateUnit(BR,1211118406,-30125.9,29321.4,270.196)
call SetHeroLevel(NR,15,false)
set BR=null
set NR=null
endfunction
function PR takes nothing returns nothing
local player UR=Player(7)
local unit IR=CreateUnit(UR,1211118391,-29818.2,30468.8,269.903)
call SetHeroLevel(IR,15,false)
call SetUnitState(IR,UNIT_STATE_MANA,85.)
set IR=CreateUnit(UR,1211118406,-29998.9,29444.3,270.074)
call SetHeroLevel(IR,15,false)
set UR=null
set IR=null
endfunction
function QR takes nothing returns nothing
local player vR=Player(5)
local unit mR=CreateUnit(vR,1211118391,-29950.2,30589.5,270.027)
call SetHeroLevel(mR,15,false)
call SetUnitState(mR,UNIT_STATE_MANA,85.)
set mR=CreateUnit(vR,1211118406,-30283.9,29308.8,270.348)
call SetHeroLevel(mR,15,false)
set vR=null
set mR=null
endfunction
function RR takes nothing returns nothing
local player dR=Player(1)
local unit fR=CreateUnit(dR,1211118391,-30205.9,30601.1,270.267)
call SetHeroLevel(fR,15,false)
call SetUnitState(fR,UNIT_STATE_MANA,85.)
set fR=CreateUnit(dR,1211118406,-30199.1,29448.7,270.266)
call SetHeroLevel(fR,15,false)
set dR=null
set fR=null
endfunction
function RT takes nothing returns nothing
local player dT=Player(18)
local unit fT=CreateUnit(dT,1211118391,-29691.7,30077.9,269.782)
call SetHeroLevel(fT,15,false)
call SetUnitState(fT,UNIT_STATE_MANA,85.)
set fT=CreateUnit(dT,1211118406,-29792.0,29571.7,269.875)
call SetHeroLevel(fT,15,false)
set dT=null
set fT=null
endfunction
function VR takes nothing returns nothing
local player XR=Player(10)
local unit CR=CreateUnit(XR,1211118391,-30338.2,30210.1,270.394)
call SetHeroLevel(CR,15,false)
call SetUnitState(CR,UNIT_STATE_MANA,85.)
set CR=CreateUnit(XR,1211118406,-29904.6,29442.8,269.983)
call SetHeroLevel(CR,15,false)
set XR=null
set CR=null
endfunction
function ZR takes nothing returns nothing
local player WR=Player(6)
local unit ER=CreateUnit(WR,1211118391,-29693.7,30597.0,269.786)
call SetHeroLevel(ER,15,false)
call SetUnitState(ER,UNIT_STATE_MANA,85.)
set ER=CreateUnit(WR,1211118406,-30199.8,29310.0,270.267)
call SetHeroLevel(ER,15,false)
set WR=null
set ER=null
endfunction
function bT takes nothing returns nothing
local player OT=Player(15)
local unit lT=CreateUnit(OT,1211118391,-30467.2,29834.7,270.519)
call SetHeroLevel(lT,15,false)
call SetUnitState(lT,UNIT_STATE_MANA,85.)
set lT=CreateUnit(OT,1211118406,-29874.4,29559.4,269.954)
call SetHeroLevel(lT,15,false)
set OT=null
set lT=null
endfunction
function eT takes nothing returns nothing
local player yT=Player(16)
local unit pT=CreateUnit(yT,1211118391,-30203.1,29826.8,270.268)
call SetHeroLevel(pT,15,false)
call SetUnitState(pT,UNIT_STATE_MANA,85.)
set pT=CreateUnit(yT,1211118406,-29780.4,29300.3,269.864)
call SetHeroLevel(pT,15,false)
set yT=null
set pT=null
endfunction
function iT takes nothing returns nothing
local player sT=Player(13)
local unit tT=CreateUnit(sT,1211118391,-30204.3,30080.3,270.268)
call SetHeroLevel(tT,15,false)
call SetUnitState(tT,UNIT_STATE_MANA,85.)
set tT=CreateUnit(sT,1211118406,-30039.0,29306.5,270.112)
call SetHeroLevel(tT,15,false)
set sT=null
set tT=null
endfunction
function nR takes nothing returns nothing
local player qR=Player(0)
local unit aR=CreateUnit(qR,1211118391,-30470.9,30602.5,270.516)
call SetHeroLevel(aR,15,false)
call SetUnitState(aR,UNIT_STATE_MANA,85.)
set aR=CreateUnit(qR,1211118406,-30360.2,29312.6,270.421)
call SetHeroLevel(aR,15,false)
set qR=null
set aR=null
endfunction
function nT takes nothing returns nothing
local player qT=Player(17)
local unit aT=CreateUnit(qT,1211118391,-29951.6,30084.7,270.028)
call SetHeroLevel(aT,15,false)
call SetUnitState(aT,UNIT_STATE_MANA,85.)
set aT=CreateUnit(qT,1211118406,-29862.1,29302.2,269.942)
call SetHeroLevel(aT,15,false)
set qT=null
set aT=null
endfunction
function oT takes nothing returns nothing
local player ST=Player(14)
local unit cT=CreateUnit(ST,1211118391,-30339.8,29950.4,270.397)
call SetHeroLevel(cT,15,false)
call SetUnitState(cT,UNIT_STATE_MANA,85.)
set cT=CreateUnit(ST,1211118406,-29968.7,29556.2,270.045)
call SetHeroLevel(cT,15,false)
set ST=null
set cT=null
endfunction
function rT takes nothing returns nothing
local player wT=Player(12)
local unit uT=CreateUnit(wT,1211118391,-30464.7,30089.7,270.515)
call SetHeroLevel(uT,15,false)
call SetUnitState(uT,UNIT_STATE_MANA,85.)
set uT=CreateUnit(wT,1211118406,-29962.2,29311.8,270.038)
call SetHeroLevel(uT,15,false)
set wT=null
set uT=null
endfunction
function xR takes nothing returns nothing
local player kR=Player(4)
local unit jR=CreateUnit(kR,1211118391,-30204.6,30339.2,270.267)
call SetHeroLevel(jR,15,false)
call SetUnitState(jR,UNIT_STATE_MANA,85.)
set jR=CreateUnit(kR,1211118406,-30106.5,29439.8,270.177)
call SetHeroLevel(jR,15,false)
set kR=null
set jR=null
endfunction
function xT takes nothing returns nothing
local player kT=Player(23)
local unit jT=CreateUnit(kT,1211118391,-29689.5,29824.6,269.779)
call SetHeroLevel(jT,15,false)
call SetUnitState(jT,UNIT_STATE_MANA,85.)
set jT=CreateUnit(kT,1211118406,-29815.4,29434.4,269.898)
call SetHeroLevel(jT,15,false)
set kT=null
set jT=null
endfunction
function QT takes nothing returns nothing
call nR()
call RR()
call GR()
call FR()
call xR()
call QR()
call ZR()
call PR()
call HR()
call LR()
call VR()
call MR()
call rT()
call iT()
call oT()
call bT()
call eT()
call nT()
call RT()
call GT()
call FT()
call xT()
endfunction
function eR takes nothing returns nothing
local integer pR=0
set pR=0
loop
exitwhen pR>8192
call CreateGroup()
set pR=pR+1
endloop
call CreateForce()
call CreateGroup()
call CreateForce()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateForce()
call CreateForce()
call CreateForce()
call CreateTimer()
call CreateForce()
call CreateGroup()
set w=CreateGroup()
call CreateGroup()
call CreateForce()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateTimer()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set r[pR]=0
set pR=pR+1
endloop
set s=CreateForce()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
call CreateGroup()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
call CreateForce()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
set l=CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
call CreateGroup()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateForce()
call CreateForce()
set pR=0
loop
exitwhen pR>1
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>1
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>1
set pR=pR+1
endloop
set b=CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
set pR=0
loop
exitwhen pR>24
set p[pR]=false
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set e[pR]=false
set pR=pR+1
endloop
endfunction
function AI takes nothing returns nothing
local trigger UI
local playerunitevent II
local integer PI
set ti=CreateTrigger()
set UI=ti
set II=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set PI=0
loop
call TriggerRegisterPlayerUnitEvent(UI,Player(PI),II,null)
set PI=PI+1
exitwhen PI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ti,Condition(Hq))
call TriggerAddAction(ti,Jq)
set UI=null
set II=null
endfunction
function BL takes nothing returns nothing
local trigger XL
local playerunitevent CL
local integer VL
set uS=CreateTrigger()
set XL=uS
set CL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set VL=0
loop
call TriggerRegisterPlayerUnitEvent(XL,Player(VL),CL,null)
set VL=VL+1
exitwhen VL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(uS,Condition(In))
call TriggerAddAction(uS,Pn)
set XL=null
set CL=null
endfunction
function BU takes nothing returns nothing
local trigger XU
local playerunitevent CU
local integer VU
set Nt=CreateTrigger()
set XU=Nt
set CU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set VU=0
loop
call TriggerRegisterPlayerUnitEvent(XU,Player(VU),CU,null)
set VU=VU+1
exitwhen VU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Nt,Condition(xq))
call TriggerAddAction(Nt,vq)
set XU=null
set CU=null
endfunction
function CF takes nothing returns nothing
local trigger KF
local playerunitevent LF
local integer XF
set Hs=CreateTrigger()
set KF=Hs
set LF=EVENT_PLAYER_UNIT_SPELL_CAST
set XF=0
loop
call TriggerRegisterPlayerUnitEvent(KF,Player(XF),LF,null)
set XF=XF+1
exitwhen XF==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Hs,Condition(np))
call TriggerAddAction(Hs,dp)
set KF=null
set LF=null
endfunction
function CI takes nothing returns nothing
local trigger KI
local playerunitevent LI
local integer XI
set ii=CreateTrigger()
set KI=ii
set LI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set XI=0
loop
call TriggerRegisterPlayerUnitEvent(KI,Player(XI),LI,null)
set XI=XI+1
exitwhen XI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ii,Condition(Kq))
call TriggerAddAction(ii,Lq)
set KI=null
set LI=null
endfunction
function DP takes nothing returns nothing
local trigger IP
local playerunitevent PP
local integer AP
set yi=CreateTrigger()
set IP=yi
set PP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set AP=0
loop
call TriggerRegisterPlayerUnitEvent(IP,Player(AP),PP,null)
set AP=AP+1
exitwhen AP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(yi,Condition(Sa))
call TriggerAddAction(yi,ca)
set IP=null
set PP=null
endfunction
function DZ takes nothing returns nothing
local trigger IZ
local playerunitevent PZ
local integer AZ
set Dt=CreateTrigger()
set IZ=Dt
set PZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set AZ=0
loop
call TriggerRegisterPlayerUnitEvent(IZ,Player(AZ),PZ,null)
set AZ=AZ+1
exitwhen AZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Dt,Condition(bq))
call TriggerAddAction(Dt,yq)
set IZ=null
set PZ=null
endfunction
function Dv takes nothing returns nothing
local trigger Iv
local playerunitevent Pv
local integer Av
set rt=CreateTrigger()
set Iv=rt
set Pv=EVENT_PLAYER_UNIT_DEATH
set Av=0
loop
call TriggerRegisterPlayerUnitEvent(Iv,Player(Av),Pv,null)
set Av=Av+1
exitwhen Av==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(rt,Condition(Ap))
call TriggerAddAction(rt,Dp)
set Iv=null
set Pv=null
endfunction
function EL takes nothing returns nothing
local trigger mL
local playerunitevent QL
local integer WL
set Mi=CreateTrigger()
set mL=Mi
set QL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set WL=0
loop
call TriggerRegisterPlayerUnitEvent(mL,Player(WL),QL,null)
set WL=WL+1
exitwhen WL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Mi,Condition(Wn))
call TriggerAddAction(Mi,En)
set mL=null
set QL=null
endfunction
function EU takes nothing returns nothing
local trigger mU
local playerunitevent QU
local integer WU
set Vt=CreateTrigger()
set mU=Vt
set QU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set WU=0
loop
call TriggerRegisterPlayerUnitEvent(mU,Player(WU),QU,null)
set WU=WU+1
exitwhen WU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Vt,Condition(hq))
call TriggerAddAction(Vt,Fq)
set mU=null
set QU=null
endfunction
function EW takes nothing returns nothing
local trigger mW
local playerunitevent QW
local integer WW
set gt=CreateTrigger()
set mW=gt
set QW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set WW=0
loop
call TriggerRegisterPlayerUnitEvent(mW,Player(WW),QW,null)
set WW=WW+1
exitwhen WW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gt,Condition(ve))
call TriggerAddAction(gt,me)
set mW=null
set QW=null
endfunction
function FP takes nothing returns nothing
local trigger GP
local playerunitevent gP
local integer hP
set li=CreateTrigger()
set GP=li
set gP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set hP=0
loop
call TriggerRegisterPlayerUnitEvent(GP,Player(hP),gP,null)
set hP=hP+1
exitwhen hP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(li,Condition(ra))
call TriggerAddAction(li,sa)
set GP=null
set gP=null
endfunction
function FY takes nothing returns nothing
local trigger GY
local playerunitevent gY
local integer hY
set hs=CreateTrigger()
set GY=hs
set gY=EVENT_PLAYER_UNIT_ATTACKED
set hY=0
loop
call TriggerRegisterPlayerUnitEvent(GY,Player(hY),gY,null)
set hY=hY+1
exitwhen hY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(hs,Condition(vy))
call TriggerAddAction(hs,my)
set GY=null
set gY=null
endfunction
function FZ takes nothing returns nothing
local trigger GZ
local playerunitevent gZ
local integer hZ
set Pt=CreateTrigger()
set GZ=Pt
set gZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set hZ=0
loop
call TriggerRegisterPlayerUnitEvent(GZ,Player(hZ),gZ,null)
set hZ=hZ+1
exitwhen hZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Pt,Condition(cq))
call TriggerAddAction(Pt,oq)
set GZ=null
set gZ=null
endfunction
function Gv takes nothing returns nothing
local trigger Rv
local playerunitevent Tv
local integer Yv
set ut=CreateTrigger()
set Rv=ut
set Tv=EVENT_PLAYER_UNIT_DEATH
set Yv=0
loop
call TriggerRegisterPlayerUnitEvent(Rv,Player(Yv),Tv,null)
set Yv=Yv+1
exitwhen Yv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ut,Condition(Ip))
call TriggerAddAction(ut,Pp)
set Rv=null
set Tv=null
endfunction
function HL takes nothing returns nothing
local trigger PL
local playerunitevent AL
local integer DL
set wS=CreateTrigger()
set PL=wS
set AL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set DL=0
loop
call TriggerRegisterPlayerUnitEvent(PL,Player(DL),AL,null)
set DL=DL+1
exitwhen DL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(wS,Condition(Zn))
call TriggerAddAction(wS,Un)
set PL=null
set AL=null
endfunction
function HT takes nothing returns nothing
set Ys=CreateTrigger()
call TriggerRegisterTimerEvent(Ys,1.00,false)
call TriggerAddAction(Ys,hy)
endfunction
function HU takes nothing returns nothing
local trigger PU
local playerunitevent AU
local integer DU
set Bt=CreateTrigger()
set PU=Bt
set AU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set DU=0
loop
call TriggerRegisterPlayerUnitEvent(PU,Player(DU),AU,null)
set DU=DU+1
exitwhen DU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Bt,Condition(kq))
call TriggerAddAction(Bt,jq)
set PU=null
set AU=null
endfunction
function HW takes nothing returns nothing
local trigger PW
local playerunitevent AW
local integer DW
set ht=CreateTrigger()
set PW=ht
set AW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set DW=0
loop
call TriggerRegisterPlayerUnitEvent(PW,Player(DW),AW,null)
set DW=DW+1
exitwhen DW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ht,Condition(Qe))
call TriggerAddAction(ht,We)
set PW=null
set AW=null
endfunction
function Ix takes nothing returns nothing
local trigger Ex
local playerunitevent Zx
local integer Ux
set Ns=CreateTrigger()
set Ex=Ns
set Zx=EVENT_PLAYER_UNIT_SPELL_CAST
set Ux=0
loop
call TriggerRegisterPlayerUnitEvent(Ex,Player(Ux),Zx,null)
set Ux=Ux+1
exitwhen Ux==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ns,Condition(Wp))
call TriggerAddAction(Ns,Ep)
set Ex=null
set Zx=null
endfunction
function JE takes nothing returns nothing
local trigger AE
local playerunitevent DE
local integer HE
set Wt=CreateTrigger()
set AE=Wt
set DE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set HE=0
loop
call TriggerRegisterPlayerUnitEvent(AE,Player(HE),DE,null)
set HE=HE+1
exitwhen HE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Wt,Condition(Be))
call TriggerAddAction(Wt,Ne)
set AE=null
set DE=null
endfunction
function KD takes nothing returns nothing
local trigger DD
local playerunitevent HD
local integer JD
set ki=CreateTrigger()
set DD=ki
set HD=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set JD=0
loop
call TriggerRegisterPlayerUnitEvent(DD,Player(JD),HD,null)
set JD=JD+1
exitwhen JD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(ki,Pa)
set DD=null
set HD=null
endfunction
function KK takes nothing returns nothing
local trigger DK
local playerunitevent HK
local integer JK
set Li=CreateTrigger()
set DK=Li
set HK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set JK=0
loop
call TriggerRegisterPlayerUnitEvent(DK,Player(JK),HK,null)
set JK=JK+1
exitwhen JK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Li,Condition(Tn))
call TriggerAddAction(Li,Yn)
set DK=null
set HK=null
endfunction
function KQ takes nothing returns nothing
local trigger DQ
local playerunitevent HQ
local integer JQ
set dt=CreateTrigger()
set DQ=dt
set HQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set JQ=0
loop
call TriggerRegisterPlayerUnitEvent(DQ,Player(JQ),HQ,null)
set JQ=JQ+1
exitwhen JQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(dt,Condition(de))
call TriggerAddAction(dt,fe)
set DQ=null
set HQ=null
endfunction
function LW takes nothing returns nothing
set Ft=CreateTrigger()
call TriggerRegisterTimerEvent(Ft,0.10,false)
call TriggerAddAction(Ft,Ze)
endfunction
function MK takes nothing returns nothing
local trigger VK
local playerunitevent BK
local integer NK
set Xi=CreateTrigger()
set VK=Xi
set BK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set NK=0
loop
call TriggerRegisterPlayerUnitEvent(VK,Player(NK),BK,null)
set NK=NK+1
exitwhen NK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Xi,Condition(Gn))
call TriggerAddAction(Xi,gn)
set VK=null
set BK=null
endfunction
function MQ takes nothing returns nothing
local trigger VQ
local playerunitevent BQ
local integer NQ
set ft=CreateTrigger()
set VQ=ft
set BQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set NQ=0
loop
call TriggerRegisterPlayerUnitEvent(VQ,Player(NQ),BQ,null)
set NQ=NQ+1
exitwhen NQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ft,Condition(Re))
call TriggerAddAction(ft,Te)
set VQ=null
set BQ=null
endfunction
function MZ takes nothing returns nothing
set Jt=CreateTrigger()
call TriggerRegisterTimerEvent(Jt,0.10,false)
call TriggerAddAction(Jt,aq)
endfunction
function NE takes nothing returns nothing
local trigger CE
local playerunitevent VE
local integer BE
set Et=CreateTrigger()
set CE=Et
set VE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set BE=0
loop
call TriggerRegisterPlayerUnitEvent(CE,Player(BE),VE,null)
set BE=BE+1
exitwhen BE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Et,Condition(Me))
call TriggerAddAction(Et,wq)
set CE=null
set VE=null
endfunction
function NI takes nothing returns nothing
set Si=CreateTrigger()
call TriggerRegisterTimerEvent(Si,0.10,false)
call TriggerAddAction(Si,Cq)
endfunction
function PA takes nothing returns nothing
local trigger ZA
local playerunitevent UA
local integer IA
set fi=CreateTrigger()
set ZA=fi
set UA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set IA=0
loop
call TriggerRegisterPlayerUnitEvent(ZA,Player(IA),UA,null)
set IA=IA+1
exitwhen IA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(fi,Condition(Ra))
call TriggerAddAction(fi,Ta)
set ZA=null
set UA=null
endfunction
function PD takes nothing returns nothing
local trigger ZD
local playerunitevent UD
local integer ID
set Fi=CreateTrigger()
set ZD=Fi
set UD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set ID=0
loop
call TriggerRegisterPlayerUnitEvent(ZD,Player(ID),UD,null)
set ID=ID+1
exitwhen ID==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Fi,Condition(Ua))
call TriggerAddAction(Fi,Ia)
set ZD=null
set UD=null
endfunction
function PJ takes nothing returns nothing
local trigger ZJ
local playerunitevent UJ
local integer IJ
set Ui=CreateTrigger()
set ZJ=Ui
set UJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set IJ=0
loop
call TriggerRegisterPlayerUnitEvent(ZJ,Player(IJ),UJ,null)
set IJ=IJ+1
exitwhen IJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ui,Condition(tn))
call TriggerAddAction(Ui,Sn)
set ZJ=null
set UJ=null
endfunction
function PT takes nothing returns nothing
set Rs=CreateTrigger()
call TriggerRegisterTimerEvent(Rs,70.00,false)
call TriggerAddAction(Rs,gy)
endfunction
function PY takes nothing returns nothing
local trigger ZY
local playerunitevent UY
local integer IY
set Fs=CreateTrigger()
set ZY=Fs
set UY=EVENT_PLAYER_UNIT_ATTACKED
set IY=0
loop
call TriggerRegisterPlayerUnitEvent(ZY,Player(IY),UY,null)
set IY=IY+1
exitwhen IY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Fs,Condition(Qy))
call TriggerAddAction(Fs,Wy)
set ZY=null
set UY=null
endfunction
function Pm takes nothing returns nothing
local trigger Zm
local playerunitevent Um
local integer Im
set lt=CreateTrigger()
set Zm=lt
set Um=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Im=0
loop
call TriggerRegisterPlayerUnitEvent(Zm,Player(Im),Um,null)
set Im=Im+1
exitwhen Im==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(lt,Condition(re))
call TriggerAddAction(lt,se)
set Zm=null
set Um=null
endfunction
function QI takes nothing returns nothing
local trigger xI
local playerunitevent vI
local integer mI
set si=CreateTrigger()
set xI=si
set vI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set mI=0
loop
call TriggerRegisterPlayerUnitEvent(xI,Player(mI),vI,null)
set mI=mI+1
exitwhen mI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(si,Condition(Aq))
call TriggerAddAction(si,Dq)
set xI=null
set vI=null
endfunction
function RH takes nothing returns nothing
local trigger nH
local playerunitevent dH
local integer fH
set xi=CreateTrigger()
set nH=xi
set dH=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set fH=0
loop
call TriggerRegisterPlayerUnitEvent(nH,Player(fH),dH,null)
set fH=fH+1
exitwhen fH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(xi,Condition(Ha))
call TriggerAddAction(xi,Ja)
set nH=null
set dH=null
endfunction
function RL takes nothing returns nothing
local trigger nL
local playerunitevent dL
local integer fL
set Bi=CreateTrigger()
set nL=Bi
set dL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set fL=0
loop
call TriggerRegisterPlayerUnitEvent(nL,Player(fL),dL,null)
set fL=fL+1
exitwhen fL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Bi,Condition(xn))
call TriggerAddAction(Bi,vn)
set nL=null
set dL=null
endfunction
function RU takes nothing returns nothing
local trigger nU
local playerunitevent dU
local integer fU
set Xt=CreateTrigger()
set nU=Xt
set dU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set fU=0
loop
call TriggerRegisterPlayerUnitEvent(nU,Player(fU),dU,null)
set fU=fU+1
exitwhen fU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Xt,Condition(Tq))
call TriggerAddAction(Xt,Yq)
set nU=null
set dU=null
endfunction
function RW takes nothing returns nothing
local trigger nW
local playerunitevent dW
local integer fW
set Yt=CreateTrigger()
set nW=Yt
set dW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set fW=0
loop
call TriggerRegisterPlayerUnitEvent(nW,Player(fW),dW,null)
set fW=fW+1
exitwhen fW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Yt,Condition(Fe))
call TriggerAddAction(Yt,ke)
set nW=null
set dW=null
endfunction
function SH takes nothing returns nothing
local trigger sH
local playerunitevent tH
local integer iH
set ji=CreateTrigger()
set sH=ji
set tH=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set iH=0
loop
call TriggerRegisterPlayerUnitEvent(sH,Player(iH),tH,null)
set iH=iH+1
exitwhen iH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ji,Condition(Aa))
call TriggerAddAction(ji,Da)
set sH=null
set tH=null
endfunction
function SL takes nothing returns nothing
local trigger sL
local playerunitevent tL
local integer iL
set Ci=CreateTrigger()
set sL=Ci
set tL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set iL=0
loop
call TriggerRegisterPlayerUnitEvent(sL,Player(iL),tL,null)
set iL=iL+1
exitwhen iL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ci,Condition(hn))
call TriggerAddAction(Ci,Fn)
set sL=null
set tL=null
endfunction
function SU takes nothing returns nothing
local trigger sU
local playerunitevent tU
local integer iU
set Kt=CreateTrigger()
set sU=Kt
set tU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set iU=0
loop
call TriggerRegisterPlayerUnitEvent(sU,Player(iU),tU,null)
set iU=iU+1
exitwhen iU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Kt,Condition(nq))
call TriggerAddAction(Kt,dq)
set sU=null
set tU=null
endfunction
function SW takes nothing returns nothing
local trigger sW
local playerunitevent tW
local integer iW
set Rt=CreateTrigger()
set sW=Rt
set tW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set iW=0
loop
call TriggerRegisterPlayerUnitEvent(sW,Player(iW),tW,null)
set iW=iW+1
exitwhen iW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Rt,Condition(Ye))
call TriggerAddAction(Rt,Ge)
set sW=null
set tW=null
endfunction
function TE takes nothing returns nothing
local trigger dE
local playerunitevent fE
local integer RE
set vt=CreateTrigger()
set dE=vt
set fE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set RE=0
loop
call TriggerRegisterPlayerUnitEvent(dE,Player(RE),fE,null)
set RE=RE+1
exitwhen RE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(vt,Condition(Je))
call TriggerAddAction(vt,Ke)
set dE=null
set fE=null
endfunction
function UK takes nothing returns nothing
local trigger WK
local playerunitevent EK
local integer ZK
set Ki=CreateTrigger()
set WK=Ki
set EK=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set ZK=0
loop
call TriggerRegisterPlayerUnitEvent(WK,Player(ZK),EK,null)
set ZK=ZK+1
exitwhen ZK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ki,Condition(fn))
call TriggerAddAction(Ki,Rn)
set WK=null
set EK=null
endfunction
function UQ takes nothing returns nothing
local trigger WQ
local playerunitevent EQ
local integer ZQ
set nt=CreateTrigger()
set WQ=nt
set EQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set ZQ=0
loop
call TriggerRegisterPlayerUnitEvent(WQ,Player(ZQ),EQ,null)
set ZQ=ZQ+1
exitwhen ZQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(nt,Condition(ae))
call TriggerAddAction(nt,ne)
set WQ=null
set EQ=null
endfunction
function VH takes nothing returns nothing
local trigger LH
local playerunitevent XH
local integer CH
set mi=CreateTrigger()
set LH=mi
set XH=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set CH=0
loop
call TriggerRegisterPlayerUnitEvent(LH,Player(CH),XH,null)
set CH=CH+1
exitwhen CH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(mi,Condition(Xa))
call TriggerAddAction(mi,Ca)
set LH=null
set XH=null
endfunction
function VP takes nothing returns nothing
local trigger LP
local playerunitevent XP
local integer CP
set pi=CreateTrigger()
set LP=pi
set XP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set CP=0
loop
call TriggerRegisterPlayerUnitEvent(LP,Player(CP),XP,null)
set CP=CP+1
exitwhen CP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(pi,Condition(oa))
call TriggerAddAction(pi,Oa)
set LP=null
set XP=null
endfunction
function VY takes nothing returns nothing
local trigger LY
local playerunitevent XY
local integer CY
set ks=CreateTrigger()
set LY=ks
set XY=EVENT_PLAYER_UNIT_SPELL_CAST
set CY=0
loop
call TriggerRegisterPlayerUnitEvent(LY,Player(CY),XY,null)
set CY=CY+1
exitwhen CY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ks,Condition(Ey))
call TriggerAddAction(ks,Zy)
set LY=null
set XY=null
endfunction
function VZ takes nothing returns nothing
local trigger LZ
local playerunitevent XZ
local integer CZ
set Ht=CreateTrigger()
set LZ=Ht
set XZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set CZ=0
loop
call TriggerRegisterPlayerUnitEvent(LZ,Player(CZ),XZ,null)
set CZ=CZ+1
exitwhen CZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ht,Condition(pq))
call TriggerAddAction(Ht,eq)
set LZ=null
set XZ=null
endfunction
function Vv takes nothing returns nothing
local trigger Lv
local playerunitevent Xv
local integer Cv
set st=CreateTrigger()
set Lv=st
set Xv=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Cv=0
loop
call TriggerRegisterPlayerUnitEvent(Lv,Player(Cv),Xv,null)
set Cv=Cv+1
exitwhen Cv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(st,Condition(Hp))
call TriggerAddAction(st,Jp)
set Lv=null
set Xv=null
endfunction
function WH takes nothing returns nothing
local trigger vH
local playerunitevent mH
local integer QH
set vi=CreateTrigger()
set vH=vi
set mH=EVENT_PLAYER_UNIT_SPELL_CAST
set QH=0
loop
call TriggerRegisterPlayerUnitEvent(vH,Player(QH),mH,null)
set QH=QH+1
exitwhen QH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(vi,Condition(Ka))
call TriggerAddAction(vi,La)
set vH=null
set mH=null
endfunction
function WP takes nothing returns nothing
local trigger vP
local playerunitevent mP
local integer QP
set bi=CreateTrigger()
set vP=bi
set mP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set QP=0
loop
call TriggerRegisterPlayerUnitEvent(vP,Player(QP),mP,null)
set QP=QP+1
exitwhen QP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(bi,Condition(ta))
call TriggerAddAction(bi,ia)
set vP=null
set mP=null
endfunction
function WZ takes nothing returns nothing
local trigger vZ
local playerunitevent mZ
local integer QZ
set At=CreateTrigger()
set vZ=At
set mZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set QZ=0
loop
call TriggerRegisterPlayerUnitEvent(vZ,Player(QZ),mZ,null)
set QZ=QZ+1
exitwhen QZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(At,Condition(Oq))
call TriggerAddAction(At,lq)
set vZ=null
set mZ=null
endfunction
function Wk takes nothing returns nothing
local trigger vk
local playerunitevent mk
local integer Qk
set Ks=CreateTrigger()
set vk=Ks
set mk=EVENT_PLAYER_UNIT_SPELL_CAST
set Qk=0
loop
call TriggerRegisterPlayerUnitEvent(vk,Player(Qk),mk,null)
set Qk=Qk+1
exitwhen Qk==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ks,Condition(Tp))
call TriggerAddAction(Ks,Yp)
set vk=null
set mk=null
endfunction
function XA takes nothing returns nothing
local trigger JA
local playerunitevent KA
local integer LA
set Ri=CreateTrigger()
set JA=Ri
set KA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set LA=0
loop
call TriggerRegisterPlayerUnitEvent(JA,Player(LA),KA,null)
set LA=LA+1
exitwhen LA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ri,Condition(Ya))
call TriggerAddAction(Ri,Ga)
set JA=null
set KA=null
endfunction
function XG takes nothing returns nothing
local trigger JG
local playerunitevent KG
local integer LG
set ms=CreateTrigger()
set JG=ms
set KG=EVENT_PLAYER_UNIT_SPELL_CAST
set LG=0
loop
call TriggerRegisterPlayerUnitEvent(JG,Player(LG),KG,null)
set LG=LG+1
exitwhen LG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ms,Condition(Hy))
call TriggerAddAction(ms,Jy)
set JG=null
set KG=null
endfunction
function XJ takes nothing returns nothing
local trigger JJ
local playerunitevent KJ
local integer LJ
set Ii=CreateTrigger()
set JJ=Ii
set KJ=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set LJ=0
loop
call TriggerRegisterPlayerUnitEvent(JJ,Player(LJ),KJ,null)
set LJ=LJ+1
exitwhen LJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ii,Condition(cn))
call TriggerAddAction(Ii,on)
set JJ=null
set KJ=null
endfunction
function Xg takes nothing returns nothing
local trigger Jg
local playerunitevent Kg
local integer Lg
set Es=CreateTrigger()
set Jg=Es
set Kg=EVENT_PLAYER_UNIT_SPELL_CAST
set Lg=0
loop
call TriggerRegisterPlayerUnitEvent(Jg,Player(Lg),Kg,null)
set Lg=Lg+1
exitwhen Lg==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Es,Condition(My))
call TriggerAddAction(Es,wp)
set Jg=null
set Kg=null
endfunction
function Xh takes nothing returns nothing
local trigger Jh
local playerunitevent Kh
local integer Lh
set Is=CreateTrigger()
set Jh=Is
set Kh=EVENT_PLAYER_UNIT_SPELL_CAST
set Lh=0
loop
call TriggerRegisterPlayerUnitEvent(Jh,Player(Lh),Kh,null)
set Lh=Lh+1
exitwhen Lh==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Is,Condition(op))
call TriggerAddAction(Is,Op)
set Jh=null
set Kh=null
endfunction
function Xm takes nothing returns nothing
local trigger Jm
local playerunitevent Km
local integer Lm
set bt=CreateTrigger()
set Jm=bt
set Km=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Lm=0
loop
call TriggerRegisterPlayerUnitEvent(Jm,Player(Lm),Km,null)
set Lm=Lm+1
exitwhen Lm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(bt,Condition(te))
call TriggerAddAction(bt,ie)
set Jm=null
set Km=null
endfunction
function YD takes nothing returns nothing
local trigger fD
local playerunitevent RD
local integer TD
set gi=CreateTrigger()
set fD=gi
set RD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set TD=0
loop
call TriggerRegisterPlayerUnitEvent(fD,Player(TD),RD,null)
set TD=TD+1
exitwhen TD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gi,Condition(va))
call TriggerAddAction(gi,ma)
set fD=null
set RD=null
endfunction
function YK takes nothing returns nothing
local trigger fK
local playerunitevent RK
local integer TK
set Hi=CreateTrigger()
set fK=Hi
set RK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set TK=0
loop
call TriggerRegisterPlayerUnitEvent(fK,Player(TK),RK,null)
set TK=TK+1
exitwhen TK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Hi,Condition(qn))
call TriggerAddAction(Hi,an)
set fK=null
set RK=null
endfunction
function YQ takes nothing returns nothing
local trigger fQ
local playerunitevent RQ
local integer TQ
set qt=CreateTrigger()
set fQ=qt
set RQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set TQ=0
loop
call TriggerRegisterPlayerUnitEvent(fQ,Player(TQ),RQ,null)
set TQ=TQ+1
exitwhen TQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(qt,Condition(ye))
call TriggerAddAction(qt,pe)
set fQ=null
set RQ=null
endfunction
function ZE takes nothing returns nothing
local trigger QE
local playerunitevent WE
local integer EE
set Qt=CreateTrigger()
set QE=Qt
set WE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set EE=0
loop
call TriggerRegisterPlayerUnitEvent(QE,Player(EE),WE,null)
set EE=EE+1
exitwhen EE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Qt,Condition(Ce))
call TriggerAddAction(Qt,Ve)
set QE=null
set WE=null
endfunction
function Zj takes nothing returns nothing
local trigger Qj
local playerunitevent Wj
local integer Ej
set Cs=CreateTrigger()
set Qj=Cs
set Wj=EVENT_PLAYER_UNIT_DEATH
set Ej=0
loop
call TriggerRegisterPlayerUnitEvent(Qj,Player(Ej),Wj,null)
set Ej=Ej+1
exitwhen Ej==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Cs,Condition(kp))
call TriggerAddAction(Cs,jp)
set Qj=null
set Wj=null
endfunction
function bF takes nothing returns nothing
local trigger oF
local playerunitevent OF
local integer lF
set Ps=CreateTrigger()
set oF=Ps
set OF=EVENT_PLAYER_UNIT_SPELL_CAST
set lF=0
loop
call TriggerRegisterPlayerUnitEvent(oF,Player(lF),OF,null)
set lF=lF+1
exitwhen lF==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ps,Condition(bp))
call TriggerAddAction(Ps,yp)
set oF=null
set OF=null
endfunction
function bI takes nothing returns nothing
local trigger oI
local playerunitevent OI
local integer lI
set wi=CreateTrigger()
set oI=wi
set OI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set lI=0
loop
call TriggerRegisterPlayerUnitEvent(oI,Player(lI),OI,null)
set lI=lI+1
exitwhen lI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(wi,Condition(Wq))
call TriggerAddAction(wi,Eq)
set oI=null
set OI=null
endfunction
function bg takes nothing returns nothing
local trigger og
local playerunitevent Og
local integer lg
set Qs=CreateTrigger()
set og=Qs
set Og=EVENT_PLAYER_UNIT_SPELL_CAST
set lg=0
loop
call TriggerRegisterPlayerUnitEvent(og,Player(lg),Og,null)
set lg=lg+1
exitwhen lg==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Qs,Condition(Ly))
call TriggerAddAction(Qs,Xy)
set og=null
set Og=null
endfunction
function bh takes nothing returns nothing
local trigger oh
local playerunitevent Oh
local integer lh
set Zs=CreateTrigger()
set oh=Zs
set Oh=EVENT_PLAYER_UNIT_SPELL_CAST
set lh=0
loop
call TriggerRegisterPlayerUnitEvent(oh,Player(lh),Oh,null)
set lh=lh+1
exitwhen lh==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Zs,Condition(rp))
call TriggerAddAction(Zs,sp)
set oh=null
set Oh=null
endfunction
function cE takes nothing returns nothing
local trigger tE
local playerunitevent iE
local integer SE
set jt=CreateTrigger()
set tE=jt
set iE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set SE=0
loop
call TriggerRegisterPlayerUnitEvent(tE,Player(SE),iE,null)
set SE=SE+1
exitwhen SE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(jt,Condition(Pe))
call TriggerAddAction(jt,Ae)
set tE=null
set iE=null
endfunction
function dI takes nothing returns nothing
local trigger qI
local playerunitevent aI
local integer nI
set ui=CreateTrigger()
set qI=ui
set aI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set nI=0
loop
call TriggerRegisterPlayerUnitEvent(qI,Player(nI),aI,null)
set nI=nI+1
exitwhen nI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ui,Condition(Zq))
call TriggerAddAction(ui,Uq)
set qI=null
set aI=null
endfunction
function dj takes nothing returns nothing
local trigger qj
local playerunitevent aj
local integer nj
set Xs=CreateTrigger()
set qj=Xs
set aj=EVENT_PLAYER_UNIT_DEATH
set nj=0
loop
call TriggerRegisterPlayerUnitEvent(qj,Player(nj),aj,null)
set nj=nj+1
exitwhen nj==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Xs,Condition(hp))
call TriggerAddAction(Xs,Fp)
set qj=null
set aj=null
endfunction
function dx takes nothing returns nothing
local trigger qx
local playerunitevent ax
local integer nx
set Bs=CreateTrigger()
set qx=Bs
set ax=EVENT_PLAYER_UNIT_DEATH
set nx=0
loop
call TriggerRegisterPlayerUnitEvent(qx,Player(nx),ax,null)
set nx=nx+1
exitwhen nx==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Bs,Condition(mp))
call TriggerAddAction(Bs,Qp)
set qx=null
set ax=null
endfunction
function eE takes nothing returns nothing
local trigger bE
local playerunitevent yE
local integer pE
set xt=CreateTrigger()
set bE=xt
set yE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set pE=0
loop
call TriggerRegisterPlayerUnitEvent(bE,Player(pE),yE,null)
set pE=pE+1
exitwhen pE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(xt,Condition(De))
call TriggerAddAction(xt,He)
set bE=null
set yE=null
endfunction
function eY takes nothing returns nothing
local trigger bY
local playerunitevent yY
local integer pY
set gs=CreateTrigger()
set bY=gs
set yY=EVENT_PLAYER_UNIT_ATTACKED
set pY=0
loop
call TriggerRegisterPlayerUnitEvent(bY,Player(pY),yY,null)
set pY=pY+1
exitwhen pY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gs,Condition(jy))
call TriggerAddAction(gs,xy)
set bY=null
set yY=null
endfunction
function ek takes nothing returns nothing
local trigger bk
local playerunitevent yk
local integer pk
set Js=CreateTrigger()
set bk=Js
set yk=EVENT_PLAYER_UNIT_SPELL_CAST
set pk=0
loop
call TriggerRegisterPlayerUnitEvent(bk,Player(pk),yk,null)
set pk=pk+1
exitwhen pk==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Js,Condition(fp))
call TriggerAddAction(Js,Rp)
set bk=null
set yk=null
endfunction
function fF takes nothing returns nothing
set As=CreateTrigger()
call TriggerRegisterTimerEvent(As,5.00,true)
call TriggerAddAction(As,ep)
endfunction
function fP takes nothing returns nothing
local trigger aP
local playerunitevent nP
local integer dP
set Oi=CreateTrigger()
set aP=Oi
set nP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set dP=0
loop
call TriggerRegisterPlayerUnitEvent(aP,Player(dP),nP,null)
set dP=dP+1
exitwhen dP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Oi,Condition(wa))
call TriggerAddAction(Oi,ua)
set aP=null
set nP=null
endfunction
function fZ takes nothing returns nothing
local trigger aZ
local playerunitevent nZ
local integer dZ
set It=CreateTrigger()
set aZ=It
set nZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set dZ=0
loop
call TriggerRegisterPlayerUnitEvent(aZ,Player(dZ),nZ,null)
set dZ=dZ+1
exitwhen dZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(It,Condition(iq))
call TriggerAddAction(It,Sq)
set aZ=null
set nZ=null
endfunction
function gA takes nothing returns nothing
local trigger TA
local playerunitevent YA
local integer GA
set ni=CreateTrigger()
set TA=ni
set YA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set GA=0
loop
call TriggerRegisterPlayerUnitEvent(TA,Player(GA),YA,null)
set GA=GA+1
exitwhen GA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ni,Condition(aa))
call TriggerAddAction(ni,na)
set TA=null
set YA=null
endfunction
function gJ takes nothing returns nothing
local trigger TJ
local playerunitevent YJ
local integer GJ
set Ei=CreateTrigger()
set TJ=Ei
set YJ=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set GJ=0
loop
call TriggerRegisterPlayerUnitEvent(TJ,Player(GJ),YJ,null)
set GJ=GJ+1
exitwhen GJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ei,Condition(wn))
call TriggerAddAction(Ei,un)
set TJ=null
set YJ=null
endfunction
function gm takes nothing returns nothing
local trigger Tm
local playerunitevent Ym
local integer Gm
set ot=CreateTrigger()
set Tm=ot
set Ym=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Gm=0
loop
call TriggerRegisterPlayerUnitEvent(Tm,Player(Gm),Ym,null)
set Gm=Gm+1
exitwhen Gm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ot,Condition(Np))
call TriggerAddAction(ot,Mp)
set Tm=null
set Ym=null
endfunction
function hD takes nothing returns nothing
set hi=CreateTrigger()
call TriggerRegisterTimerEvent(hi,0.10,false)
call TriggerAddAction(hi,Wa)
endfunction
function hI takes nothing returns nothing
local trigger YI
local playerunitevent GI
local integer gI
set ri=CreateTrigger()
set YI=ri
set GI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set gI=0
loop
call TriggerRegisterPlayerUnitEvent(YI,Player(gI),GI,null)
set gI=gI+1
exitwhen gI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ri,Condition(Iq))
call TriggerAddAction(ri,Pq)
set YI=null
set GI=null
endfunction
function iP takes nothing returns nothing
local trigger rP
local playerunitevent sP
local integer tP
set ci=CreateTrigger()
set rP=ci
set sP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set tP=0
loop
call TriggerRegisterPlayerUnitEvent(rP,Player(tP),sP,null)
set tP=tP+1
exitwhen tP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ci,Condition(Vq))
call TriggerAddAction(ci,Bq)
set rP=null
set sP=null
endfunction
function iZ takes nothing returns nothing
local trigger rZ
local playerunitevent sZ
local integer tZ
set Zt=CreateTrigger()
set rZ=Zt
set sZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set tZ=0
loop
call TriggerRegisterPlayerUnitEvent(rZ,Player(tZ),sZ,null)
set tZ=tZ+1
exitwhen tZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Zt,Condition(uq))
call TriggerAddAction(Zt,rq)
set rZ=null
set sZ=null
endfunction
function iv takes nothing returns nothing
local trigger rv
local playerunitevent sv
local integer tv
set Ms=CreateTrigger()
set rv=Ms
set sv=EVENT_PLAYER_UNIT_SPELL_CAST
set tv=0
loop
call TriggerRegisterPlayerUnitEvent(rv,Player(tv),sv,null)
set tv=tv+1
exitwhen tv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ms,Condition(Zp))
call TriggerAddAction(Ms,Up)
set rv=null
set sv=null
endfunction
function jE takes nothing returns nothing
local trigger hE
local playerunitevent FE
local integer kE
set mt=CreateTrigger()
set hE=mt
set FE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set kE=0
loop
call TriggerRegisterPlayerUnitEvent(hE,Player(kE),FE,null)
set kE=kE+1
exitwhen kE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(mt,Condition(Le))
call TriggerAddAction(mt,Xe)
set hE=null
set FE=null
endfunction
function jG takes nothing returns nothing
local trigger hG
local playerunitevent FG
local integer kG
set vs=CreateTrigger()
set hG=vs
set FG=EVENT_PLAYER_UNIT_SPELL_CAST
set kG=0
loop
call TriggerRegisterPlayerUnitEvent(hG,Player(kG),FG,null)
set kG=kG+1
exitwhen kG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(vs,Ay)
set hG=null
set FG=null
endfunction
function jg takes nothing returns nothing
local trigger hg
local playerunitevent Fg
local integer kg
set Ws=CreateTrigger()
set hg=Ws
set Fg=EVENT_PLAYER_UNIT_SPELL_CAST
set kg=0
loop
call TriggerRegisterPlayerUnitEvent(hg,Player(kg),Fg,null)
set kg=kg+1
exitwhen kg==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ws,Condition(Vy))
call TriggerAddAction(Ws,By)
set hg=null
set Fg=null
endfunction
function jh takes nothing returns nothing
local trigger hh
local playerunitevent Fh
local integer kh
set Us=CreateTrigger()
set hh=Us
set Fh=EVENT_PLAYER_UNIT_SPELL_CAST
set kh=0
loop
call TriggerRegisterPlayerUnitEvent(hh,Player(kh),Fh,null)
set kh=kh+1
exitwhen kh==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Us,Condition(ip))
call TriggerAddAction(Us,Sp)
set hh=null
set Fh=null
endfunction
function kF takes nothing returns nothing
set Ds=CreateTrigger()
call TriggerRegisterTimerEvent(Ds,5.00,true)
call TriggerAddAction(Ds,ap)
endfunction
function kL takes nothing returns nothing
local trigger gL
local playerunitevent hL
local integer FL
set Ni=CreateTrigger()
set gL=Ni
set hL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set FL=0
loop
call TriggerRegisterPlayerUnitEvent(gL,Player(FL),hL,null)
set FL=FL+1
exitwhen FL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ni,Condition(mn))
call TriggerAddAction(Ni,Qn)
set gL=null
set hL=null
endfunction
function kU takes nothing returns nothing
local trigger gU
local playerunitevent hU
local integer FU
set Ct=CreateTrigger()
set gU=Ct
set hU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set FU=0
loop
call TriggerRegisterPlayerUnitEvent(gU,Player(FU),hU,null)
set FU=FU+1
exitwhen FU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ct,Condition(Gq))
call TriggerAddAction(Ct,gq)
set gU=null
set hU=null
endfunction
function kW takes nothing returns nothing
local trigger gW
local playerunitevent hW
local integer FW
set Gt=CreateTrigger()
set gW=Gt
set hW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set FW=0
loop
call TriggerRegisterPlayerUnitEvent(gW,Player(FW),hW,null)
set FW=FW+1
exitwhen FW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Gt,Condition(je))
call TriggerAddAction(Gt,xe)
set gW=null
set hW=null
endfunction
function lA takes nothing returns nothing
local trigger cA
local playerunitevent oA
local integer OA
set qi=CreateTrigger()
set cA=qi
set oA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set OA=0
loop
call TriggerRegisterPlayerUnitEvent(cA,Player(OA),oA,null)
set OA=OA+1
exitwhen OA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(qi,Condition(ya))
call TriggerAddAction(qi,pa)
set cA=null
set oA=null
endfunction
function lJ takes nothing returns nothing
local trigger cJ
local playerunitevent oJ
local integer OJ
set Qi=CreateTrigger()
set cJ=Qi
set oJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set OJ=0
loop
call TriggerRegisterPlayerUnitEvent(cJ,Player(OJ),oJ,null)
set OJ=OJ+1
exitwhen OJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Qi,Condition(Va))
call TriggerAddAction(Qi,Ba)
set cJ=null
set oJ=null
endfunction
function lm takes nothing returns nothing
local trigger cm
local playerunitevent om
local integer Om
set St=CreateTrigger()
set cm=St
set om=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Om=0
loop
call TriggerRegisterPlayerUnitEvent(cm,Player(Om),om,null)
set Om=Om+1
exitwhen Om==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(St,Condition(Xp))
call TriggerAddAction(St,Cp)
set cm=null
set om=null
endfunction
function mA takes nothing returns nothing
local trigger jA
local playerunitevent xA
local integer vA
set di=CreateTrigger()
set jA=di
set xA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set vA=0
loop
call TriggerRegisterPlayerUnitEvent(jA,Player(vA),xA,null)
set vA=vA+1
exitwhen vA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(di,Condition(da))
call TriggerAddAction(di,fa)
set jA=null
set xA=null
endfunction
function mJ takes nothing returns nothing
local trigger jJ
local playerunitevent xJ
local integer vJ
set Zi=CreateTrigger()
set jJ=Zi
set xJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set vJ=0
loop
call TriggerRegisterPlayerUnitEvent(jJ,Player(vJ),xJ,null)
set vJ=vJ+1
exitwhen vJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Zi,Condition(rn))
call TriggerAddAction(Zi,sn)
set jJ=null
set xJ=null
endfunction
function mm takes nothing returns nothing
local trigger jm
local playerunitevent xm
local integer vm
set Ot=CreateTrigger()
set jm=Ot
set xm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set vm=0
loop
call TriggerRegisterPlayerUnitEvent(jm,Player(vm),xm,null)
set vm=vm+1
exitwhen vm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ot,Condition(we))
call TriggerAddAction(Ot,ue)
set jm=null
set xm=null
endfunction
function nA takes nothing returns nothing
local trigger eA
local playerunitevent qA
local integer aA
set ai=CreateTrigger()
set eA=ai
set qA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set aA=0
loop
call TriggerRegisterPlayerUnitEvent(eA,Player(aA),qA,null)
set aA=aA+1
exitwhen aA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ai,Condition(ea))
call TriggerAddAction(ai,qa)
set eA=null
set qA=null
endfunction
function nJ takes nothing returns nothing
local trigger eJ
local playerunitevent qJ
local integer aJ
set Wi=CreateTrigger()
set eJ=Wi
set qJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set aJ=0
loop
call TriggerRegisterPlayerUnitEvent(eJ,Player(aJ),qJ,null)
set aJ=aJ+1
exitwhen aJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Wi,Condition(Na))
call TriggerAddAction(Wi,Ma)
set eJ=null
set qJ=null
endfunction
function nm takes nothing returns nothing
local trigger em
local playerunitevent qm
local integer am
set ct=CreateTrigger()
set em=ct
set qm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set am=0
loop
call TriggerRegisterPlayerUnitEvent(em,Player(am),qm,null)
set am=am+1
exitwhen am==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ct,Condition(Vp))
call TriggerAddAction(ct,Bp)
set em=null
set qm=null
endfunction
function oD takes nothing returns nothing
local trigger iD
local playerunitevent SD
local integer cD
set Yi=CreateTrigger()
set iD=Yi
set SD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set cD=0
loop
call TriggerRegisterPlayerUnitEvent(iD,Player(cD),SD,null)
set cD=cD+1
exitwhen cD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Yi,Condition(Fa))
call TriggerAddAction(Yi,ka)
set iD=null
set SD=null
endfunction
function oK takes nothing returns nothing
local trigger iK
local playerunitevent SK
local integer cK
set Ai=CreateTrigger()
set iK=Ai
set SK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set cK=0
loop
call TriggerRegisterPlayerUnitEvent(iK,Player(cK),SK,null)
set cK=cK+1
exitwhen cK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ai,Condition(bn))
call TriggerAddAction(Ai,yn)
set iK=null
set SK=null
endfunction
function oQ takes nothing returns nothing
local trigger iQ
local playerunitevent SQ
local integer cQ
set pt=CreateTrigger()
set iQ=pt
set SQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set cQ=0
loop
call TriggerRegisterPlayerUnitEvent(iQ,Player(cQ),SQ,null)
set cQ=cQ+1
exitwhen cQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(pt,Condition(oe))
call TriggerAddAction(pt,Oe)
set iQ=null
set SQ=null
endfunction
function pL takes nothing returns nothing
local trigger lL
local playerunitevent bL
local integer yL
set Vi=CreateTrigger()
set lL=Vi
set bL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set yL=0
loop
call TriggerRegisterPlayerUnitEvent(lL,Player(yL),bL,null)
set yL=yL+1
exitwhen yL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Vi,Condition(kn))
call TriggerAddAction(Vi,jn)
set lL=null
set bL=null
endfunction
function pU takes nothing returns nothing
local trigger lU
local playerunitevent bU
local integer yU
set Lt=CreateTrigger()
set lU=Lt
set bU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set yU=0
loop
call TriggerRegisterPlayerUnitEvent(lU,Player(yU),bU,null)
set yU=yU+1
exitwhen yU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Lt,Condition(fq))
call TriggerAddAction(Lt,Rq)
set lU=null
set bU=null
endfunction
function pW takes nothing returns nothing
local trigger lW
local playerunitevent bW
local integer yW
set Tt=CreateTrigger()
set lW=Tt
set bW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set yW=0
loop
call TriggerRegisterPlayerUnitEvent(lW,Player(yW),bW,null)
set yW=yW+1
exitwhen yW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Tt,Condition(ge))
call TriggerAddAction(Tt,he)
set lW=null
set bW=null
endfunction
function qD takes nothing returns nothing
local trigger yD
local playerunitevent pD
local integer eD
set Gi=CreateTrigger()
set yD=Gi
set pD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set eD=0
loop
call TriggerRegisterPlayerUnitEvent(yD,Player(eD),pD,null)
set eD=eD+1
exitwhen eD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Gi,Condition(ja))
call TriggerAddAction(Gi,xa)
set yD=null
set pD=null
endfunction
function qG takes nothing returns nothing
local trigger yG
local playerunitevent pG
local integer eG
set xs=CreateTrigger()
set yG=xs
set pG=EVENT_PLAYER_UNIT_SPELL_CAST
set eG=0
loop
call TriggerRegisterPlayerUnitEvent(yG,Player(eG),pG,null)
set eG=eG+1
exitwhen eG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(xs,Py)
set yG=null
set pG=null
endfunction
function qK takes nothing returns nothing
local trigger yK
local playerunitevent pK
local integer eK
set Di=CreateTrigger()
set yK=Di
set pK=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set eK=0
loop
call TriggerRegisterPlayerUnitEvent(yK,Player(eK),pK,null)
set eK=eK+1
exitwhen eK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Di,Condition(pn))
call TriggerAddAction(Di,en)
set yK=null
set pK=null
endfunction
function qQ takes nothing returns nothing
local trigger yQ
local playerunitevent pQ
local integer eQ
set et=CreateTrigger()
set yQ=et
set pQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set eQ=0
loop
call TriggerRegisterPlayerUnitEvent(yQ,Player(eQ),pQ,null)
set eQ=eQ+1
exitwhen eQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(et,Condition(le))
call TriggerAddAction(et,be)
set yQ=null
set pQ=null
endfunction
function rG takes nothing returns nothing
local trigger MY
local playerunitevent wG
local integer uG
set js=CreateTrigger()
set MY=js
set wG=EVENT_PLAYER_UNIT_SPELL_EFFECT
set uG=0
loop
call TriggerRegisterPlayerUnitEvent(MY,Player(uG),wG,null)
set uG=uG+1
exitwhen uG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(js,Condition(Uy))
call TriggerAddAction(js,Iy)
set MY=null
set wG=null
endfunction
function rY takes nothing returns nothing
local trigger MT
local playerunitevent wY
local integer uY
set Gs=CreateTrigger()
set MT=Gs
set wY=EVENT_PLAYER_UNIT_ATTACKED
set uY=0
loop
call TriggerRegisterPlayerUnitEvent(MT,Player(uY),wY,null)
set uY=uY+1
exitwhen uY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Gs,Condition(Fy))
call TriggerAddAction(Gs,ky)
set MT=null
set wY=null
endfunction
function sA takes nothing returns nothing
local trigger wA
local playerunitevent uA
local integer rA
set ei=CreateTrigger()
set wA=ei
set uA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set rA=0
loop
call TriggerRegisterPlayerUnitEvent(wA,Player(rA),uA,null)
set rA=rA+1
exitwhen rA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ei,Condition(la))
call TriggerAddAction(ei,ba)
set wA=null
set uA=null
endfunction
function sm takes nothing returns nothing
local trigger wm
local playerunitevent um
local integer rm
set tt=CreateTrigger()
set wm=tt
set um=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set rm=0
loop
call TriggerRegisterPlayerUnitEvent(wm,Player(rm),um,null)
set rm=rm+1
exitwhen rm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(tt,Condition(Kp))
call TriggerAddAction(tt,Lp)
set wm=null
set um=null
endfunction
function tI takes nothing returns nothing
local trigger uI
local playerunitevent rI
local integer sI
set Mt=CreateTrigger()
set uI=Mt
set rI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set sI=0
loop
call TriggerRegisterPlayerUnitEvent(uI,Player(sI),rI,null)
set sI=sI+1
exitwhen sI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Mt,Condition(mq))
call TriggerAddAction(Mt,Qq)
set uI=null
set rI=null
endfunction
function tX takes nothing returns nothing
local trigger uX
local playerunitevent rX
local integer sX
set rS=CreateTrigger()
set uX=rS
set rX=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set sX=0
loop
call TriggerRegisterPlayerUnitEvent(uX,Player(sX),rX,null)
set sX=sX+1
exitwhen sX==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(rS,Condition(An))
call TriggerAddAction(rS,Dn)
set uX=null
set rX=null
endfunction
function uD takes nothing returns nothing
local trigger NA
local playerunitevent MA
local integer wD
set Ti=CreateTrigger()
set NA=Ti
set MA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set wD=0
loop
call TriggerRegisterPlayerUnitEvent(NA,Player(wD),MA,null)
set wD=wD+1
exitwhen wD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ti,Condition(ga))
call TriggerAddAction(Ti,ha)
set NA=null
set MA=null
endfunction
function uK takes nothing returns nothing
local trigger NJ
local playerunitevent MJ
local integer wK
set Pi=CreateTrigger()
set NJ=Pi
set MJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set wK=0
loop
call TriggerRegisterPlayerUnitEvent(NJ,Player(wK),MJ,null)
set wK=wK+1
exitwhen wK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Pi,Condition(On))
call TriggerAddAction(Pi,ln)
set NJ=null
set MJ=null
endfunction
function uQ takes nothing returns nothing
local trigger Nm
local playerunitevent Mm
local integer wQ
set yt=CreateTrigger()
set Nm=yt
set Mm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set wQ=0
loop
call TriggerRegisterPlayerUnitEvent(Nm,Player(wQ),Mm,null)
set wQ=wQ+1
exitwhen wQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(yt,Condition(Se))
call TriggerAddAction(yt,ce)
set Nm=null
set Mm=null
endfunction
function uj takes nothing returns nothing
local trigger Nk
local playerunitevent Mk
local integer wj
set Ls=CreateTrigger()
set Nk=Ls
set Mk=EVENT_PLAYER_UNIT_SPELL_CAST
set wj=0
loop
call TriggerRegisterPlayerUnitEvent(Nk,Player(wj),Mk,null)
set wj=wj+1
exitwhen wj==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ls,Condition(Gp))
call TriggerAddAction(Ls,gp)
set Nk=null
set Mk=null
endfunction
function ux takes nothing returns nothing
local trigger Nj
local playerunitevent Mj
local integer wx
set Vs=CreateTrigger()
set Nj=Vs
set Mj=EVENT_PLAYER_UNIT_DEATH
set wx=0
loop
call TriggerRegisterPlayerUnitEvent(Nj,Player(wx),Mj,null)
set wx=wx+1
exitwhen wx==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Vs,Condition(xp))
call TriggerAddAction(Vs,vp)
set Nj=null
set Mj=null
endfunction
function wE takes nothing returns nothing
local trigger BW
local playerunitevent NW
local integer MW
set kt=CreateTrigger()
set BW=kt
set NW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set MW=0
loop
call TriggerRegisterPlayerUnitEvent(BW,Player(MW),NW,null)
set MW=MW+1
exitwhen MW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(kt,Condition(Ue))
call TriggerAddAction(kt,Ie)
set BW=null
set NW=null
endfunction
function xK takes nothing returns nothing
local trigger FK
local playerunitevent kK
local integer jK
set Ji=CreateTrigger()
set FK=Ji
set kK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set jK=0
loop
call TriggerRegisterPlayerUnitEvent(FK,Player(jK),kK,null)
set jK=jK+1
exitwhen jK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ji,Condition(nn))
call TriggerAddAction(Ji,dn)
set FK=null
set kK=null
endfunction
function xQ takes nothing returns nothing
local trigger FQ
local playerunitevent kQ
local integer jQ
set at=CreateTrigger()
set FQ=at
set kQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set jQ=0
loop
call TriggerRegisterPlayerUnitEvent(FQ,Player(jQ),kQ,null)
set jQ=jQ+1
exitwhen jQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(at,Condition(ee))
call TriggerAddAction(at,qe)
set FQ=null
set kQ=null
endfunction
function yP takes nothing returns nothing
local trigger OP
local playerunitevent lP
local integer bP
set oi=CreateTrigger()
set OP=oi
set lP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set bP=0
loop
call TriggerRegisterPlayerUnitEvent(OP,Player(bP),lP,null)
set bP=bP+1
exitwhen bP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(oi,Condition(Nq))
call TriggerAddAction(oi,Mq)
set OP=null
set lP=null
endfunction
function yZ takes nothing returns nothing
local trigger OZ
local playerunitevent lZ
local integer bZ
set Ut=CreateTrigger()
set OZ=Ut
set lZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set bZ=0
loop
call TriggerRegisterPlayerUnitEvent(OZ,Player(bZ),lZ,null)
set bZ=bZ+1
exitwhen bZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ut,Condition(sq))
call TriggerAddAction(Ut,tq)
set OZ=null
set lZ=null
endfunction
function iX takes nothing returns nothing
call PT()
set Ts=CreateTrigger()
call TriggerAddAction(Ts,Hn)
call HT()
call rY()
call eY()
call FY()
call PY()
call VY()
call rG()
call qG()
call jG()
call XG()
call bg()
call jg()
call Xg()
call bh()
call jh()
call Xh()
call bF()
call fF()
call kF()
call CF()
call ek()
call Wk()
call uj()
call dj()
call Zj()
call ux()
call dx()
call Ix()
call iv()
set wt=CreateTrigger()
call TriggerAddAction(wt,Jn)
call Gv()
call Dv()
call Vv()
call sm()
call lm()
call nm()
call gm()
call mm()
call Pm()
call Xm()
call uQ()
call oQ()
call qQ()
call YQ()
call xQ()
call UQ()
call KQ()
call MQ()
call SW()
call pW()
call RW()
call kW()
call EW()
call HW()
call LW()
call wE()
call cE()
call eE()
call TE()
call jE()
call ZE()
call JE()
call NE()
call iZ()
call yZ()
call fZ()
call FZ()
call WZ()
call DZ()
call VZ()
call MZ()
call SU()
call pU()
call RU()
call kU()
call EU()
call HU()
call BU()
call tI()
call bI()
call dI()
call hI()
call QI()
call AI()
call CI()
call NI()
call iP()
call yP()
call fP()
call FP()
call WP()
call DP()
call VP()
call sA()
call lA()
call nA()
call gA()
call mA()
call PA()
call XA()
call uD()
call oD()
call qD()
call YD()
call hD()
call PD()
call KD()
call SH()
call RH()
call WH()
call VH()
call lJ()
call nJ()
call gJ()
call mJ()
call PJ()
call XJ()
call uK()
call oK()
call qK()
call YK()
call xK()
call UK()
call KK()
call MK()
call SL()
call pL()
call RL()
call kL()
call EL()
call HL()
call BL()
call tX()
endfunction
function mT takes nothing returns nothing
local player vT=Player(PLAYER_NEUTRAL_AGGRESSIVE)
call CreateUnit(vT,1747989297,-1600.0,-128.0,270.000)
call CreateUnit(vT,1747989297,-15040.0,10816.0,270.000)
call CreateUnit(vT,1747989297,-256.0,-2432.0,270.000)
call CreateUnit(vT,1747989297,-24320.0,3904.0,270.000)
call CreateUnit(vT,1747989297,-23552.0,-4544.0,270.000)
call CreateUnit(vT,1747989297,-23360.0,-64.0,270.000)
call CreateUnit(vT,1747989297,2176.0,-7744.0,270.000)
call CreateUnit(vT,1747989297,-6336.0,8000.0,270.000)
call CreateUnit(vT,1747989297,832.0,-5568.0,270.000)
call CreateUnit(vT,1747989297,-3648.0,1856.0,270.000)
call CreateUnit(vT,1747989042,-768.0,24384.0,270.000)
call CreateUnit(vT,1747989297,-26304.0,-8704.0,270.000)
call CreateUnit(vT,1747989297,2688.0,-3008.0,270.000)
call CreateUnit(vT,1747989297,-5568.0,-2752.0,270.000)
call CreateUnit(vT,1747989297,-3456.0,-2880.0,270.000)
call CreateUnit(vT,1747989297,-6464.0,1280.0,270.000)
call CreateUnit(vT,1747989297,-8064.0,3200.0,270.000)
call CreateUnit(vT,1747989297,-8768.0,1984.0,270.000)
call CreateUnit(vT,1747989297,-7104.0,-768.0,270.000)
call CreateUnit(vT,1747989297,-28544.0,0.0,270.000)
call CreateUnit(vT,1747989297,-27840.0,-2752.0,270.000)
call CreateUnit(vT,1747989297,-27008.0,2688.0,270.000)
call CreateUnit(vT,1747989297,-17024.0,512.0,270.000)
call CreateUnit(vT,1747989297,-21696.0,-4224.0,270.000)
call CreateUnit(vT,1747989042,17536.0,-9024.0,270.000)
call CreateUnit(vT,1747989297,10816.0,-7360.0,270.000)
call CreateUnit(vT,1747989297,12800.0,-6912.0,270.000)
call CreateUnit(vT,1747989297,15488.0,-7552.0,270.000)
call CreateUnit(vT,1747989297,19072.0,-7424.0,270.000)
call CreateUnit(vT,1747989297,15360.0,-5568.0,270.000)
call CreateUnit(vT,1747989297,17216.0,-8640.0,270.000)
call CreateUnit(vT,1747989297,16960.0,-16192.0,270.000)
call CreateUnit(vT,1747989297,6976.0,-6592.0,270.000)
call CreateUnit(vT,1747989297,24000.0,256.0,270.000)
call CreateUnit(vT,1747989297,-10688.0,-384.0,270.000)
call CreateUnit(vT,1747989297,13952.0,-11008.0,270.000)
call CreateUnit(vT,1747989297,-10944.0,-4608.0,270.000)
call CreateUnit(vT,1747989297,-21440.0,-8384.0,270.000)
call CreateUnit(vT,1747989297,17472.0,9472.0,270.000)
call CreateUnit(vT,1747989297,-16768.0,-8064.0,270.000)
call CreateUnit(vT,1747989297,-9920.0,-11264.0,270.000)
call CreateUnit(vT,1747989297,-7488.0,-16256.0,270.000)
call CreateUnit(vT,1747989297,448.0,-17600.0,270.000)
call CreateUnit(vT,1747989297,11008.0,-18496.0,270.000)
call CreateUnit(vT,1747989297,13248.0,-17856.0,270.000)
call CreateUnit(vT,1747989297,12288.0,-20864.0,270.000)
call CreateUnit(vT,1747989297,-11456.0,11008.0,270.000)
call CreateUnit(vT,1747989297,-8640.0,7104.0,270.000)
call CreateUnit(vT,1747989297,-7360.0,17088.0,270.000)
call CreateUnit(vT,1747989297,-5120.0,14528.0,270.000)
call CreateUnit(vT,1747989297,15488.0,-26816.0,270.000)
call CreateUnit(vT,1747989297,-9600.0,13120.0,270.000)
call CreateUnit(vT,1747989297,-11456.0,14528.0,270.000)
call CreateUnit(vT,1747989297,-12544.0,16320.0,270.000)
call CreateUnit(vT,1747989297,-7680.0,22272.0,270.000)
call CreateUnit(vT,1747989297,-6272.0,21376.0,270.000)
call CreateUnit(vT,1747989297,-4992.0,21888.0,270.000)
call CreateUnit(vT,1747989297,-1280.0,23936.0,270.000)
call CreateUnit(vT,1747989297,-3328.0,23232.0,270.000)
call CreateUnit(vT,1747989297,-2560.0,26368.0,270.000)
call CreateUnit(vT,1747989297,-6528.0,28288.0,270.000)
call CreateUnit(vT,1747989297,-9856.0,28416.0,270.000)
call CreateUnit(vT,1747989297,-13376.0,15104.0,270.000)
call CreateUnit(vT,1747989297,-10688.0,3520.0,270.000)
call CreateUnit(vT,1747989297,-9856.0,5440.0,270.000)
call CreateUnit(vT,1747989297,-6720.0,4096.0,270.000)
call CreateUnit(vT,1747989297,-13632.0,2368.0,270.000)
call CreateUnit(vT,1747989297,-10496.0,17728.0,270.000)
call CreateUnit(vT,1747989297,-7616.0,11200.0,270.000)
call CreateUnit(vT,1747989297,-18688.0,5760.0,270.000)
call CreateUnit(vT,1747989297,-25024.0,-3008.0,270.000)
call CreateUnit(vT,1747989297,-20096.0,1408.0,270.000)
call CreateUnit(vT,1747989297,-7040.0,-7808.0,270.000)
call CreateUnit(vT,1747989297,-5376.0,-9216.0,270.000)
call CreateUnit(vT,1747989297,24896.0,-27456.0,270.000)
call CreateUnit(vT,1747989297,-20352.0,12224.0,270.000)
call CreateUnit(vT,1747989297,-13568.0,5184.0,270.000)
call CreateUnit(vT,1747989297,-5120.0,24576.0,270.000)
call CreateUnit(vT,1747989297,-1856.0,27776.0,270.000)
call CreateUnit(vT,1747989297,-16704.0,24192.0,270.000)
call CreateUnit(vT,1747989297,-15936.0,17088.0,270.000)
call CreateUnit(vT,1747989297,-17792.0,16064.0,270.000)
call CreateUnit(vT,1747989297,-20224.0,21632.0,270.000)
call CreateUnit(vT,1747989297,-22400.0,19968.0,270.000)
call CreateUnit(vT,1747989297,-15872.0,20544.0,270.000)
call CreateUnit(vT,1747989297,-19776.0,16512.0,270.000)
call CreateUnit(vT,1747989297,-17088.0,12672.0,270.000)
call CreateUnit(vT,1747989297,-18560.0,19712.0,270.000)
call CreateUnit(vT,1747989297,-15680.0,26112.0,270.000)
call CreateUnit(vT,1747989297,-17088.0,26816.0,270.000)
call CreateUnit(vT,1747989297,-16704.0,3584.0,270.000)
call CreateUnit(vT,1747989297,-11456.0,7232.0,270.000)
call CreateUnit(vT,1747989297,-18176.0,10816.0,270.000)
call CreateUnit(vT,1747989297,-16000.0,6016.0,270.000)
call CreateUnit(vT,1747989297,-8896.0,26688.0,270.000)
call CreateUnit(vT,1747989297,9216.0,-4416.0,270.000)
call CreateUnit(vT,1747989297,6656.0,-4480.0,270.000)
call CreateUnit(vT,1747989297,5184.0,-1856.0,270.000)
call CreateUnit(vT,1747989297,18624.0,-448.0,270.000)
call CreateUnit(vT,1747989297,11008.0,-1984.0,270.000)
call CreateUnit(vT,1747989297,14144.0,-128.0,270.000)
call CreateUnit(vT,1747989297,8384.0,-10368.0,270.000)
call CreateUnit(vT,1747989297,5376.0,-12224.0,270.000)
call CreateUnit(vT,1747989297,3392.0,-7296.0,270.000)
call CreateUnit(vT,1747989297,12672.0,-3904.0,270.000)
call CreateUnit(vT,1747989297,27008.0,-11520.0,270.000)
call CreateUnit(vT,1747989297,-25216.0,1472.0,270.000)
call CreateUnit(vT,1747989297,23552.0,11072.0,270.000)
call CreateUnit(vT,1747989297,-20736.0,-2112.0,270.000)
call CreateUnit(vT,1747989297,-22592.0,2560.0,270.000)
call CreateUnit(vT,1747989297,-20864.0,3136.0,270.000)
call CreateUnit(vT,1747989297,-17280.0,-3136.0,270.000)
call CreateUnit(vT,1747989297,-3584.0,4608.0,270.000)
call CreateUnit(vT,1747989297,1536.0,29440.0,270.000)
call CreateUnit(vT,1747989297,-23104.0,-8832.0,270.000)
call CreateUnit(vT,1747989297,1216.0,-960.0,270.000)
call CreateUnit(vT,1747989297,-13312.0,-8512.0,270.000)
call CreateUnit(vT,1747989297,26240.0,-2688.0,270.000)
call CreateUnit(vT,1747989043,-7872.0,17536.0,270.000)
call CreateUnit(vT,1747989297,-13568.0,12160.0,270.000)
call CreateUnit(vT,1747989297,-13696.0,8064.0,270.000)
call CreateUnit(vT,1747989297,27648.0,-5824.0,270.000)
call CreateUnit(vT,1747989297,-4544.0,11648.0,270.000)
call CreateUnit(vT,1747989297,28992.0,-3200.0,270.000)
call CreateUnit(vT,1747989297,-3072.0,8320.0,270.000)
call CreateUnit(vT,1747989297,-384.0,8512.0,270.000)
call CreateUnit(vT,1747989297,28224.0,2752.0,270.000)
call CreateUnit(vT,1747989297,-4992.0,17280.0,270.000)
call CreateUnit(vT,1747989297,64.0,12608.0,270.000)
call CreateUnit(vT,1747989297,-2112.0,13696.0,270.000)
call CreateUnit(vT,1747989297,4160.0,5376.0,270.000)
call CreateUnit(vT,1747989297,4224.0,3904.0,270.000)
call CreateUnit(vT,1747989297,7232.0,2240.0,270.000)
call CreateUnit(vT,1747989297,-384.0,3072.0,270.000)
call CreateUnit(vT,1747989297,-8128.0,19968.0,270.000)
call CreateUnit(vT,1747989297,3072.0,192.0,270.000)
call CreateUnit(vT,1747989297,832.0,15872.0,270.000)
call CreateUnit(vT,1747989297,-2304.0,16064.0,270.000)
call CreateUnit(vT,1747989297,4416.0,19648.0,270.000)
call CreateUnit(vT,1747989297,1792.0,6976.0,270.000)
call CreateUnit(vT,1747989297,5888.0,24960.0,270.000)
call CreateUnit(vT,1747989297,-1792.0,19200.0,270.000)
call CreateUnit(vT,1747989297,3008.0,22784.0,270.000)
call CreateUnit(vT,1747989297,3200.0,18240.0,270.000)
call CreateUnit(vT,1747989297,-3712.0,-6528.0,270.000)
call CreateUnit(vT,1747989297,-17216.0,22208.0,270.000)
call CreateUnit(vT,1747989297,-18880.0,17920.0,270.000)
call CreateUnit(vT,1747989297,-17280.0,18304.0,270.000)
call CreateUnit(vT,1747989297,-22272.0,22400.0,270.000)
call CreateUnit(vT,1747989297,-10496.0,-9152.0,270.000)
call CreateUnit(vT,1747989297,13248.0,5120.0,270.000)
call CreateUnit(vT,1747989297,7936.0,-2368.0,270.000)
call CreateUnit(vT,1747989297,3520.0,27008.0,270.000)
call CreateUnit(vT,1747989297,8832.0,26368.0,270.000)
call CreateUnit(vT,1747989297,6848.0,21440.0,270.000)
call CreateUnit(vT,1747989297,6144.0,18560.0,270.000)
call CreateUnit(vT,1747989297,3904.0,11072.0,270.000)
call CreateUnit(vT,1747989297,8512.0,12352.0,270.000)
call CreateUnit(vT,1747989297,9280.0,20032.0,270.000)
call CreateUnit(vT,1747989297,1216.0,11008.0,270.000)
call CreateUnit(vT,1747989044,-15680.0,11200.0,270.000)
call CreateUnit(vT,1747989044,-15104.0,17408.0,270.000)
call CreateUnit(vT,1747989045,-1728.0,28608.0,270.000)
call CreateUnit(vT,1747989043,-18304.0,18112.0,270.000)
call CreateUnit(vT,1747989044,-9600.0,13888.0,270.000)
call CreateUnit(vT,1747989297,384.0,19456.0,270.000)
call CreateUnit(vT,1747989044,4864.0,5952.0,270.000)
call CreateUnit(vT,1747989044,8000.0,-1664.0,270.000)
call CreateUnit(vT,1747989044,9280.0,-3008.0,270.000)
call CreateUnit(vT,1747989045,-21056.0,21056.0,270.000)
call CreateUnit(vT,1747989045,-19648.0,12224.0,270.000)
call CreateUnit(vT,1747989045,17984.0,-13120.0,270.000)
call CreateUnit(vT,1747989042,-28544.0,704.0,270.000)
call CreateUnit(vT,1747989045,-9344.0,7168.0,270.000)
call CreateUnit(vT,1747989043,-6336.0,8576.0,270.000)
call CreateUnit(vT,1747989045,-15616.0,21248.0,270.000)
call CreateUnit(vT,1747989045,-16640.0,1024.0,270.000)
call CreateUnit(vT,1747989045,13760.0,-11584.0,270.000)
call CreateUnit(vT,1747989042,-11328.0,3712.0,270.000)
call CreateUnit(vT,1747989042,-16768.0,25920.0,270.000)
call CreateUnit(vT,1747989045,-19200.0,28352.0,270.000)
call CreateUnit(vT,1747989043,3456.0,11584.0,270.000)
call CreateUnit(vT,1747989044,-24640.0,4352.0,270.000)
call CreateUnit(vT,1747989044,-23232.0,-5120.0,270.000)
call CreateUnit(vT,1747989042,-23424.0,768.0,270.000)
call CreateUnit(vT,1747989045,-15936.0,-2688.0,270.000)
call CreateUnit(vT,1747989045,-10752.0,-3456.0,270.000)
call CreateUnit(vT,1747989044,-7552.0,4416.0,270.000)
call CreateUnit(vT,1747989045,-20160.0,-1600.0,270.000)
call CreateUnit(vT,1747989045,-21824.0,2560.0,270.000)
call CreateUnit(vT,1747989045,11392.0,-7104.0,270.000)
call CreateUnit(vT,1747989042,4352.0,20224.0,270.000)
call CreateUnit(vT,1747989044,-15360.0,4992.0,270.000)
call CreateUnit(vT,1747989042,-896.0,3392.0,270.000)
call CreateUnit(vT,1747989045,-6528.0,-832.0,270.000)
call CreateUnit(vT,1747989043,-4928.0,-3264.0,270.000)
call CreateUnit(vT,1747989042,-6144.0,-8192.0,270.000)
call CreateUnit(vT,1747989043,23424.0,640.0,270.000)
call CreateUnit(vT,1747989043,-6976.0,1344.0,270.000)
call CreateUnit(vT,1747989043,4352.0,128.0,270.000)
call CreateUnit(vT,1747989297,17472.0,19648.0,270.000)
call CreateUnit(vT,1747989044,-7872.0,22784.0,270.000)
call CreateUnit(vT,1747989297,20864.0,21504.0,270.000)
call CreateUnit(vT,1747989044,-9152.0,28480.0,270.000)
call CreateUnit(vT,1747989042,-27712.0,-9536.0,270.000)
call CreateUnit(vT,1747989042,4800.0,-12480.0,270.000)
call CreateUnit(vT,1747989045,7232.0,-11328.0,270.000)
call CreateUnit(vT,1747989045,1792.0,-8064.0,270.000)
call CreateUnit(vT,1747989297,-1600.0,5952.0,270.000)
call CreateUnit(vT,1747989043,-128.0,-1792.0,270.000)
call CreateUnit(vT,1747989042,-3392.0,8640.0,270.000)
call CreateUnit(vT,1747989044,-1856.0,16576.0,270.000)
call CreateUnit(vT,1747989043,-13888.0,14784.0,270.000)
call CreateUnit(vT,1747989297,-29568.0,-9792.0,270.000)
call CreateUnit(vT,1747989043,-9088.0,26240.0,270.000)
call CreateUnit(vT,1747989045,-5440.0,23808.0,270.000)
call CreateUnit(vT,1747989045,2176.0,30080.0,270.000)
call CreateUnit(vT,1747989043,1984.0,6464.0,270.000)
call CreateUnit(vT,1747989297,-26304.0,-1408.0,270.000)
call CreateUnit(vT,1747989043,448.0,13056.0,270.000)
call CreateUnit(vT,1747989045,3072.0,26752.0,270.000)
call CreateUnit(vT,1747989043,6656.0,18880.0,270.000)
call CreateUnit(vT,1747989043,3264.0,-3712.0,270.000)
call CreateUnit(vT,1747989297,15872.0,5760.0,270.000)
call CreateUnit(vT,1747989043,6528.0,22080.0,270.000)
call CreateUnit(vT,1747989044,8896.0,27008.0,270.000)
call CreateUnit(vT,1747989297,18496.0,-17280.0,270.000)
call CreateUnit(vT,1747989297,11392.0,7872.0,270.000)
call CreateUnit(vT,1747989297,12672.0,11328.0,270.000)
call CreateUnit(vT,1747989297,6016.0,12416.0,270.000)
call CreateUnit(vT,1747989297,7104.0,7808.0,270.000)
call CreateUnit(vT,1747989297,20864.0,2688.0,270.000)
call CreateUnit(vT,1747989297,24000.0,2560.0,270.000)
call CreateUnit(vT,1747989297,19648.0,11328.0,270.000)
call CreateUnit(vT,1747989297,11584.0,16960.0,270.000)
call CreateUnit(vT,1747989297,18496.0,-13248.0,270.000)
call CreateUnit(vT,1747989297,17216.0,-11456.0,270.000)
call CreateUnit(vT,1747989297,25088.0,-8320.0,270.000)
call CreateUnit(vT,1747989297,15680.0,-17536.0,270.000)
call CreateUnit(vT,1747989297,16640.0,-14208.0,270.000)
call CreateUnit(vT,1747989297,17280.0,-19584.0,270.000)
call CreateUnit(vT,1747989297,22912.0,-10240.0,270.000)
call CreateUnit(vT,1747989297,20864.0,-23040.0,270.000)
call CreateUnit(vT,1747989044,13120.0,-21696.0,270.000)
call CreateUnit(vT,1747989297,20096.0,-5760.0,270.000)
call CreateUnit(vT,1747989297,18816.0,-3776.0,270.000)
call CreateUnit(vT,1747989042,14464.0,-26432.0,270.000)
call CreateUnit(vT,1747989044,23808.0,-27776.0,270.000)
call CreateUnit(vT,1747989042,11776.0,-18688.0,270.000)
call CreateUnit(vT,1747989043,256.0,-18048.0,270.000)
call CreateUnit(vT,1747989045,-16192.0,-8192.0,270.000)
call CreateUnit(vT,1747989045,-11520.0,-10944.0,270.000)
call CreateUnit(vT,1747989045,16512.0,-19968.0,270.000)
call CreateUnit(vT,1747989045,20416.0,-22272.0,270.000)
call CreateUnit(vT,1747989044,28800.0,-11904.0,270.000)
call CreateUnit(vT,1747989297,15040.0,23104.0,270.000)
call CreateUnit(vT,1747989044,8128.0,12928.0,270.000)
call CreateUnit(vT,1747989044,16896.0,-15744.0,270.000)
call CreateUnit(vT,1747989042,17984.0,-640.0,270.000)
call CreateUnit(vT,1747989045,20608.0,3136.0,270.000)
call CreateUnit(vT,1747989045,7232.0,-5120.0,270.000)
call CreateUnit(vT,1747989045,25984.0,-8128.0,270.000)
call CreateUnit(vT,1747989045,20544.0,-5440.0,270.000)
call CreateUnit(vT,1747989045,11968.0,17856.0,270.000)
call CreateUnit(vT,1747989045,10048.0,20032.0,270.000)
call CreateUnit(vT,1747989043,15296.0,-7232.0,270.000)
call CreateUnit(vT,1747989043,13056.0,11776.0,270.000)
call CreateUnit(vT,1747989043,15744.0,23488.0,270.000)
call CreateUnit(vT,1747989043,17984.0,9280.0,270.000)
set vT=null
endfunction
function AD takes nothing returns nothing
call UnitRemoveAbility(GetTriggerUnit(),1093677402)
endfunction
function N9 takes integer B9 returns string
if B9==0 then
return "|cffADADADtrace|r"
elseif B9==1 then
return "|cff2685DCdebug|r"
elseif B9==2 then
return "|cffFFCC00info|r"
elseif B9==3 then
return "|cffF47E3Ewarning|r"
elseif B9==4 then
return "|cffFB2700error|r"
endif
return "?"
endfunction
function q1 takes string t1,string i1 returns nothing
local integer S1
local string c1
local integer o1
local integer O1
local string l1
local integer b1
local integer y1
local string p1
local string e1
set Cb[Xb]=i1
set Xb=Xb+1
set S1=StringHash(t1)
if HaveSavedInteger(tc,-1,S1) then
if LoadInteger(tc,-1,S1)+60<ec then
set p1=t1
set c1=""
set o1=Xb
set O1=0
loop
set o1=o1-1
set O1=O1+1
exitwhen O1>20 or o1<0
set c1=c1+"\n   "+Cb[o1]
endloop
set i1=p1+c1
call DisplayTimedTextToPlayer(uo,0.,0.,45.,N9(4)+" - "+i1)
call SaveInteger(tc,-1,S1,R2I(ec))
call SaveBoolean(tc,-1,S1,false)
elseif HaveSavedBoolean(tc,-1,S1) then
if not LoadBoolean(tc,-1,S1) then
call DisplayTimedTextToPlayer(uo,0.,0.,45.,N9(4)+" - "+"|cffFF3A29Excessive repeating errors are being omitted")
call SaveBoolean(tc,-1,S1,true)
endif
else
call DisplayTimedTextToPlayer(uo,0.,0.,45.,N9(4)+" - "+"|cffFF3A29Excessive repeating errors are being omitted")
call SaveBoolean(tc,-1,S1,true)
endif
else
call SaveInteger(tc,-1,S1,R2I(ec))
set e1="Message: "+t1
set l1=""
set b1=Xb
set y1=0
loop
set b1=b1-1
set y1=y1+1
exitwhen y1>20 or b1<0
set l1=l1+"\n   "+Cb[b1]
endloop
call DisplayTimedTextToPlayer(uo,0.,0.,45.,N9(4)+" - "+e1+l1)
endif
call I2S(1/0)
set Xb=Xb-1
endfunction
function CC takes unit DC,string HC returns integer
local integer JC
local integer KC
local integer LC
local unit XC
set Cb[Xb]=HC
set Xb=Xb+1
set JC=0
set KC=nS-1
loop
exitwhen JC>KC
set LC=hS[JC]
set HC="when calling getCityUnit in City, line 443"
set Cb[Xb]="when calling getCityUnit in City, line 443"
set Xb=Xb+1
if pO[LC]==0 then
if LC==0 then
call q1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call q1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set XC=xl[LC]
set Xb=Xb-1
if XC==DC then
set Xb=Xb-1
set XC=null
return JC
endif
set JC=JC+1
endloop
set Xb=Xb-1
set XC=null
return -1
endfunction
function Dew takes integer Iew,integer Pew returns nothing
local integer Aew
if Ib[Iew]!=-1 then
call ForceRemovePlayer(Oc[Ib[Iew]],Pb[Iew])
endif
set Ib[Iew]=Pew
call ForceAddPlayer(Oc[Ib[Iew]],Pb[Iew])
call SetPlayerTechMaxAllowed(Pb[Iew],1747990087,0)
call SetPlayerTechMaxAllowed(Pb[Iew],1747990088,0)
call SetPlayerTechMaxAllowed(Pb[Iew],1747989558,0)
call SetPlayerTechMaxAllowed(Pb[Iew],1747989575,0)
call SetPlayerTechMaxAllowed(Pb[Iew],1747990339,0)
call SetPlayerTechMaxAllowed(Pb[Iew],1747990340,0)
call SetPlayerTechMaxAllowed(Pb[Iew],1747988528,0)
call SetPlayerTechMaxAllowed(Pb[Iew],1747988532,0)
set Aew=Ib[Iew]
if Aew==0 then
call SetPlayerTechMaxAllowed(Pb[Iew],1747988528,-1)
call SetPlayerTechMaxAllowed(Pb[Iew],1747988532,-1)
elseif Aew==1 then
call SetPlayerTechMaxAllowed(Pb[Iew],1747990339,-1)
call SetPlayerTechMaxAllowed(Pb[Iew],1747990340,-1)
elseif Aew==2 then
call SetPlayerTechMaxAllowed(Pb[Iew],1747990087,-1)
call SetPlayerTechMaxAllowed(Pb[Iew],1747990088,-1)
elseif Aew==3 then
call SetPlayerTechMaxAllowed(Pb[Iew],1747989558,-1)
call SetPlayerTechMaxAllowed(Pb[Iew],1747989575,-1)
endif
endfunction
function Rdw takes integer ddw,string fdw returns nothing
set Cb[Xb]=fdw
set Xb=Xb+1
if rl[ddw]==0 then
if ddw==0 then
call q1("Nullpointer exception when calling LLIterator.LLIterator","when calling error in LinkedList, line 406")
else
call q1("Called LLIterator.LLIterator on invalid object.","when calling error in LinkedList, line 406")
endif
endif
set Cb[Xb]="when calling destroyLLIterator in LinkedList, line 406"
set Xb=Xb+1
set Cb[Xb]="when calling dealloc_LLIterator in LinkedList, line 406"
set Xb=Xb+1
if rl[ddw]==0 then
call q1("Double free: object of type LLIterator","when calling error in LinkedList, line 406")
else
set MO[wl]=ddw
set wl=wl+1
set rl[ddw]=0
endif
set Xb=Xb-1-1-1
endfunction
function Knw takes integer Anw,integer Dnw,string Hnw returns boolean
local integer Jnw
set Cb[Xb]=Hnw
set Xb=Xb+1
if ZO[Anw]==0 then
if Anw==0 then
call q1("Nullpointer exception when calling HashList.has","when calling error in HashList, line 87")
else
call q1("Called HashList.has on invalid object.","when calling error in HashList, line 87")
endif
endif
set Cb[Xb]="when calling has in HashList, line 87"
set Xb=Xb+1
set Cb[Xb]="when calling count in HashList, line 88"
set Xb=Xb+1
if ZO[Anw]==0 then
if Anw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Jnw=LoadInteger(nc,Anw,Dnw)
set Xb=Xb-1
set Xb=Xb-1-1
return Jnw>0
endfunction
function Otw takes integer Stw,integer ctw,string otw returns nothing
set Cb[Xb]=otw
set Xb=Xb+1
if not Knw(Bo,ctw,"when calling has in City, line 195") then
set Xb=Xb-1
return
endif
set xl[Stw]=ReplaceUnitBJ(xl[Stw],ctw,bj_UNIT_STATE_METHOD_RELATIVE)
set Xb=Xb-1
endfunction
function cdw takes integer sdw,integer tdw,string idw returns integer
local integer Sdw
set Cb[Xb]=idw
set Xb=Xb+1
if AO[sdw]==0 then
if sdw==0 then
call q1("Nullpointer exception when calling HashMap.get","when calling error in HashMap, line 23")
else
call q1("Called HashMap.get on invalid object.","when calling error in HashMap, line 23")
endif
endif
set Cb[Xb]="when calling get in HashMap, line 23"
set Xb=Xb+1
set Cb[Xb]="when calling loadInt in HashMap, line 24"
set Xb=Xb+1
if AO[sdw]==0 then
if sdw==0 then
call q1("Nullpointer exception when calling Table.loadInt","when calling error in Table, line 39")
else
call q1("Called Table.loadInt on invalid object.","when calling error in Table, line 39")
endif
endif
set Sdw=LoadInteger(Wo,sdw,tdw)
set Xb=Xb-1-1-1
return Sdw
endfunction
function rnw takes integer wnw,string unw returns nothing
set Cb[Xb]=unw
set Xb=Xb+1
if nO[wnw]==0 then
if wnw==0 then
call q1("Nullpointer exception when calling ForGroupCallback.ForGroupCallback","when calling error in ClosureForGroups, line 3")
else
call q1("Called ForGroupCallback.ForGroupCallback on invalid object.","when calling error in ClosureForGroups, line 3")
endif
endif
set Cb[Xb]="when calling destroyForGroupCallback in ClosureForGroups, line 3"
set Xb=Xb+1
set Cb[Xb]="when calling dealloc_ForGroupCallback in ClosureForGroups, line 3"
set Xb=Xb+1
if nO[wnw]==0 then
call q1("Double free: object of type ForGroupCallback","when calling error in ClosureForGroups, line 3")
else
set eO[qO]=wnw
set qO=qO+1
set nO[wnw]=0
endif
set Xb=Xb-1-1-1
endfunction
function SB takes real uB,real rB,real sB,integer tB,string iB returns nothing
set Cb[Xb]=iB
set Xb=Xb+1
set PS[AS]=tB
set AS=AS+1
set HS=0
set DS=2147483647
call GroupEnumUnitsInRange(IS,uB,rB,sB,JS)
set Cb[Xb]="when calling popCallback in ClosureForGroups, line 98"
set Xb=Xb+1
call GroupClear(IS)
set AS=AS-1
call rnw(PS[AS],"when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 30")
set Xb=Xb-1-1
endfunction
function I2 takes string U2 returns nothing
if (not Gc)and(not gc) then
return
endif
call DisplayTimedTextToPlayer(wo[0],0.,0.,60.,U2)
endfunction
function tbw takes integer Mlw,integer wbw,integer ubw,string rbw returns integer
local integer sbw
set Cb[Xb]=rbw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_LLEntry in LinkedList, line 401"
set Xb=Xb+1
if VO==0 then
if BO<32768 then
set BO=BO+1
set sbw=BO
set NO[sbw]=702
else
call q1("Out of memory: Could not create LLEntry.","when calling error in LinkedList, line 396")
set sbw=0
endif
else
set VO=VO-1
set sbw=CO[VO]
set NO[sbw]=702
endif
set Xb=Xb-1
set Rb[sbw]=Mlw
set Tb[sbw]=wbw
set Yb[sbw]=ubw
set Xb=Xb-1
return sbw
endfunction
function Ndw takes integer Xdw,integer Cdw,string Vdw returns nothing
local integer Bdw
set Cb[Xb]=Vdw
set Xb=Xb+1
if Sl[Xdw]==0 then
if Xdw==0 then
call q1("Nullpointer exception when calling LinkedList.add","when calling error in LinkedList, line 37")
else
call q1("Called LinkedList.add on invalid object.","when calling error in LinkedList, line 37")
endif
endif
set Cb[Xb]="when calling add in LinkedList, line 37"
set Xb=Xb+1
set Bdw=tbw(Cdw,Tb[kb[Xdw]],kb[Xdw],"when calling new_LLEntry in LinkedList, line 39")
set Yb[Tb[kb[Xdw]]]=Bdw
set Tb[kb[Xdw]]=Bdw
set jb[Xdw]=jb[Xdw]+1
set Xb=Xb-1-1
endfunction
function Uaw takes integer Waw,integer Eaw,string Zaw returns nothing
set Cb[Xb]=Zaw
set Xb=Xb+1
if pO[Waw]==0 then
if Waw==0 then
call q1("Nullpointer exception when calling City.getCityModifierOnAdd","when calling error in City, line 420")
else
call q1("Called City.getCityModifierOnAdd on invalid object.","when calling error in City, line 420")
endif
endif
set Cb[Xb]="when calling getCityModifierOnAdd in City, line 420"
set Xb=Xb+1
set Dl[Waw]=Dl[Waw]+Tl[cdw(aS,Eaw,"when calling get in City, line 421")]
set Hl[Waw]=Hl[Waw]+Fl[cdw(aS,Eaw,"when calling get in City, line 422")]
set Xb=Xb-1-1
endfunction
function nbw takes integer ebw,integer qbw returns boolean
local integer abw=Yb[kb[ebw]]
loop
exitwhen abw==kb[ebw]
if Rb[abw]==qbw then
return true
endif
set abw=Yb[abw]
endloop
return false
endfunction
function Iww takes timer Qww,integer Www,string Eww returns nothing
local integer Zww
local integer Uww
set Cb[Xb]=Eww
set Xb=Xb+1
set Zww=Uo
set Uww=GetHandleId(Qww)
set Cb[Xb]="when calling saveInt in TimerUtils, line 17"
set Xb=Xb+1
if AO[Zww]==0 then
if Zww==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,Zww,Uww,Www)
set Xb=Xb-1-1
endfunction
function Cww takes string Lww returns timer
local timer Xww
set Cb[Xb]=Lww
set Xb=Xb+1
if Zo>0 then
set Zo=Zo-1
call Iww(Eo[Zo],0,"when calling setData in TimerUtils, line 29")
set Xb=Xb-1
set Xww=null
return Eo[Zo]
else
set Xww=CreateTimer()
call Iww(Xww,0,"when calling setData in TimerUtils, line 32")
set Xb=Xb-1
set oR=Xww
set Xww=null
return oR
endif
endfunction
function Zcw takes integer mcw,timer Qcw,real Wcw,string Ecw returns nothing
set Cb[Xb]=Ecw
set Xb=Xb+1
call Iww(Qcw,mcw,"when calling setData in ClosureTimers, line 113")
call TimerStart(Qcw,Wcw,false,wR)
set ob[mcw]=Qcw
set Xb=Xb-1
endfunction
function yB takes real oB,integer OB,string lB returns integer
local timer bB
set Cb[Xb]=lB
set Xb=Xb+1
set bB=Cww("when calling getTimer in ClosureTimers, line 27")
set Cb[Xb]="when calling doAfter in ClosureTimers, line 27"
set Xb=Xb+1
set Cb[Xb]="when calling start in ClosureTimers, line 16"
set Xb=Xb+1
if TO[OB]==0 then
if OB==0 then
call q1("Nullpointer exception when calling CallbackSingle.start","when calling error in ClosureTimers, line 111")
else
call q1("Called CallbackSingle.start on invalid object.","when calling error in ClosureTimers, line 111")
endif
endif
call Zcw(OB,bB,oB,"when calling start in ClosureTimers, line 111")
set Xb=Xb-1-1-1
set bB=null
return OB
endfunction
function Bsw takes integer Hsw,integer Jsw,string Ksw returns boolean
local real Lsw
local integer Xsw
local boolean Csw
local integer Vsw
set Cb[Xb]=Ksw
set Xb=Xb+1
set Xsw=Ll[Hsw]
set Cb[Xb]="when calling has in City, line 369"
set Xb=Xb+1
if Sl[Xsw]==0 then
if Xsw==0 then
call q1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call q1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Csw=nbw(Xsw,Jsw)
set Xb=Xb-1
if Csw then
set Xb=Xb-1
return false
endif
call Ndw(Ll[Hsw],Jsw,"when calling add in City, line 371")
call Uaw(Hsw,Jsw,"when calling getCityModifierOnAdd in City, line 372")
call I2("Added a modifier "+kl[cdw(aS,Jsw,"when calling get in City, line 373")]+" | "+R2SW(Rl[cdw(aS,Jsw,"when calling get in City, line 373")],3,3))
set Lsw=Rl[cdw(aS,Jsw,"when calling get in City, line 374")]
set Cb[Xb]="when calling alloc_City_City_CallbackSingle_line374 in City, line 374"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set Vsw=RO
set TO[Vsw]=639
else
call q1("Out of memory: Could not create City_City_CallbackSingle_line374.","when calling error in City, line 374")
set Vsw=0
endif
else
set fO=fO-1
set Vsw=dO[fO]
set TO[Vsw]=639
endif
set Xb=Xb-1
set Vl[Vsw]=Hsw
set Bl[Vsw]=Jsw
call yB(Lsw,Vsw,"when calling doAfter in City, line 374")
set Xb=Xb-1
return true
endfunction
function kaw takes integer faw,string Raw returns string
local integer Taw
local integer Yaw
local integer Gaw
local integer gaw
local integer haw
local integer Faw
set Cb[Xb]=Raw
set Xb=Xb+1
if pO[faw]==0 then
if faw==0 then
call q1("Nullpointer exception when calling City.getCityNameColored","when calling error in City, line 179")
else
call q1("Called City.getCityNameColored on invalid object.","when calling error in City, line 179")
endif
endif
set gaw=lc[Ql[faw]]
set haw=bc[Ql[faw]]
set Faw=yc[Ql[faw]]
set Taw=gaw/16
set Yaw=haw/16
set Gaw=Faw/16
set Raw="|cff"+VS[Taw]+VS[gaw-Taw*16]+VS[Yaw]+VS[haw-Yaw*16]+VS[Gaw]+VS[Faw-Gaw*16]+vl[faw]+"|r"
set Xb=Xb-1
return Raw
endfunction
function l5 takes player i5,string S5 returns string
local integer c5
local integer o5
local integer O5
set Cb[Xb]=S5
set Xb=Xb+1
set o5=Mc[GetPlayerId(i5)]
set Cb[Xb]="when calling getForceId in Messages, line 53"
set Xb=Xb+1
if yl[o5]==0 then
if o5==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set O5=Ib[o5]
set Xb=Xb-1
set c5=GetRandomInt(0,2)
if O5==0 then
set S5=jo[c5]
elseif O5==1 then
set S5=xo[c5]
elseif O5==2 then
set S5=vo[c5]
elseif O5==3 then
set S5=mo[c5]
else
set S5="Attention!"
endif
set Xb=Xb-1
return "|cffffa600"+S5+"|r"
endfunction
function hdw takes integer Tdw,string Ydw returns nothing
local integer Gdw
local integer gdw
set Cb[Xb]=Ydw
set Xb=Xb+1
if rl[Tdw]==0 then
if Tdw==0 then
call q1("Nullpointer exception when calling LLIterator.reset","when calling error in LinkedList, line 421")
else
call q1("Called LLIterator.reset on invalid object.","when calling error in LinkedList, line 421")
endif
endif
set Cb[Xb]="when calling reset in LinkedList, line 421"
set Xb=Xb+1
set Gdw=hb[Tdw]
set Cb[Xb]="when calling getDummy in LinkedList, line 422"
set Xb=Xb+1
if Sl[Gdw]==0 then
if Gdw==0 then
call q1("Nullpointer exception when calling LinkedList.getDummy","when calling error in LinkedList, line 362")
else
call q1("Called LinkedList.getDummy on invalid object.","when calling error in LinkedList, line 362")
endif
endif
set gdw=kb[Gdw]
set Xb=Xb-1
set Gb[Tdw]=gdw
set gb[Tdw]=Gb[Tdw]
set Xb=Xb-1-1
endfunction
function obw takes integer ibw,string Sbw returns integer
local integer cbw
set Cb[Xb]=Sbw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_LLIterator in LinkedList, line 412"
set Xb=Xb+1
if wl==0 then
if ul<32768 then
set ul=ul+1
set cbw=ul
set rl[cbw]=703
else
call q1("Out of memory: Could not create LLIterator.","when calling error in LinkedList, line 406")
set cbw=0
endif
else
set wl=wl-1
set cbw=MO[wl]
set rl[cbw]=703
endif
set Xb=Xb-1
set Cb[Xb]="when calling construct_LLIterator in LinkedList, line 412"
set Xb=Xb+1
set Fb[cbw]=true
set hb[cbw]=ibw
call hdw(cbw,"when calling reset in LinkedList, line 414")
set Xb=Xb-1-1
return cbw
endfunction
function tww takes integer x0w,string v0w returns nothing
local integer m0w
local unit Q0w
local integer W0w
local integer E0w
local integer Z0w
local integer U0w
local integer I0w
local integer P0w
local integer A0w
local real D0w
local integer H0w
local integer J0w
local integer K0w
local unit L0w
local player X0w
local integer C0w
local player V0w
local integer B0w
local integer N0w
local integer M0w
local integer www
local integer uww
local integer rww
local boolean sww
set Cb[Xb]=v0w
set Xb=Xb+1
if x0w<0 or x0w>=nS then
set Xb=Xb-1
set Q0w=null
set L0w=null
set X0w=null
set V0w=null
return
endif
if Fc-eo[x0w]<=60 then
set Xb=Xb-1
set Q0w=null
set L0w=null
set X0w=null
set V0w=null
return
endif
set A0w=hS[x0w]
set Cb[Xb]="when calling getLastPublicOrder in Revolts, line 21"
set Xb=Xb+1
if pO[A0w]==0 then
if A0w==0 then
call q1("Nullpointer exception when calling City.getLastPublicOrder","when calling error in City, line 335")
else
call q1("Called City.getLastPublicOrder on invalid object.","when calling error in City, line 335")
endif
endif
set D0w=Al[A0w]
set Xb=Xb-1
set H0w=hS[x0w]
set Cb[Xb]="when calling getPopulation in Revolts, line 22"
set Xb=Xb+1
if pO[H0w]==0 then
if H0w==0 then
call q1("Nullpointer exception when calling City.getPopulation","when calling error in City, line 344")
else
call q1("Called City.getPopulation on invalid object.","when calling error in City, line 344")
endif
endif
set J0w=Ul[H0w]
set Xb=Xb-1
set m0w=J0w
set K0w=hS[x0w]
set Cb[Xb]="when calling getCityUnit in Revolts, line 23"
set Xb=Xb+1
if pO[K0w]==0 then
if K0w==0 then
call q1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call q1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set L0w=xl[K0w]
set Xb=Xb-1
set Q0w=L0w
set X0w=GetOwningPlayer(L0w)
if GetPlayerSlotState(X0w)==PLAYER_SLOT_STATE_PLAYING then
set sww=GetPlayerController(X0w)==MAP_CONTROL_USER
else
set sww=false
endif
if not sww then
set Xb=Xb-1
set Q0w=null
set L0w=null
set X0w=null
set V0w=null
return
endif
if D0w<50.0 then
set eo[x0w]=Fc
set C0w=hS[x0w]
set Cb[Xb]="when calling addModifier in Revolts, line 28"
set Xb=Xb+1
if pO[C0w]==0 then
if C0w==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(C0w,1,"when calling addModifier in City, line 368")
set Xb=Xb-1
set v0w="A violent mob has appeared near the gates of "+kaw(hS[x0w],"when calling getCityNameColored in Revolts, line 29")+"!"
set V0w=GetOwningPlayer(L0w)
set Cb[Xb]="when calling attentionToPlayer in Revolts, line 29"
set Xb=Xb+1
call DisplayTimedTextToPlayer(V0w,0.,0.,10.0,l5(V0w,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(V0w,0.,0.,10.0,v0w)
set Xb=Xb-1
if D0w>=30.0 then
set B0w=No[0]
set Cb[Xb]="when calling iterator in Revolts, line 32"
set Xb=Xb+1
set N0w=obw(B0w,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set W0w=N0w
loop
exitwhen Yb[gb[W0w]]==Gb[W0w]
set gb[W0w]=Yb[gb[W0w]]
set E0w=Rb[gb[W0w]]
call CreateUnit(wo[PLAYER_NEUTRAL_AGGRESSIVE],E0w,GetUnitX(Q0w),GetUnitY(Q0w),0.)
if GetRandomReal(0.0,1.0)<=m0w*1./150000 then
call CreateUnit(wo[PLAYER_NEUTRAL_AGGRESSIVE],E0w,GetUnitX(Q0w),GetUnitY(Q0w),0.)
endif
endloop
set Cb[Xb]="when calling close in Revolts, line 32"
set Xb=Xb+1
if Fb[W0w]then
call Rdw(W0w,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1
elseif D0w>=15.0 then
set M0w=No[1]
set Cb[Xb]="when calling iterator in Revolts, line 38"
set Xb=Xb+1
set www=obw(M0w,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set Z0w=www
loop
exitwhen Yb[gb[Z0w]]==Gb[Z0w]
set gb[Z0w]=Yb[gb[Z0w]]
set U0w=Rb[gb[Z0w]]
call CreateUnit(wo[PLAYER_NEUTRAL_AGGRESSIVE],U0w,GetUnitX(Q0w),GetUnitY(Q0w),0.)
if GetRandomReal(0.0,1.0)<=m0w*1./150000 then
call CreateUnit(wo[PLAYER_NEUTRAL_AGGRESSIVE],U0w,GetUnitX(Q0w),GetUnitY(Q0w),0.)
endif
endloop
set Cb[Xb]="when calling close in Revolts, line 38"
set Xb=Xb+1
if Fb[Z0w]then
call Rdw(Z0w,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1
else
set uww=No[2]
set Cb[Xb]="when calling iterator in Revolts, line 44"
set Xb=Xb+1
set rww=obw(uww,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set I0w=rww
loop
exitwhen Yb[gb[I0w]]==Gb[I0w]
set gb[I0w]=Yb[gb[I0w]]
set P0w=Rb[gb[I0w]]
call CreateUnit(wo[PLAYER_NEUTRAL_AGGRESSIVE],P0w,GetUnitX(Q0w),GetUnitY(Q0w),0.)
if GetRandomReal(0.0,1.0)<=m0w*1./150000 then
call CreateUnit(wo[PLAYER_NEUTRAL_AGGRESSIVE],P0w,GetUnitX(Q0w),GetUnitY(Q0w),0.)
endif
endloop
set Cb[Xb]="when calling close in Revolts, line 44"
set Xb=Xb+1
if Fb[I0w]then
call Rdw(I0w,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1
endif
endif
set Xb=Xb-1
set Q0w=null
set L0w=null
set X0w=null
set V0w=null
endfunction
function iiw takes integer Vtw,string Btw returns real
local integer Ntw
local integer Mtw
local boolean wiw
local real uiw
local real riw
local real siw
local real tiw
set Cb[Xb]=Btw
set Xb=Xb+1
set Al[Vtw]=100.0-Pl[Vtw]*1000.-SquareRoot(Ul[Vtw]*1.)/17.+Dl[Vtw]-Ul[Vtw]*1./1000*GS[Jl[Vtw]]
set uiw=El[Vtw]
set riw=Zl[Vtw]
set Cb[Xb]="when calling alloc_City_City_ForGroupCallback_line313 in City, line 313"
set Xb=Xb+1
if qO==0 then
if aO<32768 then
set aO=aO+1
set Ntw=aO
set nO[Ntw]=688
else
call q1("Out of memory: Could not create City_City_ForGroupCallback_line313.","when calling error in City, line 313")
set Ntw=0
endif
else
set qO=qO-1
set Ntw=eO[qO]
set nO[Ntw]=688
endif
set Xb=Xb-1
set Xl[Ntw]=Vtw
call SB(uiw,riw,500,Ntw,"when calling forUnitsInRange in City, line 313")
set siw=El[Vtw]
set tiw=Zl[Vtw]
set Cb[Xb]="when calling alloc_City_City_ForGroupCallback_line317 in City, line 317"
set Xb=Xb+1
if qO==0 then
if aO<32768 then
set aO=aO+1
set Mtw=aO
set nO[Mtw]=689
else
call q1("Out of memory: Could not create City_City_ForGroupCallback_line317.","when calling error in City, line 317")
set Mtw=0
endif
else
set qO=qO-1
set Mtw=eO[qO]
set nO[Mtw]=689
endif
set Xb=Xb-1
set Cl[Mtw]=Vtw
call SB(siw,tiw,1500.0,Mtw,"when calling forUnitsInRange in City, line 317")
if Al[Vtw]<0.0 then
set Al[Vtw]=0.0
endif
if Al[Vtw]>100.0 then
set Al[Vtw]=100.0
endif
if Al[Vtw]<50.0 then
set wiw=GetRandomReal(0.0,1.0)<=0.01
else
set wiw=false
endif
if wiw then
call tww(ml[Vtw],"when calling checkForRevolt in City, line 328")
endif
set Xb=Xb-1
return Al[Vtw]
endfunction
function Ctw takes integer Ptw,string Atw returns integer
local integer Dtw
local real Htw
local real Jtw
local real Ktw
local real Ltw
local real Xtw
set Cb[Xb]=Atw
set Xb=Xb+1
set Dtw=0
set Dtw=0+cdw(iS,GetUnitTypeId(xl[Ptw]),"when calling get in City, line 283")
set Xtw=Ul[Ptw]*1.
set Cb[Xb]="when calling countPublicOrder in City, line 295"
set Xb=Xb+1
if pO[Ptw]==0 then
if Ptw==0 then
call q1("Nullpointer exception when calling City.countPublicOrder","when calling error in City, line 308")
else
call q1("Called City.countPublicOrder on invalid object.","when calling error in City, line 308")
endif
endif
set Ltw=iiw(Ptw,"when calling countPublicOrder in City, line 308")
set Xb=Xb-1
set Htw=Ltw/100.
set Jtw=bo
if 0.75>Jtw then
set Ktw=0.75
else
set Ktw=Jtw
endif
if Htw>Ktw then
set Ktw=Htw
endif
set Dtw=Dtw+R2I(SquareRoot(Xtw*Ktw)/6.)
set Dtw=R2I(Dtw*Hl[Ptw]*TS[Jl[Ptw]])
set Xb=Xb-1
return Dtw
endfunction
function K8 takes multiboard E8,integer Z8,integer U8,string I8,real P8 returns nothing
local multiboarditem A8=MultiboardGetItem(E8,U8,Z8)
local string D8=I8
local string H8
local integer J8
set U8=R2I((R2I(P8/0.004)-StringLength(I8))*1./2)
set H8=""
set J8=0
set Z8=U8-1
loop
exitwhen J8>Z8
set H8=H8+" "
set J8=J8+1
endloop
if ModuloReal(U8,2)==1. then
set D8=" "+D8
endif
set D8=H8+D8
call MultiboardSetItemValue(A8,D8)
set A8=null
endfunction
function edw takes integer ydw,string pdw returns nothing
set Cb[Xb]=pdw
set Xb=Xb+1
if XO[ydw]==0 then
if ydw==0 then
call q1("Nullpointer exception when calling FoldClosure.FoldClosure","when calling error in LinkedList, line 498")
else
call q1("Called FoldClosure.FoldClosure on invalid object.","when calling error in LinkedList, line 498")
endif
endif
set Cb[Xb]="when calling destroyFoldClosure in LinkedList, line 498"
set Xb=Xb+1
set Cb[Xb]="when calling dealloc_FoldClosure in LinkedList, line 498"
set Xb=Xb+1
if XO[ydw]==0 then
call q1("Double free: object of type FoldClosure","when calling error in LinkedList, line 498")
else
set JO[KO]=ydw
set KO=KO+1
set XO[ydw]=0
endif
set Xb=Xb-1-1-1
endfunction
function lww takes string rww,string sww returns integer
local integer tww_2
local integer iww
local boolean Sww
local integer cww
local string oww
local integer Oww
set Cb[Xb]=sww
set Xb=Xb+1
set tww_2=StringHash(rww)
loop
set iww=Io
set Cb[Xb]="when calling hasString in TypeCasting, line 25"
set Xb=Xb+1
if AO[iww]==0 then
if iww==0 then
call q1("Nullpointer exception when calling Table.hasString","when calling error in Table, line 18")
else
call q1("Called Table.hasString on invalid object.","when calling error in Table, line 18")
endif
endif
set Sww=HaveSavedString(Wo,iww,tww_2)
set Xb=Xb-1
if Sww then
set cww=Io
set Cb[Xb]="when calling loadString in TypeCasting, line 26"
set Xb=Xb+1
if AO[cww]==0 then
if cww==0 then
call q1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call q1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set oww=LoadStr(Wo,cww,tww_2)
set Xb=Xb-1
exitwhen oww==rww
else
set Oww=Io
set Cb[Xb]="when calling saveString in TypeCasting, line 29"
set Xb=Xb+1
if AO[Oww]==0 then
if Oww==0 then
call q1("Nullpointer exception when calling Table.saveString","when calling error in Table, line 60")
else
call q1("Called Table.saveString on invalid object.","when calling error in Table, line 60")
endif
endif
set sww=rww
call SaveStr(Wo,Oww,tww_2,rww)
set Xb=Xb-1
exitwhen true
endif
set tww_2=tww_2+1
endloop
set Xb=Xb-1
return tww_2
endfunction
function s4 takes integer N1,integer M1,integer w4,string u4 returns integer
local integer r4
set Cb[Xb]=u4
set Xb=Xb+1
set Cb[Xb]="when calling stringFromIndex in LinkedList, line 349"
set Xb=Xb+1
set N1=Io
set Cb[Xb]="when calling loadString in TypeCasting, line 35"
set Xb=Xb+1
if AO[N1]==0 then
if N1==0 then
call q1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call q1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set u4=LoadStr(Wo,N1,w4)
set Xb=Xb-1-1
set r4=lww(u4+I2S(M1)+",","when calling stringToIndex in LinkedList, line 349")
set Xb=Xb-1
return r4
endfunction
function Ebw takes integer Fbw,integer kbw,integer jbw,string xbw returns integer
local integer vbw
local integer mbw
local integer Qbw
local integer Wbw
set Cb[Xb]=xbw
set Xb=Xb+1
set vbw=kbw
set mbw=Yb[kb[Fbw]]
loop
exitwhen mbw==kb[Fbw]
set Qbw=Rb[mbw]
set xbw="when calling run in LinkedList, line 281"
set Cb[Xb]="when calling run in LinkedList, line 281"
set Xb=Xb+1
if XO[jbw]==0 then
if jbw==0 then
call q1("Nullpointer exception when calling FoldClosure.run","when calling error in LinkedList, line 499")
else
call q1("Called FoldClosure.run on invalid object.","when calling error in LinkedList, line 499")
endif
endif
set Wbw=s4(jbw,Qbw,vbw,"when calling run_wrapper in LinkedList, line 499")
set Xb=Xb-1
set vbw=Wbw
set mbw=Yb[mbw]
endloop
call edw(jbw,"when calling dispatch_FoldClosure_destroyFoldClosure in LinkedList, line 283")
set Xb=Xb-1
return vbw
endfunction
function Jbw takes integer Zbw,string Ubw returns string
local integer Ibw
local integer Pbw
local integer Abw
local string Dbw
local integer Hbw
set Cb[Xb]=Ubw
set Xb=Xb+1
set Ibw=lww("[","when calling stringToIndex in LinkedList, line 349")
set Cb[Xb]="when calling alloc_LinkedList_LinkedList_FoldClosure_line349 in LinkedList, line 349"
set Xb=Xb+1
if KO==0 then
if LO<32768 then
set LO=LO+1
set Pbw=LO
set XO[Pbw]=686
else
call q1("Out of memory: Could not create LinkedList_LinkedList_FoldClosure_line349.","when calling error in LinkedList, line 349")
set Pbw=0
endif
else
set KO=KO-1
set Pbw=JO[KO]
set XO[Pbw]=686
endif
set Xb=Xb-1
set Cb[Xb]="when calling foldl in LinkedList, line 349"
set Xb=Xb+1
if Sl[Zbw]==0 then
if Zbw==0 then
call q1("Nullpointer exception when calling LinkedList.foldl","when calling error in LinkedList, line 277")
else
call q1("Called LinkedList.foldl on invalid object.","when calling error in LinkedList, line 277")
endif
endif
set Hbw=Ebw(Zbw,Ibw,Pbw,"when calling foldl in LinkedList, line 277")
set Xb=Xb-1
set Cb[Xb]="when calling stringFromIndex in LinkedList, line 349"
set Xb=Xb+1
set Abw=Io
set Cb[Xb]="when calling loadString in TypeCasting, line 35"
set Xb=Xb+1
if AO[Abw]==0 then
if Abw==0 then
call q1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call q1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set Dbw=LoadStr(Wo,Abw,Hbw)
set Xb=Xb-1-1
set Ubw=SubString(Dbw,0,StringLength(Dbw)-1)+"]"
set Xb=Xb-1
return Ubw
endfunction
function Qaw takes integer jaw,string xaw returns integer
local integer vaw
local integer maw
set Cb[Xb]=xaw
set Xb=Xb+1
if pO[jaw]==0 then
if jaw==0 then
call q1("Nullpointer exception when calling City.getModifiers","when calling error in City, line 391")
else
call q1("Called City.getModifiers on invalid object.","when calling error in City, line 391")
endif
endif
set Cb[Xb]="when calling getModifiers in City, line 391"
set Xb=Xb+1
set maw=Ll[jaw]
set Cb[Xb]="when calling toString in City, line 392"
set Xb=Xb+1
if Sl[maw]==0 then
if maw==0 then
call q1("Nullpointer exception when calling LinkedList.toString","when calling error in LinkedList, line 348")
else
call q1("Called LinkedList.toString on invalid object.","when calling error in LinkedList, line 348")
endif
endif
set xaw=Jbw(maw,"when calling toString in LinkedList, line 348")
set Xb=Xb-1
call I2(xaw)
set Xb=Xb-1
set vaw=Ll[jaw]
set Xb=Xb-1
return vaw
endfunction
function aiw takes integer eiw returns string
local string qiw
if Ul[eiw]<100000 then
set qiw=I2S(R2I(Ul[eiw]*1./1000))+","+I2S(R2I(ModuloReal(Ul[eiw],1000)/100.))+"k"
else
set qiw=I2S(R2I(Ul[eiw]*1./1000))+"k"
endif
return qiw
endfunction
function k2 takes real F2 returns real
if F2>0. then
return 1.
elseif F2<0. then
return -1.
else
return 0.
endif
endfunction
function dww takes integer aww returns string
local string nww="|cff15ff00+"
if k2(aww*1.)==-1. then
set nww="|cffff0000"
endif
return nww+I2S(aww)+"|r"
endfunction
function piw takes integer Siw,string ciw returns string
local real oiw
local integer Oiw
local integer liw
local integer biw
local integer yiw
set Cb[Xb]=ciw
set Xb=Xb+1
set Cb[Xb]="when calling countPublicOrder in City, line 339"
set Xb=Xb+1
if pO[Siw]==0 then
if Siw==0 then
call q1("Nullpointer exception when calling City.countPublicOrder","when calling error in City, line 308")
else
call q1("Called City.countPublicOrder on invalid object.","when calling error in City, line 308")
endif
endif
set oiw=iiw(Siw,"when calling countPublicOrder in City, line 308")
set Xb=Xb-1
set biw=R2I(255.-oiw/100.*255.)
set yiw=R2I(oiw/100.*255.)
set Oiw=biw/16
set liw=yiw/16
set ciw=StringCase("|cff"+VS[Oiw]+VS[biw-Oiw*16]+VS[liw]+VS[yiw-liw*16]+VS[0]+VS[0],false)+I2S(R2I(oiw))+","+I2S(R2I(ModuloReal(R2I(oiw*10.),10)))+"%|r"
set Xb=Xb-1
return ciw
endfunction
function pew takes integer Ipw,string Ppw returns nothing
local integer Apw
local multiboard Dpw
local integer Hpw
local integer Jpw
local integer Kpw
local multiboard Lpw
local integer Xpw
local integer Cpw
local multiboard Vpw
local integer Bpw
local integer Npw
local integer Mpw
local string wew
local integer uew
local string rew
local integer sew
local string tew
local integer iew
local string Sew
local integer cew
local integer oew
local integer Oew
local integer lew
local string bew
local string yew
set Cb[Xb]=Ppw
set Xb=Xb+1
if Db[Ipw]==-1 then
set Xb=Xb-1
set Dpw=null
set Lpw=null
set Vpw=null
return
endif
set Apw=GetPlayerId(Pb[Ipw])
call K8(Lc[Apw],Jc[0],Jc[1],kaw(hS[Db[Ipw]],"when calling getCityNameColored in PlayerStats, line 76"),0.40)
set Bpw=hS[Db[Ipw]]
set Cb[Xb]="when calling countTax in PlayerStats, line 85"
set Xb=Xb+1
if pO[Bpw]==0 then
if Bpw==0 then
call q1("Nullpointer exception when calling City.countTax","when calling error in City, line 279")
else
call q1("Called City.countTax on invalid object.","when calling error in City, line 279")
endif
endif
set Npw=Ctw(Bpw,"when calling countTax in City, line 279")
set Xb=Xb-1
set Mpw=hS[Db[Ipw]]
set Cb[Xb]="when calling getTaxLevelString in PlayerStats, line 86"
set Xb=Xb+1
if pO[Mpw]==0 then
if Mpw==0 then
call q1("Nullpointer exception when calling City.getTaxLevelString","when calling error in City, line 176")
else
call q1("Called City.getTaxLevelString on invalid object.","when calling error in City, line 176")
endif
endif
set wew=Qo[Jl[Mpw]]
set Xb=Xb-1
set uew=hS[Db[Ipw]]
set Cb[Xb]="when calling getPublicOrderStr in PlayerStats, line 87"
set Xb=Xb+1
if pO[uew]==0 then
if uew==0 then
call q1("Nullpointer exception when calling City.getPublicOrderStr","when calling error in City, line 338")
else
call q1("Called City.getPublicOrderStr on invalid object.","when calling error in City, line 338")
endif
endif
set rew=piw(uew,"when calling getPublicOrderStr in City, line 338")
set Xb=Xb-1
set sew=hS[Db[Ipw]]
set Cb[Xb]="when calling getPopulationStr in PlayerStats, line 88"
set Xb=Xb+1
if pO[sew]==0 then
if sew==0 then
call q1("Nullpointer exception when calling City.getPopulationStr","when calling error in City, line 359")
else
call q1("Called City.getPopulationStr on invalid object.","when calling error in City, line 359")
endif
endif
set tew=aiw(sew)
set Xb=Xb-1
set iew=hS[Db[Ipw]]
set Cb[Xb]="when calling getPopulationGrowthStr in PlayerStats, line 89"
set Xb=Xb+1
if pO[iew]==0 then
if iew==0 then
call q1("Nullpointer exception when calling City.getPopulationGrowthStr","when calling error in City, line 356")
else
call q1("Called City.getPopulationGrowthStr on invalid object.","when calling error in City, line 356")
endif
endif
set Sew=dww(Il[iew])
set Xb=Xb-1
set Dpw=Lc[Apw]
set cew=Pc[0]
set oew=Pc[1]
set Ppw=I2S(Npw)
call MultiboardSetItemValue(MultiboardGetItem(Dpw,oew,cew),Ppw)
call MultiboardSetItemValue(MultiboardGetItem(Dpw,Pc[1],Pc[0]+1),wew)
call MultiboardSetItemValue(MultiboardGetItem(Dpw,Ac[1],Ac[0]),rew)
call MultiboardSetItemValue(MultiboardGetItem(Dpw,Dc[1],Dc[0]),tew)
call MultiboardSetItemValue(MultiboardGetItem(Dpw,Hc[1],Hc[0]),Sew)
set Hpw=0
set Oew=Qaw(hS[Db[Ipw]],"when calling getModifiers in PlayerStats, line 99")
set Cb[Xb]="when calling iterator in PlayerStats, line 99"
set Xb=Xb+1
set lew=obw(Oew,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set Jpw=lew
loop
exitwhen Yb[gb[Jpw]]==Gb[Jpw]
set gb[Jpw]=Yb[gb[Jpw]]
set Kpw=Rb[gb[Jpw]]
set Lpw=Lc[Apw]
set bew=kl[cdw(aS,Kpw,"when calling get in PlayerStats, line 101")]
call MultiboardSetItemValue(MultiboardGetItem(Lpw,4+Hpw,4),bew)
set yew="("+jl[cdw(aS,Kpw,"when calling get in PlayerStats, line 102")]+")"
call MultiboardSetItemValue(MultiboardGetItem(Lpw,4+Hpw,5),yew)
set Hpw=Hpw+1
endloop
set Cb[Xb]="when calling close in PlayerStats, line 99"
set Xb=Xb+1
if Fb[Jpw]then
call Rdw(Jpw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1
set Xpw=Hpw
set Cpw=9
loop
exitwhen Xpw>Cpw
set Vpw=Lc[Apw]
call MultiboardSetItemValue(MultiboardGetItem(Vpw,4+Xpw,4)," ")
call MultiboardSetItemValue(MultiboardGetItem(Vpw,4+Xpw,5)," ")
set Xpw=Xpw+1
endloop
set Xb=Xb-1
set Dpw=null
set Lpw=null
set Vpw=null
endfunction
function itw takes integer Nsw,string Msw returns nothing
local integer wtw
local integer utw
local integer rtw
local integer stw
local integer ttw
set Cb[Xb]=Msw
set Xb=Xb+1
set wtw=0
set utw=23
loop
exitwhen wtw>utw
set rtw=Mc[wtw]
set Cb[Xb]="when calling getSelectedCityId in City, line 252"
set Xb=Xb+1
if yl[rtw]==0 then
if rtw==0 then
call q1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call q1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set stw=Db[rtw]
set Xb=Xb-1
if stw==ml[Nsw]then
set ttw=Mc[wtw]
set Msw="when calling refreshMultiboardCity in City, line 253"
set Cb[Xb]="when calling refreshMultiboardCity in City, line 253"
set Xb=Xb+1
if yl[ttw]==0 then
if ttw==0 then
call q1("Nullpointer exception when calling PlayerStats.refreshMultiboardCity","when calling error in PlayerStats, line 71")
else
call q1("Called PlayerStats.refreshMultiboardCity on invalid object.","when calling error in PlayerStats, line 71")
endif
endif
call pew(ttw,"when calling refreshMultiboardCity in PlayerStats, line 71")
set Xb=Xb-1
endif
set wtw=wtw+1
endloop
set Xb=Xb-1
endfunction
function qtw takes integer ltw,integer btw,string ytw returns nothing
local integer ptw
local integer etw
set Cb[Xb]=ytw
set Xb=Xb+1
if btw==PLAYER_NEUTRAL_AGGRESSIVE then
call SetUnitOwner(xl[ltw],Player(PLAYER_NEUTRAL_AGGRESSIVE),true)
set Cb[Xb]="when calling changeTaxLevelFORCED in City, line 204"
set Xb=Xb+1
if pO[ltw]==0 then
if ltw==0 then
call q1("Nullpointer exception when calling City.changeTaxLevelFORCED","when calling error in City, line 273")
else
call q1("Called City.changeTaxLevelFORCED on invalid object.","when calling error in City, line 273")
endif
endif
set Dl[ltw]=Dl[ltw]-YS[Jl[ltw]]
set Dl[ltw]=Dl[ltw]+YS[0]
set Jl[ltw]=0
set Xb=Xb-1
else
call SetUnitOwner(xl[ltw],wo[btw],true)
endif
set Wl[ltw]=btw
if btw>=0 and btw<24 then
set ptw=Mc[btw]
set Cb[Xb]="when calling getForceId in City, line 211"
set Xb=Xb+1
if yl[ptw]==0 then
if ptw==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set etw=Ib[ptw]
set Xb=Xb-1
set Ql[ltw]=etw
endif
set Cb[Xb]="when calling refreshMultiboardIfPossible in City, line 213"
set Xb=Xb+1
if pO[ltw]==0 then
if ltw==0 then
call q1("Nullpointer exception when calling City.refreshMultiboardIfPossible","when calling error in City, line 250")
else
call q1("Called City.refreshMultiboardIfPossible on invalid object.","when calling error in City, line 250")
endif
endif
call itw(ltw,"when calling refreshMultiboardIfPossible in City, line 250")
set Xb=Xb-1-1
endfunction
function Rtw takes integer atw,integer ntw,string dtw returns nothing
local integer ftw
set Cb[Xb]=dtw
set Xb=Xb+1
set ftw=Ql[atw]
if ftw==0 then
set Cb[Xb]="when calling replaceCity in City, line 218"
set Xb=Xb+1
if pO[atw]==0 then
if atw==0 then
call q1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call q1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call Otw(atw,1747988529,"when calling replaceCity in City, line 194")
set Xb=Xb-1
elseif ftw==3 then
set Cb[Xb]="when calling replaceCity in City, line 220"
set Xb=Xb+1
if pO[atw]==0 then
if atw==0 then
call q1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call q1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call Otw(atw,1747989590,"when calling replaceCity in City, line 194")
set Xb=Xb-1
elseif ftw==1 then
set Cb[Xb]="when calling replaceCity in City, line 222"
set Xb=Xb+1
if pO[atw]==0 then
if atw==0 then
call q1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call q1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call Otw(atw,1747990326,"when calling replaceCity in City, line 194")
set Xb=Xb-1
elseif ftw==2 then
set Cb[Xb]="when calling replaceCity in City, line 224"
set Xb=Xb+1
if pO[atw]==0 then
if atw==0 then
call q1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call q1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call Otw(atw,1747990084,"when calling replaceCity in City, line 194")
set Xb=Xb-1
endif
set Cb[Xb]="when calling changeOwner in City, line 225"
set Xb=Xb+1
if pO[atw]==0 then
if atw==0 then
call q1("Nullpointer exception when calling City.changeOwner","when calling error in City, line 199")
else
call q1("Called City.changeOwner on invalid object.","when calling error in City, line 199")
endif
endif
call qtw(atw,ntw,"when calling changeOwner in City, line 199")
set Xb=Xb-1-1
endfunction
function eC takes string MX returns nothing
local integer wC
local integer uC
local integer rC
local integer sC
local integer tC
local integer iC
local integer SC
local integer cC
local integer oC
local integer OC
local player lC
local location bC
local real yC
local integer pC
set Cb[Xb]=MX
set Xb=Xb+1
set wC=CC(GetSpellTargetUnit(),"when calling getCityId in CityManage, line 19")
set sC=hS[wC]
set Cb[Xb]="when calling getCityForceId in CityManage, line 20"
set Xb=Xb+1
if pO[sC]==0 then
if sC==0 then
call q1("Nullpointer exception when calling City.getCityForceId","when calling error in City, line 191")
else
call q1("Called City.getCityForceId on invalid object.","when calling error in City, line 191")
endif
endif
set tC=Ql[sC]
set Xb=Xb-1
set uC=GetPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))
set iC=Mc[uC]
set Cb[Xb]="when calling changeForce in CityManage, line 22"
set Xb=Xb+1
if yl[iC]==0 then
if iC==0 then
call q1("Nullpointer exception when calling PlayerStats.changeForce","when calling error in PlayerStats, line 125")
else
call q1("Called PlayerStats.changeForce on invalid object.","when calling error in PlayerStats, line 125")
endif
endif
call Dew(iC,tC)
set Xb=Xb-1
set SC=Lo[tC]
set Cb[Xb]="when calling iterator in CityManage, line 25"
set Xb=Xb+1
set cC=obw(SC,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set rC=cC
loop
exitwhen Yb[gb[rC]]==Gb[rC]
set gb[rC]=Yb[gb[rC]]
set oC=1
set OC=Rb[gb[rC]]
set lC=wo[uC]
set bC=GetSpellTargetLoc()
set yC=0.
call GroupClear(bj_lastCreatedGroup)
loop
set oC=oC-1
exitwhen oC<0
call CreateUnitAtLocSaveLast(lC,OC,bC,yC)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
endloop
set Cb[Xb]="when calling close in CityManage, line 25"
set Xb=Xb+1
if Fb[rC]then
call Rdw(rC,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1
set pC=hS[wC]
set Cb[Xb]="when calling settleCity in CityManage, line 28"
set Xb=Xb+1
if pO[pC]==0 then
if pC==0 then
call q1("Nullpointer exception when calling City.settleCity","when calling error in City, line 215")
else
call q1("Called City.settleCity on invalid object.","when calling error in City, line 215")
endif
endif
call Rtw(pC,uC,"when calling settleCity in City, line 215")
set Xb=Xb-1
call KillUnit(GetSpellAbilityUnit())
set Xb=Xb-1
set lC=null
set bC=null
endfunction
function AFw takes nothing returns nothing
set Xb=0
call eC("CityManage, line 18")
endfunction
function AK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function AQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988812,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988559,0)
endfunction
function AT takes nothing returns nothing
call SetFloatGameState(GAME_STATE_TIME_OF_DAY,bj_MELEE_STARTING_TOD)
call MeleeStartingHeroLimit()
endfunction
function BA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990599,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990600,0)
endfunction
function gww takes integer dww_2,string fww returns trigger
local integer Rww
local fogstate Tww
local integer Yww
local trigger Gww
set Cb[Xb]=fww
set Xb=Xb+1
set Rww=Io
set Tww=ConvertFogState(dww_2)
set Cb[Xb]="when calling saveFogState in TypeCasting, line 94"
set Xb=Xb+1
if AO[Rww]==0 then
if Rww==0 then
call q1("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call q1("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call SaveFogStateHandle(Wo,Rww,0,Tww)
set Xb=Xb-1
set Yww=Io
set Cb[Xb]="when calling loadTrigger in TypeCasting, line 95"
set Xb=Xb+1
if AO[Yww]==0 then
if Yww==0 then
call q1("Nullpointer exception when calling Table.loadTrigger","when calling error in Table, line 111")
else
call q1("Called Table.loadTrigger on invalid object.","when calling error in Table, line 111")
endif
endif
set Gww=LoadTriggerHandle(Wo,Yww,0)
set Xb=Xb-1-1
set lR=Gww
set Tww=null
set Gww=null
return lR
endfunction
function k0w takes string h0w returns boolean
local boolean F0w
set Cb[Xb]=h0w
set Xb=Xb+1
set F0w=TriggerEvaluate(gww(cdw(po,GetSpellAbilityId(),"when calling get in RegisterEvents, line 58"),"when calling triggerFromIndex in RegisterEvents, line 58"))
set Xb=Xb-1
return F0w
endfunction
function BFw takes nothing returns boolean
set Xb=0
return k0w("RegisterEvents, line 58")
endfunction
function VG takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function BG takes nothing returns nothing
if VG() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function BI takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,Xq)
endfunction
function BJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function BY takes nothing returns boolean
if GetSpellAbilityId()!=1093677620 then
return false
endif
return true
endfunction
function BZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989570,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989556,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989559,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989557,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989560,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989573,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989574,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651841,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651833,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651832,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989582,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990097,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989812,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990098,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990099,0)
endfunction
function Vg takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function Bg takes nothing returns nothing
if Vg() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function Vh takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function Bh takes nothing returns nothing
if Vh() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function hbw takes string Gbw returns integer
local integer gbw
set Cb[Xb]=Gbw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_LinkedList in LinkedList, line 31"
set Xb=Xb+1
if tl==0 then
if il<32768 then
set il=il+1
set gbw=il
set Sl[gbw]=706
else
call q1("Out of memory: Could not create LinkedList.","when calling error in LinkedList, line 17")
set gbw=0
endif
else
set tl=tl-1
set gbw=sl[tl]
set Sl[gbw]=706
endif
set Xb=Xb-1
set Cb[Xb]="when calling construct_LinkedList2 in LinkedList, line 31"
set Xb=Xb+1
set kb[gbw]=tbw(0,0,0,"when calling new_LLEntry in LinkedList, line 18")
set jb[gbw]=0
set Yb[kb[gbw]]=kb[gbw]
set Tb[kb[gbw]]=kb[gbw]
set Xb=Xb-1-1
return gbw
endfunction
function Bhw takes nothing returns boolean
local integer Vhw
set Xb=0
set Cb[Xb]="Abilities, line 1"
set Xb=Xb+1
set Cb[Xb]="when calling asList in Abilities, line 17"
set Xb=Xb+1
set Vhw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(Vhw,1093677642,"when calling add in LinkedList, line 393")
call Ndw(Vhw,1093677641,"when calling add in LinkedList, line 393")
call Ndw(Vhw,1093677640,"when calling add in LinkedList, line 393")
call Ndw(Vhw,1093678155,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set sS=Vhw
set Xb=Xb-1
return true
endfunction
function Bj takes nothing returns nothing
local player Ij=GetOwningPlayer(GetKillingUnit())
local playerstate Pj=PLAYER_STATE_RESOURCE_GOLD
local playerstate Aj
local playerstate Dj
local player Hj
local force Jj
local location Kj
local real Lj
local real Xj
local player Cj
local force Vj
if Pj==PLAYER_STATE_RESOURCE_GOLD then
set Aj=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Ij,Aj,GetPlayerState(Ij,Aj)+125)
elseif Pj==PLAYER_STATE_RESOURCE_LUMBER then
set Dj=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Ij,Dj,GetPlayerState(Ij,Dj)+125)
endif
call SetPlayerState(Ij,Pj,GetPlayerState(Ij,Pj)+125)
set Hj=GetOwningPlayer(GetKillingUnit())
set Jj=CreateForce()
call ForceAddPlayer(Jj,Hj)
if IsPlayerInForce(GetLocalPlayer(),Jj) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_091")
endif
set y=GetUnitLoc(GetDyingUnit())
set Cj=GetOwningPlayer(GetDyingUnit())
set Vj=CreateForce()
call ForceAddPlayer(Vj,Cj)
set Kj=y
set Lj=GetLocationX(Kj)
set Xj=GetLocationY(Kj)
if IsPlayerInForce(GetLocalPlayer(),Vj) then
call PingMinimap(Lj,Xj,2.00)
endif
call RemoveLocation(y)
set Ij=null
set Pj=null
set Aj=null
set Dj=null
set Hj=null
set Jj=null
set Kj=null
set Cj=null
set Vj=null
endfunction
function Bk takes nothing returns nothing
local player Ik=GetOwningPlayer(GetSpellTargetUnit())
local playerstate Pk=PLAYER_STATE_RESOURCE_GOLD
local playerstate Ak
local playerstate Dk
local player Hk
local force Jk
local location Kk
local real Lk
local real Xk
local player Ck
local force Vk
if Pk==PLAYER_STATE_RESOURCE_GOLD then
set Ak=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Ik,Ak,GetPlayerState(Ik,Ak)+500)
elseif Pk==PLAYER_STATE_RESOURCE_LUMBER then
set Dk=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Ik,Dk,GetPlayerState(Ik,Dk)+500)
endif
call SetPlayerState(Ik,Pk,GetPlayerState(Ik,Pk)+500)
call RemoveUnit(GetSpellAbilityUnit())
set Hk=GetOwningPlayer(GetSpellTargetUnit())
set Jk=CreateForce()
call ForceAddPlayer(Jk,Hk)
if IsPlayerInForce(GetLocalPlayer(),Jk) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1231")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set Ck=GetOwningPlayer(GetSpellTargetUnit())
set Vk=CreateForce()
call ForceAddPlayer(Vk,Ck)
set Kk=y
set Lk=GetLocationX(Kk)
set Xk=GetLocationY(Kk)
if IsPlayerInForce(GetLocalPlayer(),Vk) then
call PingMinimap(Lk,Xk,2.00)
endif
call RemoveLocation(y)
set Ik=null
set Pk=null
set Ak=null
set Dk=null
set Hk=null
set Jk=null
set Kk=null
set Ck=null
set Vk=null
endfunction
function Bm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989066,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988551,0)
endfunction
function K2 takes player P2,string A2 returns string
local integer D2
local integer H2
local integer J2
set Cb[Xb]=A2
set Xb=Xb+1
set H2=Mc[GetPlayerId(P2)]
set Cb[Xb]="when calling getForceId in Messages, line 5"
set Xb=Xb+1
if yl[H2]==0 then
if H2==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set J2=Ib[H2]
set Xb=Xb-1
set D2=GetRandomInt(0,2)
if J2==0 then
set A2=ao[D2]
elseif J2==1 then
set A2=no[D2]
elseif J2==2 then
set A2=do[D2]
elseif J2==3 then
set A2=fo[D2]
else
set A2="Warning!"
endif
set Xb=Xb-1
return "|cffff0000"+A2+"|r"
endfunction
function N2 takes player L2,string X2 returns string
local integer C2
local integer V2
local integer B2
set Cb[Xb]=X2
set Xb=Xb+1
set V2=Mc[GetPlayerId(L2)]
set Cb[Xb]="when calling getForceId in Messages, line 21"
set Xb=Xb+1
if yl[V2]==0 then
if V2==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set B2=Ib[V2]
set Xb=Xb-1
set C2=GetRandomInt(0,2)
if B2==0 then
set X2=Ro[C2]
elseif B2==1 then
set X2=To[C2]
elseif B2==2 then
set X2=Yo[C2]
elseif B2==3 then
set X2=Go[C2]
else
set X2="Note:"
endif
set Xb=Xb-1
return "|cff00ccff"+X2+"|r"
endfunction
function nkw takes integer pkw,integer ekw,string qkw returns integer
local integer akw
if ekw<0 or ekw>=24 then
call q1("Index out of Bounds",qkw)
elseif ekw<=11 then
if ekw<=5 then
if ekw<=2 then
if ekw<=1 then
if ekw<=0 then
set akw=Mb[pkw]
else
set akw=wy[pkw]
endif
else
set akw=uy[pkw]
endif
elseif ekw<=4 then
if ekw<=3 then
set akw=ry[pkw]
else
set akw=sy[pkw]
endif
else
set akw=ty[pkw]
endif
elseif ekw<=8 then
if ekw<=7 then
if ekw<=6 then
set akw=iy[pkw]
else
set akw=Sy[pkw]
endif
else
set akw=cy[pkw]
endif
elseif ekw<=10 then
if ekw<=9 then
set akw=oy[pkw]
else
set akw=Oy[pkw]
endif
else
set akw=ly[pkw]
endif
elseif ekw<=17 then
if ekw<=14 then
if ekw<=13 then
if ekw<=12 then
set akw=by[pkw]
else
set akw=yy[pkw]
endif
else
set akw=py[pkw]
endif
elseif ekw<=16 then
if ekw<=15 then
set akw=ey[pkw]
else
set akw=qy[pkw]
endif
else
set akw=ay[pkw]
endif
elseif ekw<=20 then
if ekw<=19 then
if ekw<=18 then
set akw=ny[pkw]
else
set akw=dy[pkw]
endif
else
set akw=fy[pkw]
endif
elseif ekw<=22 then
if ekw<=21 then
set akw=Ry[pkw]
else
set akw=Ty[pkw]
endif
else
set akw=Yy[pkw]
endif
return akw
endfunction
function ykw takes integer okw,integer Okw,integer lkw,string bkw returns nothing
if Okw<0 or Okw>=24 then
call q1("Index out of Bounds",bkw)
elseif Okw<=11 then
if Okw<=5 then
if Okw<=2 then
if Okw<=1 then
if Okw<=0 then
set Mb[okw]=lkw
else
set wy[okw]=lkw
endif
else
set uy[okw]=lkw
endif
elseif Okw<=4 then
if Okw<=3 then
set ry[okw]=lkw
else
set sy[okw]=lkw
endif
else
set ty[okw]=lkw
endif
elseif Okw<=8 then
if Okw<=7 then
if Okw<=6 then
set iy[okw]=lkw
else
set Sy[okw]=lkw
endif
else
set cy[okw]=lkw
endif
elseif Okw<=10 then
if Okw<=9 then
set oy[okw]=lkw
else
set Oy[okw]=lkw
endif
else
set ly[okw]=lkw
endif
elseif Okw<=17 then
if Okw<=14 then
if Okw<=13 then
if Okw<=12 then
set by[okw]=lkw
else
set yy[okw]=lkw
endif
else
set py[okw]=lkw
endif
elseif Okw<=16 then
if Okw<=15 then
set ey[okw]=lkw
else
set qy[okw]=lkw
endif
else
set ay[okw]=lkw
endif
elseif Okw<=20 then
if Okw<=19 then
if Okw<=18 then
set ny[okw]=lkw
else
set dy[okw]=lkw
endif
else
set fy[okw]=lkw
endif
elseif Okw<=22 then
if Okw<=21 then
set Ry[okw]=lkw
else
set Ty[okw]=lkw
endif
else
set Yy[okw]=lkw
endif
endfunction
function Uew takes integer mew,player Qew,integer Wew,string Eew returns nothing
local integer Zew
set Cb[Xb]=Eew
set Xb=Xb+1
set Zew=GetPlayerId(Qew)
if not Ab[mew]then
set Xb=Xb-1
return
endif
if Zew>=24 then
set Xb=Xb-1
return
endif
if nkw(mew,Zew,"when reading array PlayerStats_alliance_states in  in PlayerStats, line 61")==Wew or Qew==Pb[mew]then
set Xb=Xb-1
return
endif
call ykw(mew,Zew,Wew,"when writing array PlayerStats_alliance_states in PlayerStats, line 63")
call SetPlayerAllianceStateBJ(Pb[mew],Qew,Wew)
set Xb=Xb-1
endfunction
function PB takes playercolor FB returns integer
local playercolor vB=FB
local integer mB=0
local integer QB=0
local integer WB=bj_MAX_PLAYER_SLOTS-1
local integer kB
local integer jB
local integer xB
local playercolor EB
local integer ZB
local integer UB
local integer IB
loop
exitwhen QB>WB
if co[QB]==vB then
set mB=QB
exitwhen true
endif
set QB=QB+1
endloop
if mB<=23 then
set EB=FB
set ZB=0
set UB=0
set IB=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen UB>IB
if co[UB]==EB then
set ZB=UB
exitwhen true
endif
set UB=UB+1
endloop
set kB=LS[ZB]
set jB=XS[ZB]
set xB=CS[ZB]
else
set kB=0
set jB=0
set xB=0
endif
set Vb=kB
set Bb=jB
set Nb=xB
set vB=null
set EB=null
return Vb
endfunction
function hB takes player dB returns string
local integer YB=PB(GetPlayerColor(dB))
local integer GB=Bb
local integer gB=Nb
local integer fB=YB/16
local integer RB=GB/16
local integer TB=gB/16
return "|cff"+VS[fB]+VS[YB-fB*16]+VS[RB]+VS[GB-RB*16]+VS[TB]+VS[gB-TB*16]+GetPlayerName(dB)+"|r"
endfunction
function t5 takes player M2,string w5 returns string
local integer u5
local integer r5
local integer s5
set Cb[Xb]=w5
set Xb=Xb+1
set r5=Mc[GetPlayerId(M2)]
set Cb[Xb]="when calling getForceId in Messages, line 37"
set Xb=Xb+1
if yl[r5]==0 then
if r5==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set s5=Ib[r5]
set Xb=Xb-1
set u5=GetRandomInt(0,2)
if s5==0 then
set w5=go[u5]
elseif s5==1 then
set w5=ho[u5]
elseif s5==2 then
set w5=Fo[u5]
elseif s5==3 then
set w5=ko[u5]
else
set w5="Good news!"
endif
set Xb=Xb-1
return "|cff00ff00"+w5+"|r"
endfunction
function b3 takes string iM returns nothing
local player SM
local player cM
local string oM
local string OM
local integer lM
local force bM
local force yM
local integer pM
local integer eM
local integer qM
local integer aM
local integer nM
local integer dM
local integer fM
local integer RM
local integer TM
local force YM
local force GM
local integer gM
local integer hM
local integer FM
local integer kM
local integer jM
local integer xM
local player vM
local force mM
local player QM
local player WM
local player EM
local integer ZM
local integer UM
local integer IM
local integer PM
local player AM
local force DM
local player HM
local player JM
local player KM
local integer LM
local integer XM
local integer CM
local integer VM
local player BM
local force NM
local player MM
local player w3
local player u3
local integer r3
local integer s3
local integer t3
local integer i3
local player S3
local force c3
local player o3
local player O3
local player l3
set Cb[Xb]=iM
set Xb=Xb+1
set SM=GetOwningPlayer(GetSpellAbilityUnit())
set cM=GetOwningPlayer(GetSpellTargetUnit())
set oM=hB(SM)
set OM=hB(cM)
set lM=GetPlayerId(SM)
set YM=CreateForce()
call ForceAddPlayer(YM,SM)
set bM=YM
set GM=CreateForce()
call ForceAddPlayer(GM,SM)
set yM=GM
set pM=GetSpellAbilityId()
if pM==1093677396 then
set gM=Mc[lM]
set Cb[Xb]="when calling getAllianceState in Diplomacy, line 16"
set Xb=Xb+1
if yl[gM]==0 then
if gM==0 then
call q1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call q1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Cb[Xb]="when calling getAllianceState in PlayerStats, line 66"
set Xb=Xb+1
set hM=nkw(gM,GetPlayerId(cM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Xb=Xb-1-1
if hM==bj_ALLIANCE_UNALLIED then
set Xb=Xb-1
set SM=null
set cM=null
set bM=null
set yM=null
set YM=null
set GM=null
set vM=null
set mM=null
set QM=null
set WM=null
set EM=null
set AM=null
set DM=null
set HM=null
set JM=null
set KM=null
set BM=null
set NM=null
set MM=null
set w3=null
set u3=null
set S3=null
set c3=null
set o3=null
set O3=null
set l3=null
return
endif
set FM=Mc[lM]
set kM=bj_ALLIANCE_UNALLIED
set Cb[Xb]="when calling setAlliance in Diplomacy, line 18"
set Xb=Xb+1
if yl[FM]==0 then
if FM==0 then
call q1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call q1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Uew(FM,cM,kM,"when calling setAlliance in PlayerStats, line 55")
set Xb=Xb-1
set jM=Mc[GetPlayerId(cM)]
set xM=bj_ALLIANCE_UNALLIED
set Cb[Xb]="when calling setAlliance in Diplomacy, line 19"
set Xb=Xb+1
if yl[jM]==0 then
if jM==0 then
call q1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call q1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Uew(jM,SM,xM,"when calling setAlliance in PlayerStats, line 55")
set Xb=Xb-1
set eM=0
set qM=23
loop
exitwhen eM>qM
set vM=wo[eM]
set mM=CreateForce()
call ForceAddPlayer(mM,vM)
if wo[eM]==cM then
set QM=wo[eM]
set Cb[Xb]="when calling warningToPlayer in Diplomacy, line 24"
set Xb=Xb+1
call DisplayTimedTextToPlayer(QM,0.,0.,10.0,K2(QM,"when calling getWarningStringForPlayer in Messages, line 79"))
call DisplayTimedTextToPlayer(QM,0.,0.,10.0,oM+" has declared war on you!")
set Xb=Xb-1
elseif mM==bM or mM==yM then
set WM=wo[eM]
set Cb[Xb]="when calling attentionToPlayer in Diplomacy, line 26"
set Xb=Xb+1
call DisplayTimedTextToPlayer(WM,0.,0.,10.0,l5(WM,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(WM,0.,0.,10.0,oM+" has declared war on your brother-in-arms, "+OM+"!")
set Xb=Xb-1
else
set EM=wo[eM]
set Cb[Xb]="when calling noteToPlayer in Diplomacy, line 28"
set Xb=Xb+1
call DisplayTimedTextToPlayer(EM,0.,0.,10.0,N2(EM,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(EM,0.,0.,10.0,oM+" has declared war on "+OM)
set Xb=Xb-1
endif
set eM=eM+1
endloop
elseif pM==1093677397 then
set ZM=Mc[lM]
set Cb[Xb]="when calling getAllianceState in Diplomacy, line 31"
set Xb=Xb+1
if yl[ZM]==0 then
if ZM==0 then
call q1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call q1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Cb[Xb]="when calling getAllianceState in PlayerStats, line 66"
set Xb=Xb+1
set UM=nkw(ZM,GetPlayerId(cM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Xb=Xb-1-1
if UM==bj_ALLIANCE_ALLIED_VISION then
set Xb=Xb-1
set SM=null
set cM=null
set bM=null
set yM=null
set YM=null
set GM=null
set vM=null
set mM=null
set QM=null
set WM=null
set EM=null
set AM=null
set DM=null
set HM=null
set JM=null
set KM=null
set BM=null
set NM=null
set MM=null
set w3=null
set u3=null
set S3=null
set c3=null
set o3=null
set O3=null
set l3=null
return
endif
set IM=Mc[lM]
set PM=bj_ALLIANCE_ALLIED_VISION
set Cb[Xb]="when calling setAlliance in Diplomacy, line 33"
set Xb=Xb+1
if yl[IM]==0 then
if IM==0 then
call q1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call q1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Uew(IM,cM,PM,"when calling setAlliance in PlayerStats, line 55")
set Xb=Xb-1
set aM=0
set nM=23
loop
exitwhen aM>nM
set AM=wo[aM]
set DM=CreateForce()
call ForceAddPlayer(DM,AM)
if wo[aM]==cM then
set HM=wo[aM]
set Cb[Xb]="when calling goodNewsToPlayer in Diplomacy, line 38"
set Xb=Xb+1
call DisplayTimedTextToPlayer(HM,0.,0.,10.0,t5(HM,"when calling getGoodNewsStringForPlayer in Messages, line 85"))
call DisplayTimedTextToPlayer(HM,0.,0.,10.0,oM+" seeks an alliance with you!")
set Xb=Xb-1
elseif DM==bM or DM==yM then
set JM=wo[aM]
set Cb[Xb]="when calling noteToPlayer in Diplomacy, line 40"
set Xb=Xb+1
call DisplayTimedTextToPlayer(JM,0.,0.,10.0,N2(JM,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(JM,0.,0.,10.0,oM+" has allied "+OM)
set Xb=Xb-1
else
set KM=wo[aM]
set Cb[Xb]="when calling noteToPlayer in Diplomacy, line 42"
set Xb=Xb+1
call DisplayTimedTextToPlayer(KM,0.,0.,10.0,N2(KM,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(KM,0.,0.,10.0,oM+" has allied "+OM)
set Xb=Xb-1
endif
set aM=aM+1
endloop
elseif pM==1093677398 then
set LM=Mc[lM]
set Cb[Xb]="when calling getAllianceState in Diplomacy, line 45"
set Xb=Xb+1
if yl[LM]==0 then
if LM==0 then
call q1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call q1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Cb[Xb]="when calling getAllianceState in PlayerStats, line 66"
set Xb=Xb+1
set XM=nkw(LM,GetPlayerId(cM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Xb=Xb-1-1
if XM==bj_ALLIANCE_NEUTRAL then
set Xb=Xb-1
set SM=null
set cM=null
set bM=null
set yM=null
set YM=null
set GM=null
set vM=null
set mM=null
set QM=null
set WM=null
set EM=null
set AM=null
set DM=null
set HM=null
set JM=null
set KM=null
set BM=null
set NM=null
set MM=null
set w3=null
set u3=null
set S3=null
set c3=null
set o3=null
set O3=null
set l3=null
return
endif
set CM=Mc[lM]
set VM=bj_ALLIANCE_NEUTRAL
set Cb[Xb]="when calling setAlliance in Diplomacy, line 47"
set Xb=Xb+1
if yl[CM]==0 then
if CM==0 then
call q1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call q1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Uew(CM,cM,VM,"when calling setAlliance in PlayerStats, line 55")
set Xb=Xb-1
set dM=0
set fM=23
loop
exitwhen dM>fM
set BM=wo[dM]
set NM=CreateForce()
call ForceAddPlayer(NM,BM)
if wo[dM]==cM then
set MM=wo[dM]
set Cb[Xb]="when calling noteToPlayer in Diplomacy, line 52"
set Xb=Xb+1
call DisplayTimedTextToPlayer(MM,0.,0.,10.0,N2(MM,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(MM,0.,0.,10.0,oM+" is now neutral towards you!")
set Xb=Xb-1
elseif NM==bM or NM==yM then
set w3=wo[dM]
set Cb[Xb]="when calling noteToPlayer in Diplomacy, line 54"
set Xb=Xb+1
call DisplayTimedTextToPlayer(w3,0.,0.,10.0,N2(w3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(w3,0.,0.,10.0,oM+" shows neutrality towards "+OM)
set Xb=Xb-1
else
set u3=wo[dM]
set iM="when calling noteToPlayer in Diplomacy, line 56"
set Cb[Xb]="when calling noteToPlayer in Diplomacy, line 56"
set Xb=Xb+1
call DisplayTimedTextToPlayer(u3,0.,0.,10.0,N2(u3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(u3,0.,0.,10.0,oM+" shows neutrality towards "+OM)
set Xb=Xb-1
endif
set dM=dM+1
endloop
elseif pM==1093677400 then
set r3=Mc[lM]
set Cb[Xb]="when calling getAllianceState in Diplomacy, line 59"
set Xb=Xb+1
if yl[r3]==0 then
if r3==0 then
call q1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call q1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Cb[Xb]="when calling getAllianceState in PlayerStats, line 66"
set Xb=Xb+1
set s3=nkw(r3,GetPlayerId(cM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Xb=Xb-1-1
if s3==bj_ALLIANCE_NEUTRAL then
set Xb=Xb-1
set SM=null
set cM=null
set bM=null
set yM=null
set YM=null
set GM=null
set vM=null
set mM=null
set QM=null
set WM=null
set EM=null
set AM=null
set DM=null
set HM=null
set JM=null
set KM=null
set BM=null
set NM=null
set MM=null
set w3=null
set u3=null
set S3=null
set c3=null
set o3=null
set O3=null
set l3=null
return
endif
set t3=Mc[lM]
set i3=bj_ALLIANCE_NEUTRAL
set Cb[Xb]="when calling setAlliance in Diplomacy, line 61"
set Xb=Xb+1
if yl[t3]==0 then
if t3==0 then
call q1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call q1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Uew(t3,cM,i3,"when calling setAlliance in PlayerStats, line 55")
set Xb=Xb-1
set RM=0
set TM=23
loop
exitwhen RM>TM
set S3=wo[RM]
set c3=CreateForce()
call ForceAddPlayer(c3,S3)
if wo[RM]==cM then
set o3=wo[RM]
set Cb[Xb]="when calling noteToPlayer in Diplomacy, line 66"
set Xb=Xb+1
call DisplayTimedTextToPlayer(o3,0.,0.,10.0,N2(o3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(o3,0.,0.,10.0,oM+" unallies you!")
set Xb=Xb-1
elseif c3==bM or c3==yM then
set O3=wo[RM]
set Cb[Xb]="when calling noteToPlayer in Diplomacy, line 68"
set Xb=Xb+1
call DisplayTimedTextToPlayer(O3,0.,0.,10.0,N2(O3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(O3,0.,0.,10.0,oM+" has unallied "+OM)
set Xb=Xb-1
else
set l3=wo[RM]
set Cb[Xb]="when calling noteToPlayer in Diplomacy, line 70"
set Xb=Xb+1
call DisplayTimedTextToPlayer(l3,0.,0.,10.0,N2(l3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(l3,0.,0.,10.0,oM+" has unallied "+OM)
set Xb=Xb-1
endif
set RM=RM+1
endloop
endif
set Xb=Xb-1
set SM=null
set cM=null
set bM=null
set yM=null
set YM=null
set GM=null
set vM=null
set mM=null
set QM=null
set WM=null
set EM=null
set AM=null
set DM=null
set HM=null
set JM=null
set KM=null
set BM=null
set NM=null
set MM=null
set w3=null
set u3=null
set S3=null
set c3=null
set o3=null
set O3=null
set l3=null
endfunction
function CFw takes nothing returns nothing
set Xb=0
call b3("Diplomacy, line 119")
endfunction
function CG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990091 then
return false
endif
return true
endfunction
function CK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function CQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989072,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989073,0)
endfunction
function XW takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function CW takes nothing returns boolean
if not XW() then
return false
endif
return true
endfunction
function Cg takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989077 then
return false
endif
return true
endfunction
function Ch takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990071 then
return false
endif
return true
endfunction
function B1 takes string V1 returns boolean
set Cb[Xb]=V1
set Xb=Xb+1
set Cb[Xb]="when calling alloc_LinkedList_Comparator_line504 in LinkedList, line 504"
set Xb=Xb+1
if DO==0 then
if HO<32768 then
set HO=HO+1
else
call q1("Out of memory: Could not create LinkedList_Comparator_line504.","when calling error in LinkedList, line 504")
endif
else
set DO=DO-1
endif
set Xb=Xb-1
set Cb[Xb]="when calling alloc_LinkedList_Comparator_line508 in LinkedList, line 508"
set Xb=Xb+1
if DO==0 then
if HO<32768 then
set HO=HO+1
else
call q1("Out of memory: Could not create LinkedList_Comparator_line508.","when calling error in LinkedList, line 508")
endif
else
set DO=DO-1
endif
set Xb=Xb-1-1
return true
endfunction
function Chw takes nothing returns boolean
set Xb=0
return B1("LinkedList, line 1")
endfunction
function AA takes nothing returns boolean
if GetResearched()!=1378890054 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890054,true)!=2 then
return false
endif
return true
endfunction
function DA takes nothing returns boolean
if not AA() then
return false
endif
return true
endfunction
function Bnw takes integer Lnw,integer Xnw,string Cnw returns boolean
local boolean Vnw
set Cb[Xb]=Cnw
set Xb=Xb+1
if AO[Lnw]==0 then
if Lnw==0 then
call q1("Nullpointer exception when calling HashMap.has","when calling error in HashMap, line 13")
else
call q1("Called HashMap.has on invalid object.","when calling error in HashMap, line 13")
endif
endif
set Cb[Xb]="when calling has in HashMap, line 13"
set Xb=Xb+1
set Cb[Xb]="when calling hasInt in HashMap, line 14"
set Xb=Xb+1
if AO[Lnw]==0 then
if Lnw==0 then
call q1("Nullpointer exception when calling Table.hasInt","when calling error in Table, line 9")
else
call q1("Called Table.hasInt on invalid object.","when calling error in Table, line 9")
endif
endif
set Vnw=HaveSavedInteger(Wo,Lnw,Xnw)
set Xb=Xb-1-1-1
return Vnw
endfunction
function qOw takes integer lOw,integer bOw,string yOw returns nothing
local hashtable pOw
local integer eOw
set Cb[Xb]=yOw
set Xb=Xb+1
set pOw=nc
set Cb[Xb]="when calling count in HashList, line 19"
set Xb=Xb+1
if ZO[lOw]==0 then
if lOw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set eOw=LoadInteger(nc,lOw,bOw)
set Xb=Xb-1
call SaveInteger(pOw,lOw,bOw,eOw+1)
set Xb=Xb-1
set pOw=null
endfunction
function Qhw takes integer xhw,integer vhw,string mhw returns nothing
set Cb[Xb]=mhw
set Xb=Xb+1
call SaveInteger(ac,xhw,eb[xhw],vhw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[xhw]==0 then
if xhw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(xhw,vhw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[xhw]=eb[xhw]+1
set Xb=Xb-1
endfunction
function Ahw takes integer Whw,integer Ehw,string Zhw returns nothing
local integer Uhw
local hashtable Ihw
local integer Phw
set Cb[Xb]=Zhw
set Xb=Xb+1
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[Whw]==0 then
if Whw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Uhw=LoadInteger(nc,Whw,Ehw)
set Xb=Xb-1
if Uhw<=0 then
set Ihw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[Whw]==0 then
if Whw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Phw=eb[Whw]
set Xb=Xb-1
call SaveInteger(Ihw,Whw,Ehw,Phw)
call Qhw(Whw,Ehw,"when calling add in HashSet, line 13")
endif
set Xb=Xb-1
set Ihw=null
endfunction
function Khw takes integer Dhw,integer Hhw,string Jhw returns nothing
set Cb[Xb]=Jhw
set Xb=Xb+1
if ZO[Dhw]==0 then
if Dhw==0 then
call q1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call q1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if ZO[Dhw]<=695 then
call Qhw(Dhw,Hhw,"when calling add in HashList, line 25")
else
call Ahw(Dhw,Hhw,"when calling add in HashList, line 25")
endif
set Xb=Xb-1
endfunction
function UOw takes integer QOw,integer WOw,integer EOw,string ZOw returns nothing
set Cb[Xb]=ZOw
set Xb=Xb+1
if not Bnw(QOw,WOw,"when calling has in HashMap, line 18") then
set qb[QOw]=qb[QOw]+1
endif
set Cb[Xb]="when calling saveInt in HashMap, line 20"
set Xb=Xb+1
if AO[QOw]==0 then
if QOw==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,QOw,WOw,EOw)
set Xb=Xb-1-1
endfunction
function NOw takes integer LOw,integer XOw,integer COw,string VOw returns nothing
local boolean BOw
set Cb[Xb]=VOw
set Xb=Xb+1
call UOw(LOw,XOw,COw,"when calling put in HashMap, line 60")
set Cb[Xb]="when calling hasKey in HashMap, line 61"
set Xb=Xb+1
if AO[LOw]==0 then
if LOw==0 then
call q1("Nullpointer exception when calling IterableMap.hasKey","when calling error in HashMap, line 87")
else
call q1("Called IterableMap.hasKey on invalid object.","when calling error in HashMap, line 87")
endif
endif
set Cb[Xb]="when calling hasKey in HashMap, line 87"
set Xb=Xb+1
set BOw=Knw(ab[LOw],XOw,"when calling has in HashMap, line 88")
set Xb=Xb-1-1
if not BOw then
call Khw(ab[LOw],XOw,"when calling add in HashMap, line 62")
endif
set Xb=Xb-1
endfunction
function rdw takes integer Nnw,integer Mnw,integer wdw,string udw returns nothing
set Cb[Xb]=udw
set Xb=Xb+1
if AO[Nnw]==0 then
if Nnw==0 then
call q1("Nullpointer exception when calling HashMap.put","when calling error in HashMap, line 17")
else
call q1("Called HashMap.put on invalid object.","when calling error in HashMap, line 17")
endif
endif
if AO[Nnw]<=732 then
call UOw(Nnw,Mnw,wdw,"when calling put in HashMap, line 17")
else
call NOw(Nnw,Mnw,wdw,"when calling put in HashMap, line 17")
endif
set Xb=Xb-1
endfunction
function vcw takes integer jcw,string xcw returns nothing
set Cb[Xb]=xcw
set Xb=Xb+1
if cb[jcw]!=null then
if cdw(WS,GetHandleId(cb[jcw]),"when calling get in ClosureEvents, line 60")==jcw then
call rdw(WS,GetHandleId(cb[jcw]),tb[jcw],"when calling put in ClosureEvents, line 62")
elseif ib[jcw]!=0 then
set tb[ib[jcw]]=tb[jcw]
endif
elseif cdw(QS,Sb[jcw],"when calling get in ClosureEvents, line 66")==jcw then
call rdw(QS,Sb[jcw],tb[jcw],"when calling put in ClosureEvents, line 68")
elseif ib[jcw]!=0 then
set tb[ib[jcw]]=tb[jcw]
endif
set ib[tb[jcw]]=ib[jcw]
set tb[jcw]=0
set ib[jcw]=0
set Xb=Xb-1
endfunction
function Caw takes integer Law,string Xaw returns nothing
set Cb[Xb]=Xaw
set Xb=Xb+1
if kO[Law]==0 then
if Law==0 then
call q1("Nullpointer exception when calling OnCastListener.OnCastListener","when calling error in ClosureEvents, line 50")
else
call q1("Called OnCastListener.OnCastListener on invalid object.","when calling error in ClosureEvents, line 50")
endif
endif
set Cb[Xb]="when calling destroyOnCastListener in ClosureEvents, line 50"
set Xb=Xb+1
call vcw(Law,"when calling OnCastListener_onDestroy in ClosureEvents, line 58")
set Cb[Xb]="when calling dealloc_OnCastListener in ClosureEvents, line 58"
set Xb=Xb+1
if kO[Law]==0 then
call q1("Double free: object of type OnCastListener","when calling error in ClosureEvents, line 50")
else
set FO=FO+1
set kO[Law]=0
endif
set Xb=Xb-1-1-1
endfunction
function DOw takes integer IOw,integer POw,string AOw returns nothing
set Cb[Xb]=AOw
set Xb=Xb+1
if Bnw(IOw,POw,"when calling has in HashMap, line 28") then
set qb[IOw]=qb[IOw]-1
endif
set Cb[Xb]="when calling removeInt in HashMap, line 30"
set Xb=Xb+1
if AO[IOw]==0 then
if IOw==0 then
call q1("Nullpointer exception when calling Table.removeInt","when calling error in Table, line 24")
else
call q1("Called Table.removeInt on invalid object.","when calling error in Table, line 24")
endif
endif
call RemoveSavedInteger(Wo,IOw,POw)
set Xb=Xb-1-1
endfunction
function TOw takes integer aOw,integer nOw,string dOw returns nothing
local hashtable fOw
local integer ROw
set Cb[Xb]=dOw
set Xb=Xb+1
set fOw=nc
set Cb[Xb]="when calling count in HashList, line 22"
set Xb=Xb+1
if ZO[aOw]==0 then
if aOw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ROw=LoadInteger(nc,aOw,nOw)
set Xb=Xb-1
call SaveInteger(fOw,aOw,nOw,ROw-1)
set Xb=Xb-1
set fOw=null
endfunction
function jOw takes integer YOw,integer GOw,string gOw returns nothing
local integer hOw
local integer FOw
local integer kOw
set Cb[Xb]=gOw
set Xb=Xb+1
set kOw=LoadInteger(ac,YOw,GOw)
set Cb[Xb]="when calling decrOccurences in HashList, line 54"
set Xb=Xb+1
if ZO[YOw]==0 then
if YOw==0 then
call q1("Nullpointer exception when calling HashList.decrOccurences","when calling error in HashList, line 21")
else
call q1("Called HashList.decrOccurences on invalid object.","when calling error in HashList, line 21")
endif
endif
call TOw(YOw,kOw,"when calling decrOccurences in HashList, line 21")
set Xb=Xb-1
set hOw=GOw
set FOw=eb[YOw]
loop
exitwhen hOw>FOw
call SaveInteger(ac,YOw,hOw,LoadInteger(ac,YOw,hOw+1))
set hOw=hOw+1
endloop
set eb[YOw]=eb[YOw]-1
set Xb=Xb-1
endfunction
function alw takes integer tlw,integer ilw,string Slw returns nothing
local integer clw
local integer olw
local hashtable Olw
local integer llw
local integer blw
local hashtable ylw
local integer plw
local hashtable elw
local integer qlw
set Cb[Xb]=Slw
set Xb=Xb+1
set Olw=dc
set Cb[Xb]="when calling get in HashSet, line 22"
set Xb=Xb+1
if ZO[tlw]==0 then
if tlw==0 then
call q1("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call q1("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set llw=LoadInteger(ac,tlw,ilw)
set Xb=Xb-1
call RemoveSavedInteger(Olw,tlw,llw)
set clw=ilw+1
set Cb[Xb]="when calling size in HashSet, line 23"
set Xb=Xb+1
if ZO[tlw]==0 then
if tlw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set blw=eb[tlw]
set Xb=Xb-1
set olw=blw
loop
exitwhen clw>olw
set ylw=dc
set Slw="when calling get in HashSet, line 24"
set Cb[Xb]="when calling get in HashSet, line 24"
set Xb=Xb+1
if ZO[tlw]==0 then
if tlw==0 then
call q1("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call q1("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set plw=LoadInteger(ac,tlw,clw)
set Xb=Xb-1
set elw=dc
set Cb[Xb]="when calling get in HashSet, line 24"
set Xb=Xb+1
if ZO[tlw]==0 then
if tlw==0 then
call q1("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call q1("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set qlw=LoadInteger(ac,tlw,clw)
set Xb=Xb-1
call SaveInteger(ylw,tlw,plw,LoadInteger(elw,tlw,qlw)-1)
set clw=clw+1
endloop
call jOw(tlw,ilw,"when calling removeAt in HashSet, line 25")
set Xb=Xb-1
set Olw=null
set ylw=null
set elw=null
endfunction
function Ylw takes integer nlw,integer dlw,string flw returns nothing
local integer Rlw
local integer Tlw
set Cb[Xb]=flw
set Xb=Xb+1
set Cb[Xb]="when calling count in HashSet, line 17"
set Xb=Xb+1
if ZO[nlw]==0 then
if nlw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Rlw=LoadInteger(nc,nlw,dlw)
set Xb=Xb-1
if Rlw>0 then
set Tlw=LoadInteger(dc,nlw,dlw)
set Cb[Xb]="when calling removeAt in HashSet, line 18"
set Xb=Xb+1
if ZO[nlw]==0 then
if nlw==0 then
call q1("Nullpointer exception when calling HashSet.removeAt","when calling error in HashSet, line 21")
else
call q1("Called HashSet.removeAt on invalid object.","when calling error in HashSet, line 21")
endif
endif
call alw(nlw,Tlw,"when calling removeAt in HashSet, line 21")
set Xb=Xb-1
endif
set Xb=Xb-1
endfunction
function vnw takes integer knw,integer jnw,string xnw returns nothing
set Cb[Xb]=xnw
set Xb=Xb+1
if ZO[knw]==0 then
if knw==0 then
call q1("Nullpointer exception when calling HashList.removeAt","when calling error in HashList, line 53")
else
call q1("Called HashList.removeAt on invalid object.","when calling error in HashList, line 53")
endif
endif
if ZO[knw]<=695 then
call jOw(knw,jnw,"when calling removeAt in HashList, line 53")
else
call alw(knw,jnw,"when calling removeAt in HashList, line 53")
endif
set Xb=Xb-1
endfunction
function Pnw takes integer mnw,integer Qnw,string Wnw returns nothing
local integer Enw
local integer Znw
local integer Unw
local integer Inw
set Cb[Xb]=Wnw
set Xb=Xb+1
if ZO[mnw]==0 then
if mnw==0 then
call q1("Nullpointer exception when calling HashList.remove","when calling error in HashList, line 60")
else
call q1("Called HashList.remove on invalid object.","when calling error in HashList, line 60")
endif
endif
if ZO[mnw]<=695 then
set Enw=mnw
set Znw=Qnw
set Cb[Xb]="when calling remove in HashList, line 60"
set Xb=Xb+1
set Unw=0
set Inw=eb[mnw]-1
loop
exitwhen Unw>Inw
if Znw==LoadInteger(ac,Enw,Unw) then
call vnw(Enw,Unw,"when calling removeAt in HashList, line 63")
exitwhen true
endif
set Unw=Unw+1
endloop
set Xb=Xb-1
else
call Ylw(mnw,Qnw,"when calling remove in HashList, line 60")
endif
set Xb=Xb-1
endfunction
function slw takes integer MOw,integer wlw,string ulw returns nothing
local boolean rlw
set Cb[Xb]=ulw
set Xb=Xb+1
call DOw(MOw,wlw,"when calling remove in HashMap, line 66")
set Cb[Xb]="when calling hasKey in HashMap, line 67"
set Xb=Xb+1
if AO[MOw]==0 then
if MOw==0 then
call q1("Nullpointer exception when calling IterableMap.hasKey","when calling error in HashMap, line 87")
else
call q1("Called IterableMap.hasKey on invalid object.","when calling error in HashMap, line 87")
endif
endif
set Cb[Xb]="when calling hasKey in HashMap, line 87"
set Xb=Xb+1
set rlw=Knw(ab[MOw],wlw,"when calling has in HashMap, line 88")
set Xb=Xb-1-1
if rlw then
call Pnw(ab[MOw],wlw,"when calling remove in HashMap, line 68")
endif
set Xb=Xb-1
endfunction
function bdw takes integer odw,integer Odw,string ldw returns nothing
set Cb[Xb]=ldw
set Xb=Xb+1
if AO[odw]==0 then
if odw==0 then
call q1("Nullpointer exception when calling HashMap.remove","when calling error in HashMap, line 27")
else
call q1("Called HashMap.remove on invalid object.","when calling error in HashMap, line 27")
endif
endif
if AO[odw]<=732 then
call DOw(odw,Odw,"when calling remove in HashMap, line 27")
else
call slw(odw,Odw,"when calling remove in HashMap, line 27")
endif
set Xb=Xb-1
endfunction
function kcw takes integer gcw,string hcw returns nothing
local integer Fcw
set Cb[Xb]=hcw
set Xb=Xb+1
set Fcw=ES[ub[gcw]]
if Fcw==gcw then
set ES[ub[gcw]]=rb[gcw]
elseif sb[gcw]!=0 then
set rb[sb[gcw]]=rb[gcw]
endif
set sb[rb[gcw]]=sb[gcw]
set Fcw=ZS[ub[gcw]]
if Fcw==gcw then
set ZS[ub[gcw]]=rb[gcw]
elseif sb[gcw]!=0 then
set rb[sb[gcw]]=rb[gcw]
endif
set sb[rb[gcw]]=sb[gcw]
set rb[gcw]=0
set sb[gcw]=0
set Cb[Xb]="when calling dealloc_EventListener in ClosureEvents, line 202"
set Xb=Xb+1
if SO[gcw]==0 then
call q1("Double free: object of type EventListener","when calling error in ClosureEvents, line 98")
else
set sO[tO]=gcw
set tO=tO+1
set SO[gcw]=0
endif
set Xb=Xb-1-1
endfunction
function jV takes integer gV,string hV returns nothing
local integer FV
local integer kV
set Cb[Xb]=hV
set Xb=Xb+1
if gV>0 then
if ZS[gV]!=0 then
set FV=ZS[gV]
set ZS[gV]=0
loop
exitwhen FV==0
set kV=FV
set FV=rb[FV]
set Cb[Xb]="when calling dispatch_EventListener_destroyEventListener in ClosureEvents, line 282"
set Xb=Xb+1
if SO[kV]==0 then
if kV==0 then
call q1("Nullpointer exception when calling EventListener.EventListener","when calling error in ClosureEvents, line 98")
else
call q1("Called EventListener.EventListener on invalid object.","when calling error in ClosureEvents, line 98")
endif
endif
call kcw(kV,"when calling destroyEventListener in ClosureEvents, line 98")
set Xb=Xb-1
endloop
endif
endif
set Xb=Xb-1
endfunction
function GV takes unit nV,string dV returns nothing
local integer fV
local integer RV
local integer TV
local integer YV
set Cb[Xb]=dV
set Xb=Xb+1
call jV(GetUnitUserData(nV),"when calling unregisterEvents in ClosureEvents, line 258")
if Bnw(WS,GetHandleId(nV),"when calling has in ClosureEvents, line 259") then
set fV=cdw(WS,GetHandleId(nV),"when calling get in ClosureEvents, line 260")
call bdw(WS,GetHandleId(nV),"when calling remove in ClosureEvents, line 261")
loop
exitwhen fV==0
set RV=fV
set fV=tb[fV]
call Caw(RV,"when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 265")
endloop
endif
if Bnw(WS,GetHandleId(nV),"when calling has in ClosureEvents, line 266") then
set TV=cdw(WS,GetHandleId(nV),"when calling get in ClosureEvents, line 267")
loop
exitwhen TV==0
set YV=TV
set TV=tb[TV]
call Caw(YV,"when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 271")
endloop
endif
set Xb=Xb-1
endfunction
function DFw takes nothing returns nothing
set Xb=0
set Cb[Xb]="ClosureEvents, line 288"
set Xb=Xb+1
call GV(Do[Ho-1],"when calling unregisterEventsForUnit in ClosureEvents, line 288")
set Xb=Xb-1
endfunction
function AJ takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747990351 then
return false
endif
return true
endfunction
function DJ takes nothing returns boolean
if not AJ() then
return false
endif
return true
endfunction
function DT takes nothing returns nothing
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_097","TRIGSTR_098","ReplaceableTextures\\CommandButtons\\BTNSteelMelee.blp")
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_103","TRIGSTR_104","ReplaceableTextures\\WorldEditUI\\Doodad-Cinematic.blp")
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_2667","TRIGSTR_2668","ReplaceableTextures\\WorldEditUI\\Editor-MultipleUnits.blp")
endfunction
function AY takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1966092336 then
return false
endif
if GetSpellAbilityId()!=1093677906 then
return false
endif
if GetOwningPlayer(GetSpellTargetUnit())==Player(PLAYER_NEUTRAL_AGGRESSIVE) then
return false
endif
if IsUnitType(GetSpellTargetUnit(),UNIT_TYPE_STRUCTURE)!=true then
return false
endif
return true
endfunction
function DY takes nothing returns boolean
if not AY() then
return false
endif
return true
endfunction
function Am takes nothing returns boolean
if GetResearched()!=1378889798 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889798,true)!=1 then
return false
endif
return true
endfunction
function Dm takes nothing returns boolean
if not Am() then
return false
endif
return true
endfunction
function Px takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747990581 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990580 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989813 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747988569 then
return true
endif
return false
endfunction
function Ax takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989049 then
return false
endif
if not Px() then
return false
endif
return true
endfunction
function Dx takes nothing returns boolean
if not Ax() then
return false
endif
return true
endfunction
function E2 takes nothing returns boolean
return true
endfunction
function E9 takes nothing returns boolean
local integer Q9
local integer W9
set uo=GetLocalPlayer()
set Q9=0
set W9=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen Q9>W9
set wo[Q9]=Player(Q9)
set Q9=Q9+1
endloop
return true
endfunction
function EA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990604,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990602,0)
endfunction
function ED takes nothing returns nothing
local player mD=GetOwningPlayer(GetTriggerUnit())
local boolexpr QD=Condition(Ea)
local group WD=CreateGroup()
local code xD
local boolean vD
call GroupEnumUnitsOfPlayer(WD,mD,QD)
call DestroyBoolExpr(QD)
set xD=Za
set vD=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(WD,xD)
if vD then
call DestroyGroup(WD)
endif
set mD=null
set QD=null
set WD=null
endfunction
function g0w takes playerunitevent q0w,code a0w,code n0w,code d0w returns nothing
local integer f0w=GetHandleId(q0w)
local integer R0w
local filterfunc T0w
local trigger Y0w
local player G0w
if yo[f0w]==null then
set yo[f0w]=CreateTrigger()
set R0w=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen R0w<0
set Y0w=yo[f0w]
set G0w=wo[R0w]
if a0w!=null then
set T0w=Filter(a0w)
else
set T0w=null
endif
call TriggerRegisterPlayerUnitEvent(Y0w,G0w,q0w,T0w)
set R0w=R0w-1
endloop
endif
if n0w!=null then
call TriggerAddCondition(yo[f0w],Filter(n0w))
endif
if d0w!=null then
call TriggerAddAction(yo[f0w],d0w)
endif
set T0w=null
set Y0w=null
set G0w=null
endfunction
function aV takes eventid tV,string iV returns integer
local integer SV
local integer cV
local integer oV
local trigger OV
local integer lV
local integer bV
local integer yV
local integer pV
local boolean eV
local boolean qV
set Cb[Xb]=iV
set Xb=Xb+1
set SV=GetHandleId(tV)
set mS=mS+1
set vS[SV]=mS
set lV=GetHandleId(tV)
if (lV>=18 and lV<=51)or(lV>=269 and lV<=277) then
call g0w(ConvertPlayerUnitEvent(SV),null,Ef,null)
else
if tV!=EVENT_UNIT_DAMAGED and tV!=EVENT_PLAYER_LEAVE and tV!=FS then
set bV=GetHandleId(tV)
set eV=bV<261 or bV>268 and bV!=17
else
set eV=false
endif
if eV then
set yV=GetHandleId(tV)
set qV=yV<305 or yV>307
else
set qV=false
endif
if qV then
call q1("registering handleid: "+I2S(SV)+" non-playerunitevent. Except EVENT_UNIT_DAMAGED and EVENT_PLAYER_LEAVE these are not supported right now.","when calling error in ClosureEvents, line 243")
endif
endif
set pV=GetHandleId(tV)
if pV>=305 and pV<=307 and(not US) then
set US=true
set cV=0
set oV=bj_MAX_PLAYERS-1
loop
exitwhen cV>oV
set OV=xS
call TriggerRegisterPlayerEvent(OV,wo[cV],EVENT_PLAYER_MOUSE_UP)
call TriggerRegisterPlayerEvent(OV,wo[cV],EVENT_PLAYER_MOUSE_DOWN)
call TriggerRegisterPlayerEvent(OV,wo[cV],EVENT_PLAYER_MOUSE_MOVE)
set cV=cV+1
endloop
endif
set Xb=Xb-1
set OV=null
return mS
endfunction
function m9 takes string T9 returns boolean
local playerunitevent Y9
local playerunitevent G9
local playerunitevent g9
local integer h9
local integer F9
local integer k9
local integer j9
local integer x9
local integer v9
set Cb[Xb]=T9
set Xb=Xb+1
set Y9=EVENT_PLAYER_UNIT_DEATH
set Cb[Xb]="when calling alloc_OreCapture_EventListener_line9 in OreCapture, line 9"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set h9=iO
set SO[h9]=680
else
call q1("Out of memory: Could not create OreCapture_EventListener_line9.","when calling error in OreCapture, line 9")
set h9=0
endif
else
set tO=tO-1
set h9=sO[tO]
set SO[h9]=680
endif
set Xb=Xb-1
set ub[h9]=0
set rb[h9]=0
set sb[h9]=0
set Cb[Xb]="when calling add in OreCapture, line 9"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set F9=vS[GetHandleId(Y9)]
if F9==0 then
set F9=aV(Y9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[h9]=F9
if ES[ub[h9]]!=0 then
set sb[ES[ub[h9]]]=h9
set rb[h9]=ES[ub[h9]]
endif
set ES[ub[h9]]=h9
set Xb=Xb-1
set G9=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set Cb[Xb]="when calling alloc_OreCapture_EventListener_line14 in OreCapture, line 14"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set k9=iO
set SO[k9]=678
else
call q1("Out of memory: Could not create OreCapture_EventListener_line14.","when calling error in OreCapture, line 14")
set k9=0
endif
else
set tO=tO-1
set k9=sO[tO]
set SO[k9]=678
endif
set Xb=Xb-1
set ub[k9]=0
set rb[k9]=0
set sb[k9]=0
set Cb[Xb]="when calling add in OreCapture, line 14"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set j9=vS[GetHandleId(G9)]
if j9==0 then
set j9=aV(G9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[k9]=j9
if ES[ub[k9]]!=0 then
set sb[ES[ub[k9]]]=k9
set rb[k9]=ES[ub[k9]]
endif
set ES[ub[k9]]=k9
set Xb=Xb-1
set g9=EVENT_PLAYER_UNIT_ATTACKED
set Cb[Xb]="when calling alloc_OreCapture_EventListener_line21 in OreCapture, line 21"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set x9=iO
set SO[x9]=679
else
call q1("Out of memory: Could not create OreCapture_EventListener_line21.","when calling error in OreCapture, line 21")
set x9=0
endif
else
set tO=tO-1
set x9=sO[tO]
set SO[x9]=679
endif
set Xb=Xb-1
set ub[x9]=0
set rb[x9]=0
set sb[x9]=0
set Cb[Xb]="when calling add in OreCapture, line 21"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set v9=vS[GetHandleId(g9)]
if v9==0 then
set v9=aV(g9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[x9]=v9
if ES[ub[x9]]!=0 then
set sb[ES[ub[x9]]]=x9
set rb[x9]=ES[ub[x9]]
endif
set ES[ub[x9]]=x9
set Xb=Xb-1-1
set Y9=null
set G9=null
set g9=null
return true
endfunction
function EFw takes nothing returns boolean
set Xb=0
return m9("OreCapture, line 1")
endfunction
function WI takes nothing returns boolean
if GetResearched()!=1378890032 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890032,true)!=1 then
return false
endif
return true
endfunction
function EI takes nothing returns boolean
if not WI() then
return false
endif
return true
endfunction
function EJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function EY takes nothing returns nothing
local player xY=GetOwningPlayer(GetAttacker())
local player vY=GetOwningPlayer(GetAttacker())
local player mY
local player QY
local unit WY
set r[GetPlayerId(xY)+1]=r[GetPlayerId(vY)+1]+1
set mY=GetOwningPlayer(GetTriggerUnit())
set QY=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(mY)+1]=r[GetPlayerId(QY)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set WY=GetTriggerUnit()
call SetUnitState(WY,UNIT_STATE_LIFE,GetUnitState(WY,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set xY=null
set vY=null
set mY=null
set QY=null
set WY=null
endfunction
function Em takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988558,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989057,0)
endfunction
function Eww takes nothing returns boolean
set Po=CreateTrigger()
set Ao=CreateTrigger()
call TriggerAddCondition(Cc,Filter(Lf))
call TriggerAddAction(Cc,Xf)
return true
endfunction
function F1 takes nothing returns boolean
set ac=InitHashtable()
set nc=InitHashtable()
return true
endfunction
function F8 takes nothing returns boolean
return true
endfunction
function hA takes nothing returns boolean
if GetResearched()!=1378890040 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890040,true)!=2 then
return false
endif
return true
endfunction
function FA takes nothing returns boolean
if not hA() then
return false
endif
return true
endfunction
function FD takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
return true
endfunction
function FF takes nothing returns nothing
local group GF
local code gF
local boolean hF
set b=GetUnitsOfTypeIdAll(1747989301)
set GF=b
set gF=qp
set hF=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(GF,gF)
if hF then
call DestroyGroup(GF)
endif
call DestroyGroup(b)
set GF=null
endfunction
function P1 takes string m1 returns boolean
local playerunitevent Q1
local playerunitevent W1
local integer E1
local integer Z1
local integer U1
local integer I1
set Cb[Xb]=m1
set Xb=Xb+1
set Q1=EVENT_PLAYER_UNIT_DEATH
set Cb[Xb]="when calling alloc_LimitEncampments_EventListener_line8 in LimitEncampments, line 8"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set E1=iO
set SO[E1]=670
else
call q1("Out of memory: Could not create LimitEncampments_EventListener_line8.","when calling error in LimitEncampments, line 8")
set E1=0
endif
else
set tO=tO-1
set E1=sO[tO]
set SO[E1]=670
endif
set Xb=Xb-1
set ub[E1]=0
set rb[E1]=0
set sb[E1]=0
set Cb[Xb]="when calling add in LimitEncampments, line 8"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set Z1=vS[GetHandleId(Q1)]
if Z1==0 then
set Z1=aV(Q1,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[E1]=Z1
if ES[ub[E1]]!=0 then
set sb[ES[ub[E1]]]=E1
set rb[E1]=ES[ub[E1]]
endif
set ES[ub[E1]]=E1
set Xb=Xb-1
set W1=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Cb[Xb]="when calling alloc_LimitEncampments_EventListener_line12 in LimitEncampments, line 12"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set U1=iO
set SO[U1]=669
else
call q1("Out of memory: Could not create LimitEncampments_EventListener_line12.","when calling error in LimitEncampments, line 12")
set U1=0
endif
else
set tO=tO-1
set U1=sO[tO]
set SO[U1]=669
endif
set Xb=Xb-1
set ub[U1]=0
set rb[U1]=0
set sb[U1]=0
set Cb[Xb]="when calling add in LimitEncampments, line 12"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set I1=vS[GetHandleId(W1)]
if I1==0 then
set I1=aV(W1,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[U1]=I1
if ES[ub[U1]]!=0 then
set sb[ES[ub[U1]]]=U1
set rb[U1]=ES[ub[U1]]
endif
set ES[ub[U1]]=U1
set Xb=Xb-1-1
set Q1=null
set W1=null
return true
endfunction
function FFw takes nothing returns boolean
set Xb=0
return P1("LimitEncampments, line 1")
endfunction
function hJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990354 then
return false
endif
return true
endfunction
function FJ takes nothing returns boolean
if not hJ() then
return false
endif
return true
endfunction
function hm takes nothing returns boolean
if GetResearched()!=1378889796 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889796,true)!=1 then
return false
endif
return true
endfunction
function Fm takes nothing returns boolean
if not hm() then
return false
endif
return true
endfunction
function GD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990584,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990594,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990583,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990607,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990598,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990606,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990599,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990601,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651855,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651852,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651850,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990595,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990596,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990604,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990603,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990322,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990323,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990321,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990324,0)
endfunction
function YE takes nothing returns boolean
if GetResearched()!=1378889807 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889807,true)!=1 then
return false
endif
return true
endfunction
function GE takes nothing returns boolean
if not YE() then
return false
endif
return true
endfunction
function anw takes integer ynw,timer pnw,real enw,string qnw returns nothing
set Cb[Xb]=qnw
set Xb=Xb+1
if hO[ynw]==0 then
if ynw==0 then
call q1("Nullpointer exception when calling CallbackPeriodic.start","when calling error in ClosureTimers, line 132")
else
call q1("Called CallbackPeriodic.start on invalid object.","when calling error in ClosureTimers, line 132")
endif
endif
set Cb[Xb]="when calling start in ClosureTimers, line 132"
set Xb=Xb+1
call Iww(pnw,ynw,"when calling setData in ClosureTimers, line 134")
call TimerStart(pnw,enw,true,tR)
set Xb=Xb-1-1
endfunction
function H3 takes string E3 returns boolean
local integer Z3
local integer U3
local integer I3
local timer P3
local integer A3
local timer D3
set Cb[Xb]=E3
set Xb=Xb+1
set Z3=0
set U3=23
loop
exitwhen Z3>U3
set rc[Z3]=0
set Z3=Z3+1
endloop
set Cb[Xb]="when calling alloc_Economy_CallbackPeriodic_line47 in Economy, line 47"
set Xb=Xb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set I3=gO
set hO[I3]=635
else
call q1("Out of memory: Could not create Economy_CallbackPeriodic_line47.","when calling error in Economy, line 47")
set I3=0
endif
else
set GO=GO-1
set I3=YO[GO]
set hO[I3]=635
endif
set Xb=Xb-1
set Cb[Xb]="when calling doPeriodically in Economy, line 47"
set Xb=Xb+1
set P3=Cww("when calling getTimer in ClosureTimers, line 57")
set Cb[Xb]="when calling doPeriodically in ClosureTimers, line 57"
set Xb=Xb+1
call anw(I3,P3,0.333333343,"when calling start in ClosureTimers, line 45")
set Xb=Xb-1-1
set Cb[Xb]="when calling alloc_Economy_CallbackPeriodic_line54 in Economy, line 54"
set Xb=Xb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set A3=gO
set hO[A3]=636
else
call q1("Out of memory: Could not create Economy_CallbackPeriodic_line54.","when calling error in Economy, line 54")
set A3=0
endif
else
set GO=GO-1
set A3=YO[GO]
set hO[A3]=636
endif
set Xb=Xb-1
set Cb[Xb]="when calling doPeriodically in Economy, line 54"
set Xb=Xb+1
set D3=Cww("when calling getTimer in ClosureTimers, line 57")
set Cb[Xb]="when calling doPeriodically in ClosureTimers, line 57"
set Xb=Xb+1
call anw(A3,D3,10.0,"when calling start in ClosureTimers, line 45")
set Xb=Xb-1-1-1
set P3=null
set D3=null
return true
endfunction
function GFw takes nothing returns boolean
set Xb=0
return H3("Economy, line 1")
endfunction
function GL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function GU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651848,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651846,0)
endfunction
function GW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651828,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651827,0)
endfunction
function Gww takes nothing returns boolean
set ao[0]="Terrible! Terrible news, my lord!"
set ao[1]="The messenger came to us with horrific news! May we execute him?"
set ao[2]="A mere nightmare, Your Mightiness!"
set no[0]="Holy Mother of God, we have horrific news!"
set no[1]="Lord Preserve us, Great Prince!"
set no[2]="Great Prince, we have horrific news!"
set do[0]="Allah be merciful! I bring terrible news"
set do[1]="Oh, Great Sultan! We have terrible news"
set do[2]="Oh, Great one! I bring ill news"
set fo[0]="Saints save us, we have some most horrific news!"
set fo[1]="My Basileus! We have horrific news!"
set fo[2]="My Basileus, by the grace of our lord. We have horrific news!"
set Ro[0]="My King, we have received news concerning our realm"
set Ro[1]="The messenger arrived with news. No matter, could I execute him?"
set Ro[2]="My liege I bring news about the realm"
set To[0]="Great Prince, a messenger came with news"
set To[1]="May the God bless you, Great Prince, we have some news"
set To[2]="There is something you should know, Great Prince"
set Yo[0]="My Sultan! We have news"
set Yo[1]="Praise be to Allah, Sultan! We bring news"
set Yo[2]="Great Sultan! We have some news"
set Go[0]="My Basileus, we have some news"
set Go[1]="My Basileus, we have some news"
set Go[2]="My Basileus, we have some news"
set go[0]="Milord! Good news!"
set go[1]="Praise the Holy Lord! We have good news"
set go[2]="My King, we bring great news for you!"
set ho[0]="By the grace of our Lord, we bring good news!"
set ho[1]="We received great news my Lord! Still the Messenger deserves to be pusnished"
set ho[2]="My Lord, we have received delightful news!"
set Fo[0]="Praise be to Allah, Sultan! We have great news"
set Fo[1]="Good tidings Sultan! I bring good news"
set Fo[2]="Allah is glorious, Sultan! We have great news"
set ko[0]="Good news, my Basileus!"
set ko[1]="Praise the Holy Lord, we bring great news, my Basileus!"
set ko[2]="We received good news my Basileus! We shouldn’t blind this messenger"
set jo[0]="Your Majesty, important news!"
set jo[1]="May the God bless you, my lord. There is something you must know!"
set jo[2]="There is something that needs your attention, my lord!"
set xo[0]="By the Saints! Great Prince, you must hear to this"
set xo[1]="You should hear this, Great Prince!"
set xo[2]="You need to see this, Great Prince!"
set vo[0]="Great one, urgent news must be brought to your attention!"
set vo[1]="My Sultan, there is something you need to know!"
set vo[2]="My Great Sultan, there is something you must know!"
set mo[0]="My Basileus, there is something you need to know!"
set mo[1]="My Basileus, we can not delay this news!"
set mo[2]="My Basileus, you should be aware of this!"
set Qo[0]="|cffffd900Med."
set Qo[1]="|cff00ff00Low"
set Qo[2]="|cffff0000High"
set Qo[3]="|cff940000Harsh"
return true
endfunction
function HA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990603,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990604,0)
endfunction
function Itw takes integer Wtw,integer Etw,string Ztw returns nothing
local player Utw
set Cb[Xb]=Ztw
set Xb=Xb+1
if Fc-Kl[Wtw]>=dS then
set Kl[Wtw]=Fc
set Dl[Wtw]=Dl[Wtw]-YS[Jl[Wtw]]
set Dl[Wtw]=Dl[Wtw]+YS[Etw]
set Jl[Wtw]=Etw
else
set Utw=wo[Wl[Wtw]]
set Cb[Xb]="when calling noteToPlayer in City, line 271"
set Xb=Xb+1
call DisplayTimedTextToPlayer(Utw,0.,0.,10.0,N2(Utw,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(Utw,0.,0.,10.0,"Wait 1 turn to be able to change tax level.")
set Xb=Xb-1
endif
set Xb=Xb-1
set Utw=null
endfunction
function Eqw takes integer hqw,string Fqw returns nothing
local integer kqw
local integer jqw
local integer xqw
local integer vqw
local boolean mqw
local unit Qqw
local boolean Wqw
set Cb[Xb]=Fqw
set Xb=Xb+1
set xqw=sS
set vqw=GetSpellAbilityId()
set Cb[Xb]="when calling has in Taxation, line 7"
set Xb=Xb+1
if Sl[xqw]==0 then
if xqw==0 then
call q1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call q1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set mqw=nbw(xqw,vqw)
set Xb=Xb-1
if mqw then
set Qqw=GetSpellTargetUnit()
set Cb[Xb]="when calling isCity in Taxation, line 8"
set Xb=Xb+1
set Wqw=Knw(Bo,GetUnitTypeId(Qqw),"when calling has in City, line 437")
set Xb=Xb-1
if Wqw then
if GetOwningPlayer(GetSpellTargetUnit())==GetOwningPlayer(GetSpellAbilityUnit()) then
set kqw=0
set jqw=GetSpellAbilityId()
if jqw==1093677642 then
set kqw=1
elseif jqw==1093677641 then
set kqw=0
elseif jqw==1093677640 then
set kqw=2
elseif jqw==1093678155 then
set kqw=3
endif
set hqw=hS[CC(GetSpellTargetUnit(),"when calling getCityId in Taxation, line 20")]
set Cb[Xb]="when calling changeTaxLevel in Taxation, line 20"
set Xb=Xb+1
if pO[hqw]==0 then
if hqw==0 then
call q1("Nullpointer exception when calling City.changeTaxLevel","when calling error in City, line 262")
else
call q1("Called City.changeTaxLevel on invalid object.","when calling error in City, line 262")
endif
endif
call Itw(hqw,kqw,"when calling changeTaxLevel in City, line 262")
set Xb=Xb-1
endif
endif
endif
set Xb=Xb-1
set Qqw=null
endfunction
function Ilw takes integer mlw,string Qlw returns nothing
local unit Wlw
local player Elw
local player Zlw
local player Ulw
set Cb[Xb]=Qlw
set Xb=Xb+1
set Wlw=GetConstructingStructure()
if GetUnitTypeId(Wlw)==1747988808 then
if fc[GetPlayerId(GetOwningPlayer(Wlw))]<3 then
set Elw=GetOwningPlayer(Wlw)
set Zlw=GetOwningPlayer(Wlw)
set fc[GetPlayerId(Elw)]=fc[GetPlayerId(Zlw)]+1
else
set Ulw=GetOwningPlayer(Wlw)
set Cb[Xb]="when calling attentionToPlayer in LimitEncampments, line 18"
set Xb=Xb+1
call DisplayTimedTextToPlayer(Ulw,0.,0.,10.0,l5(Ulw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Ulw,0.,0.,10.0,"You cannot build more than 3 encampments.")
set Xb=Xb-1
set Cb[Xb]="when calling alloc_LimitEncampments_CallbackSingle_line19 in LimitEncampments, line 19"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set mlw=RO
set TO[mlw]=645
else
call q1("Out of memory: Could not create LimitEncampments_CallbackSingle_line19.","when calling error in LimitEncampments, line 19")
set mlw=0
endif
else
set fO=fO-1
set mlw=dO[fO]
set TO[mlw]=645
endif
set Xb=Xb-1
set nb[mlw]=Wlw
call yB(0.01,mlw,"when calling doAfter in LimitEncampments, line 19")
endif
endif
set Xb=Xb-1
set Wlw=null
set Elw=null
set Zlw=null
set Ulw=null
endfunction
function Jlw takes integer Plw returns nothing
local unit Alw=GetTriggerUnit()
local player Dlw
local player Hlw
if GetUnitTypeId(Alw)==1747990614 then
set Dlw=GetOwningPlayer(Alw)
set Hlw=GetOwningPlayer(Alw)
set Rc[GetPlayerId(Dlw)]=Rc[GetPlayerId(Hlw)]-1
endif
set Alw=null
set Dlw=null
set Hlw=null
endfunction
function e0w takes rect o0w,real O0w,real l0w returns boolean
local boolean b0w
local boolean y0w
local boolean p0w
if O0w>GetRectMinX(o0w) then
set b0w=O0w<GetRectMaxX(o0w)
else
set b0w=false
endif
if b0w then
set y0w=l0w>GetRectMinY(o0w)
else
set y0w=false
endif
if y0w then
set p0w=l0w<GetRectMaxY(o0w)
else
set p0w=false
endif
return p0w
endfunction
function mww takes integer hww,string Fww returns rect
local integer kww
local fogstate jww
local integer xww
local rect vww
set Cb[Xb]=Fww
set Xb=Xb+1
set kww=Io
set jww=ConvertFogState(hww)
set Cb[Xb]="when calling saveFogState in TypeCasting, line 136"
set Xb=Xb+1
if AO[kww]==0 then
if kww==0 then
call q1("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call q1("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call SaveFogStateHandle(Wo,kww,0,jww)
set Xb=Xb-1
set xww=Io
set Cb[Xb]="when calling loadRect in TypeCasting, line 137"
set Xb=Xb+1
if AO[xww]==0 then
if xww==0 then
call q1("Nullpointer exception when calling Table.loadRect","when calling error in Table, line 147")
else
call q1("Called Table.loadRect on invalid object.","when calling error in Table, line 147")
endif
endif
set vww=LoadRectHandle(Wo,xww,0)
set Xb=Xb-1-1
set bR=vww
set jww=null
set vww=null
return bR
endfunction
function Lyw takes integer Zyw,string Uyw returns nothing
local unit Iyw
local real Pyw
local real Ayw
local integer Dyw
local integer Hyw
local integer Jyw
local player Kyw
set Cb[Xb]=Uyw
set Xb=Xb+1
set Iyw=GetTriggerUnit()
if GetUnitTypeId(Iyw)==1747988569 then
set Pyw=GetUnitX(Iyw)
set Ayw=GetUnitY(Iyw)
set Hyw=Mo
set Cb[Xb]="when calling iterator in NoShipsNearRivers, line 11"
set Xb=Xb+1
set Jyw=obw(Hyw,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set Dyw=Jyw
loop
exitwhen Yb[gb[Dyw]]==Gb[Dyw]
set gb[Dyw]=Yb[gb[Dyw]]
if e0w(mww(Rb[gb[Dyw]],"when calling rectFromIndex in NoShipsNearRivers, line 11"),Pyw,Ayw) then
set Uyw="when calling alloc_NoShipsNearRivers_CallbackSingle_line14 in NoShipsNearRivers, line 14"
set Cb[Xb]="when calling alloc_NoShipsNearRivers_CallbackSingle_line14 in NoShipsNearRivers, line 14"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set Zyw=RO
set TO[Zyw]=649
else
call q1("Out of memory: Could not create NoShipsNearRivers_CallbackSingle_line14.","when calling error in NoShipsNearRivers, line 14")
set Zyw=0
endif
else
set fO=fO-1
set Zyw=dO[fO]
set TO[Zyw]=649
endif
set Xb=Xb-1
set Ub[Zyw]=Iyw
call yB(0.01,Zyw,"when calling doAfter in NoShipsNearRivers, line 14")
set Kyw=GetOwningPlayer(Iyw)
set Cb[Xb]="when calling attentionToPlayer in NoShipsNearRivers, line 16"
set Xb=Xb+1
call DisplayTimedTextToPlayer(Kyw,0.,0.,10.0,l5(Kyw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Kyw,0.,0.,10.0,"You cannot build shipyards near rivers")
set Xb=Xb-1
endif
endloop
set Cb[Xb]="when calling close in NoShipsNearRivers, line 11"
set Xb=Xb+1
if Fb[Dyw]then
call Rdw(Dyw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1
endif
set Xb=Xb-1
set Iyw=null
set Kyw=null
endfunction
function Nlw takes integer Klw,string Llw returns nothing
local unit Xlw
local player Clw
local player Vlw
local player Blw
set Cb[Xb]=Llw
set Xb=Xb+1
set Xlw=GetConstructingStructure()
if GetUnitTypeId(Xlw)==1747990614 then
if Rc[GetPlayerId(GetOwningPlayer(Xlw))]<3 then
set Clw=GetOwningPlayer(Xlw)
set Vlw=GetOwningPlayer(Xlw)
set Rc[GetPlayerId(Clw)]=Rc[GetPlayerId(Vlw)]+1
else
set Blw=GetOwningPlayer(Xlw)
set Cb[Xb]="when calling attentionToPlayer in LimitMercenaryCamps, line 18"
set Xb=Xb+1
call DisplayTimedTextToPlayer(Blw,0.,0.,10.0,l5(Blw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Blw,0.,0.,10.0,"You cannot build more than 3 mercenary camps.")
set Xb=Xb-1
set Cb[Xb]="when calling alloc_LimitMercenaryCamps_CallbackSingle_line19 in LimitMercenaryCamps, line 19"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set Klw=RO
set TO[Klw]=646
else
call q1("Out of memory: Could not create LimitMercenaryCamps_CallbackSingle_line19.","when calling error in LimitMercenaryCamps, line 19")
set Klw=0
endif
else
set fO=fO-1
set Klw=dO[fO]
set TO[Klw]=646
endif
set Xb=Xb-1
set db[Klw]=Xlw
call yB(0.01,Klw,"when calling doAfter in LimitMercenaryCamps, line 19")
endif
endif
set Xb=Xb-1
set Xlw=null
set Clw=null
set Vlw=null
set Blw=null
endfunction
function OOw takes integer uOw,string rOw returns nothing
local unit sOw
local boolean tOw
local player iOw
local boolean SOw
local boolean cOw
local boolean oOw
set Cb[Xb]=rOw
set Xb=Xb+1
set sOw=GetTriggerUnit()
set Cb[Xb]="when calling isCity in Garissons, line 9"
set Xb=Xb+1
set Cb[Xb]="when calling isCity in UnitTools, line 5"
set Xb=Xb+1
set tOw=Knw(Bo,GetUnitTypeId(sOw),"when calling has in City, line 437")
set Xb=Xb-1-1
if tOw then
set SOw=true
else
set SOw=Knw(Vo,GetUnitTypeId(sOw),"when calling has in Garissons, line 9")
endif
if SOw then
set iOw=GetOwningPlayer(sOw)
if GetPlayerSlotState(iOw)==PLAYER_SLOT_STATE_PLAYING then
set cOw=GetPlayerController(iOw)==MAP_CONTROL_USER
else
set cOw=false
endif
set oOw=not cOw
else
set oOw=false
endif
if oOw then
call IssueImmediateOrder(sOw,"spiritwolf")
endif
set Xb=Xb-1
set sOw=null
set iOw=null
endfunction
function Saw takes integer Lqw,string Xqw returns nothing
local unit Cqw
local unit Vqw
local integer Bqw
local player Nqw
local integer Mqw
local integer waw
local player uaw
local integer raw
local integer saw
local boolean taw
local boolean iaw
set Cb[Xb]=Xqw
set Xb=Xb+1
if GetSpellAbilityId()==1093677620 then
set Cqw=GetSpellAbilityUnit()
set Vqw=GetSpellTargetUnit()
set Bqw=GetPlayerId(GetOwningPlayer(Cqw))
set Lqw=GetPlayerId(GetOwningPlayer(Vqw))
set Nqw=wo[Bqw]
if GetPlayerSlotState(Nqw)==PLAYER_SLOT_STATE_PLAYING then
set taw=GetPlayerController(Nqw)==MAP_CONTROL_USER
else
set taw=false
endif
if taw then
set Mqw=Mc[Bqw]
set waw=-GetUnitLevel(Vqw)
set Cb[Xb]="when calling changeUpkeep in Upkeep, line 15"
set Xb=Xb+1
if yl[Mqw]==0 then
if Mqw==0 then
call q1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call q1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Hb[Mqw]=Hb[Mqw]+waw
set Xb=Xb-1
endif
set uaw=wo[Lqw]
if GetPlayerSlotState(uaw)==PLAYER_SLOT_STATE_PLAYING then
set iaw=GetPlayerController(uaw)==MAP_CONTROL_USER
else
set iaw=false
endif
if iaw then
set raw=Mc[Lqw]
set saw=GetUnitLevel(Vqw)
set Cb[Xb]="when calling changeUpkeep in Upkeep, line 17"
set Xb=Xb+1
if yl[raw]==0 then
if raw==0 then
call q1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call q1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Hb[raw]=Hb[raw]+saw
set Xb=Xb-1
endif
endif
set Xb=Xb-1
set Cqw=null
set Vqw=null
set Nqw=null
set uaw=null
endfunction
function Spw takes integer spw,string tpw returns nothing
local force ipw
set Cb[Xb]=tpw
set Xb=Xb+1
set tpw=hB(GetTriggerPlayer())+" has left the game!"
set ipw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),ipw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,5.0,tpw)
endif
set spw=Mc[GetPlayerId(GetTriggerPlayer())]
set Cb[Xb]="when calling setInGame in OnPlayerLeave, line 7"
set Xb=Xb+1
if yl[spw]==0 then
if spw==0 then
call q1("Nullpointer exception when calling PlayerStats.setInGame","when calling error in PlayerStats, line 45")
else
call q1("Called PlayerStats.setInGame on invalid object.","when calling error in PlayerStats, line 45")
endif
endif
set Ab[spw]=false
set Xb=Xb-1
call SetPlayerName(GetTriggerPlayer(),GetPlayerName(GetTriggerPlayer())+" [LEFT]")
set Xb=Xb-1
set ipw=null
endfunction
function Upw takes integer hpw,string Fpw returns nothing
local unit kpw
local integer jpw
local integer xpw
local boolean vpw
local player mpw
local player Qpw
local integer Wpw
local integer Epw
local integer Zpw
set Cb[Xb]=Fpw
set Xb=Xb+1
set jpw=Jo
set xpw=GetUnitTypeId(GetTriggerUnit())
set Cb[Xb]="when calling has in OreCapture, line 22"
set Xb=Xb+1
if Sl[jpw]==0 then
if jpw==0 then
call q1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call q1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set vpw=nbw(jpw,xpw)
set Xb=Xb-1
if vpw then
set kpw=GetTriggerUnit()
if GetUnitStatePercent(kpw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=80.0 then
call SetUnitOwner(kpw,GetOwningPlayer(GetAttacker()),true)
call SetUnitState(kpw,UNIT_STATE_LIFE,GetUnitState(kpw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.0)*0.01)
set mpw=GetOwningPlayer(kpw)
set Epw=rc[GetPlayerId(GetOwningPlayer(kpw))]
set Wpw=Ko
set rc[GetPlayerId(mpw)]=Epw-cdw(Wpw,GetUnitTypeId(kpw),"when calling get in OreCapture, line 29")
set Qpw=GetOwningPlayer(GetAttacker())
set Zpw=rc[GetPlayerId(GetOwningPlayer(GetAttacker()))]
set hpw=Ko
set rc[GetPlayerId(Qpw)]=Zpw+cdw(hpw,GetUnitTypeId(kpw),"when calling get in OreCapture, line 30")
endif
endif
set Xb=Xb-1
set kpw=null
set mpw=null
set Qpw=null
endfunction
function WSw takes integer gSw returns nothing
local unit hSw=GetDyingUnit()
local real FSw
local real kSw
local player jSw
local integer xSw
local real vSw
local unit mSw
local unitstate QSw
if hSw==xl[Nl[gSw]]then
set jSw=wo[Wl[Nl[gSw]]]
set xSw=GetUnitTypeId(hSw)
set xl[Nl[gSw]]=CreateUnitAtLoc(jSw,xSw,GetUnitLoc(hSw),bj_UNIT_FACING)
set mSw=xl[Nl[gSw]]
set QSw=UNIT_STATE_LIFE
set vSw=GetUnitState(xl[Nl[gSw]],UNIT_STATE_MAX_LIFE)
set FSw=bo
if 0.>FSw then
set kSw=0.
else
set kSw=FSw
endif
if 50.0>kSw then
set kSw=50.0
endif
call SetUnitState(mSw,QSw,vSw*kSw*0.01)
call SetUnitState(xl[Nl[gSw]],UNIT_STATE_MANA,GetUnitState(hSw,UNIT_STATE_MANA))
endif
set hSw=null
set jSw=null
set mSw=null
set QSw=null
endfunction
function nww takes integer bww,string yww returns unit
local integer pww
local fogstate eww
local integer qww
local unit aww
set Cb[Xb]=yww
set Xb=Xb+1
set pww=Io
set eww=ConvertFogState(bww)
set Cb[Xb]="when calling saveFogState in TypeCasting, line 52"
set Xb=Xb+1
if AO[pww]==0 then
if pww==0 then
call q1("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call q1("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call SaveFogStateHandle(Wo,pww,0,eww)
set Xb=Xb-1
set qww=Io
set Cb[Xb]="when calling loadUnit in TypeCasting, line 53"
set Xb=Xb+1
if AO[qww]==0 then
if qww==0 then
call q1("Nullpointer exception when calling Table.loadUnit","when calling error in Table, line 75")
else
call q1("Called Table.loadUnit on invalid object.","when calling error in Table, line 75")
endif
endif
set aww=LoadUnitHandle(Wo,qww,0)
set Xb=Xb-1-1
set OR=aww
set eww=null
set aww=null
return OR
endfunction
function dyw takes integer Syw,string cyw returns nothing
local integer oyw
local integer Oyw
local real lyw
local real byw
local integer yyw
local unit pyw
local integer eyw
local boolean qyw
local integer ayw
local integer nyw
set Cb[Xb]=cyw
set Xb=Xb+1
set Syw=Ec
set eyw=GetUnitTypeId(GetOrderedUnit())
set Cb[Xb]="when calling has in MassControl, line 33"
set Xb=Xb+1
if Sl[Syw]==0 then
if Syw==0 then
call q1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call q1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set qyw=nbw(Syw,eyw)
set Xb=Xb-1
if qyw then
if Bnw(Qc,GetHandleId(GetOrderedUnit()),"when calling has in MassControl, line 34") then
set oyw=cdw(Qc,GetHandleId(GetOrderedUnit()),"when calling get in MassControl, line 35")
set Oyw=GetIssuedOrderId()
set lyw=GetOrderPointX()
set byw=GetOrderPointY()
set Cb[Xb]="when calling iterator in MassControl, line 38"
set Xb=Xb+1
set ayw=obw(oyw,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set yyw=ayw
loop
exitwhen Yb[gb[yyw]]==Gb[yyw]
set gb[yyw]=Yb[gb[yyw]]
set pyw=nww(Rb[gb[yyw]],"when calling unitFromIndex in MassControl, line 38")
set cyw="when calling alloc_MassControl_CallbackSingle_line39 in MassControl, line 39"
set Cb[Xb]="when calling alloc_MassControl_CallbackSingle_line39 in MassControl, line 39"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set nyw=RO
set TO[nyw]=647
else
call q1("Out of memory: Could not create MassControl_CallbackSingle_line39.","when calling error in MassControl, line 39")
set nyw=0
endif
else
set fO=fO-1
set nyw=dO[fO]
set TO[nyw]=647
endif
set Xb=Xb-1
set Qb[nyw]=pyw
set Wb[nyw]=Oyw
set Eb[nyw]=lyw
set Zb[nyw]=byw
call yB(0.01,nyw,"when calling doAfter in MassControl, line 39")
endloop
set Cb[Xb]="when calling close in MassControl, line 38"
set Xb=Xb+1
if Fb[yyw]then
call Rdw(yyw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1
call bdw(Qc,GetHandleId(GetOrderedUnit()),"when calling remove in MassControl, line 42")
endif
endif
set Xb=Xb-1
set pyw=null
endfunction
function eaw takes integer caw,string oaw returns nothing
local unit Oaw
local integer law
local player baw
local integer yaw
local boolean paw
set Cb[Xb]=oaw
set Xb=Xb+1
set Oaw=GetDyingUnit()
set law=GetPlayerId(GetOwningPlayer(Oaw))
set baw=wo[law]
if GetPlayerSlotState(baw)==PLAYER_SLOT_STATE_PLAYING then
set paw=GetPlayerController(baw)==MAP_CONTROL_USER
else
set paw=false
endif
if paw and(not IsUnitType(Oaw,UNIT_TYPE_STRUCTURE)) then
set yaw=Mc[law]
set caw=GetUnitLevel(Oaw)
set Cb[Xb]="when calling changeUpkeep in Upkeep, line 32"
set Xb=Xb+1
if yl[yaw]==0 then
if yaw==0 then
call q1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call q1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Hb[yaw]=Hb[yaw]+caw
set Xb=Xb-1
endif
set Xb=Xb-1
set Oaw=null
set baw=null
endfunction
function Mww takes unit Lww,unit Xww returns real
local real Cww_2=GetUnitX(Lww)
local real Vww=GetUnitY(Lww)
local real Bww=Cww_2-GetUnitX(Xww)
local real Nww=Vww-GetUnitY(Xww)
return SquareRoot(Bww*Bww+Nww*Nww)
endfunction
function eqw takes integer wqw,string uqw returns nothing
local unit rqw
local player sqw
local group tqw
local integer iqw
local boolean Sqw
local location cqw
local group oqw
local unit Oqw
local integer lqw
local boolean bqw
local boolean yqw
local boolean pqw
set Cb[Xb]=uqw
set Xb=Xb+1
set rqw=GetTriggerUnit()
set wqw=GetUnitTypeId(rqw)
set iqw=lo
set Cb[Xb]="when calling has in RangeChecks, line 14"
set Xb=Xb+1
if Sl[iqw]==0 then
if iqw==0 then
call q1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call q1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Sqw=nbw(iqw,wqw)
set Xb=Xb-1
if Sqw then
set sqw=GetOwningPlayer(rqw)
set cqw=GetUnitLoc(rqw)
set oqw=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(oqw,cqw,2000.0,null)
call DestroyBoolExpr(null)
set qc=CreateGroup()
call ForGroup(oqw,Pf)
set tqw=qc
loop
exitwhen FirstOfGroup(tqw)==null
set Oqw=FirstOfGroup(tqw)
call GroupRemoveUnit(tqw,Oqw)
if GetOwningPlayer(Oqw)==sqw and Oqw!=rqw then
if GetUnitTypeId(Oqw)==wqw and Mww(Oqw,rqw)<=1500 then
set yqw=true
else
if Knw(Vo,wqw,"when calling has in RangeChecks, line 21") then
set bqw=Knw(Vo,GetUnitTypeId(Oqw),"when calling has in RangeChecks, line 21")
else
set bqw=false
endif
set yqw=bqw
endif
set pqw=yqw
else
set pqw=false
endif
if pqw then
set Cb[Xb]="when calling alloc_RangeChecks_CallbackSingle_line23 in RangeChecks, line 23"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set lqw=RO
set TO[lqw]=652
else
call q1("Out of memory: Could not create RangeChecks_CallbackSingle_line23.","when calling error in RangeChecks, line 23")
set lqw=0
endif
else
set fO=fO-1
set lqw=dO[fO]
set TO[lqw]=652
endif
set Xb=Xb-1
set Kb[lqw]=rqw
call yB(0.01,lqw,"when calling doAfter in RangeChecks, line 23")
if wqw==1747988557 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 27"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build settlements too close to each other.")
set Xb=Xb-1
elseif wqw==1747989041 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 29"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build settlements too close to each other.")
set Xb=Xb-1
elseif wqw==1747990344 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 31"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build settlements too close to each other.")
set Xb=Xb-1
elseif wqw==1747989075 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 33"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build churches too close to each other.")
set Xb=Xb-1
elseif wqw==1747990102 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 35"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build churches too close to each other.")
set Xb=Xb-1
elseif wqw==1747988785 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 37"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build churches too close to each other.")
set Xb=Xb-1
elseif wqw==1747989839 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 39"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build mosques too close to each other.")
set Xb=Xb-1
elseif wqw==1747989059 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 41"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build castles too close to each other.")
set Xb=Xb-1
elseif wqw==1747989331 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 43"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build castles too close to each other.")
set Xb=Xb-1
elseif wqw==1747990351 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 45"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build castles too close to each other.")
set Xb=Xb-1
elseif wqw==1747990353 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 47"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build castles too close to each other.")
set Xb=Xb-1
elseif wqw==1747988568 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 49"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build inns too close to each other.")
set Xb=Xb-1
elseif wqw==1747990341 then
set Cb[Xb]="when calling attentionToPlayer in RangeChecks, line 51"
set Xb=Xb+1
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,l5(sqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(sqw,0.,0.,10.0,"You cannot build inns too close to each other.")
set Xb=Xb-1
endif
exitwhen true
endif
endloop
call GroupClear(tqw)
call DestroyGroup(tqw)
endif
set Xb=Xb-1
set rqw=null
set sqw=null
set tqw=null
set cqw=null
set oqw=null
set Oqw=null
endfunction
function fcw takes integer pcw,string ecw returns nothing
local integer qcw
local integer acw
local integer ncw
local player dcw
set Cb[Xb]=ecw
set Xb=Xb+1
if GetSpellAbilityId()==1093677620 then
if GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))<24 then
set qcw=Mc[GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))]
set Cb[Xb]="when calling getForceId in Clerics, line 10"
set Xb=Xb+1
if yl[qcw]==0 then
if qcw==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set pcw=Ib[qcw]
set Xb=Xb-1
set acw=Mc[GetPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]
set Cb[Xb]="when calling getForceId in Clerics, line 10"
set Xb=Xb+1
if yl[acw]==0 then
if acw==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set ncw=Ib[acw]
set Xb=Xb-1
if pcw==ncw then
call IssueImmediateOrderById(GetSpellAbilityUnit(),851972)
set dcw=GetOwningPlayer(GetSpellAbilityUnit())
set Cb[Xb]="when calling noteToPlayer in Clerics, line 12"
set Xb=Xb+1
call DisplayTimedTextToPlayer(dcw,0.,0.,10.0,N2(dcw,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(dcw,0.,0.,10.0,"Clerics cannot convert someone who professes same religion as you.")
set Xb=Xb-1
endif
endif
endif
set Xb=Xb-1
set dcw=null
endfunction
function gpw takes integer apw,string npw returns nothing
local unit dpw
local integer fpw
local boolean Rpw
local player Tpw
local integer Ypw
local integer Gpw
set Cb[Xb]=npw
set Xb=Xb+1
set apw=Jo
set fpw=GetUnitTypeId(GetTriggerUnit())
set Cb[Xb]="when calling has in OreCapture, line 15"
set Xb=Xb+1
if Sl[apw]==0 then
if apw==0 then
call q1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call q1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Rpw=nbw(apw,fpw)
set Xb=Xb-1
if Rpw then
set dpw=GetTriggerUnit()
set Tpw=GetOwningPlayer(dpw)
set Gpw=rc[GetPlayerId(GetOwningPlayer(dpw))]
set Ypw=Ko
set rc[GetPlayerId(Tpw)]=Gpw+cdw(Ypw,GetUnitTypeId(dpw),"when calling get in OreCapture, line 19")
endif
set Xb=Xb-1
set dpw=null
set Tpw=null
endfunction
function AC takes integer IC,integer PC returns integer
if IC==1 then
if PC==0 then
return 1747988529
elseif PC==1 then
return 1747990326
elseif PC==2 then
return 1747990084
elseif PC==3 then
return 1747989590
else
return 1747988529
endif
elseif IC==2 then
if PC==0 then
return 1747988530
elseif PC==1 then
return 1747990327
elseif PC==2 then
return 1747990087
elseif PC==3 then
return 1747989591
else
return 1747988530
endif
elseif IC==3 then
if PC==0 then
return 1747988531
elseif PC==1 then
return 1747990328
elseif PC==2 then
return 1747990086
elseif PC==3 then
return 1747989592
else
return 1747988531
endif
elseif PC==0 then
return 1747988529
elseif PC==1 then
return 1747990326
elseif PC==2 then
return 1747990084
elseif PC==3 then
return 1747989590
else
return 1747988529
endif
endfunction
function UC takes integer ZC returns integer
if ZC==1747988529 then
return 1
elseif ZC==1747988530 then
return 2
elseif ZC==1747988531 then
return 3
elseif ZC==1747990326 then
return 1
elseif ZC==1747990327 then
return 2
elseif ZC==1747990328 then
return 3
elseif ZC==1747990084 then
return 1
elseif ZC==1747990087 then
return 2
elseif ZC==1747990086 then
return 3
elseif ZC==1747989590 then
return 1
elseif ZC==1747989591 then
return 2
elseif ZC==1747989592 then
return 3
else
return 1
endif
endfunction
function Qtw takes integer Ttw,player Ytw,string Gtw returns nothing
local integer gtw
local integer htw
local unit Ftw
local unit ktw
local real jtw
local integer xtw
local integer vtw
local integer mtw
set Cb[Xb]=Gtw
set Xb=Xb+1
set Ftw=xl[Ttw]
call SetUnitState(Ftw,UNIT_STATE_LIFE,GetUnitState(Ftw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,60.0)*0.01)
set ktw=xl[Ttw]
call SetUnitState(ktw,UNIT_STATE_MANA,GetUnitState(ktw,UNIT_STATE_MAX_MANA)*RMaxBJ(0.,30.0)*0.01)
set Cb[Xb]="when calling addModifier in City, line 234"
set Xb=Xb+1
if pO[Ttw]==0 then
if Ttw==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(Ttw,0,"when calling addModifier in City, line 368")
set Xb=Xb-1
set jtw=Gl[cdw(aS,6,"when calling get in City, line 235")]
if GetRandomReal(0.0,1.0)<=jtw then
set Cb[Xb]="when calling addModifier in City, line 236"
set Xb=Xb+1
if pO[Ttw]==0 then
if Ttw==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(Ttw,6,"when calling addModifier in City, line 368")
set Xb=Xb-1
endif
set gtw=Ql[Ttw]
set htw=GetPlayerId(Ytw)
if htw>=0 and htw<24 then
set xtw=Mc[htw]
set Cb[Xb]="when calling getForceId in City, line 242"
set Xb=Xb+1
if yl[xtw]==0 then
if xtw==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set vtw=Ib[xtw]
set Xb=Xb-1
set gtw=vtw
endif
if Knw(Co,GetUnitTypeId(xl[Ttw]),"when calling has in City, line 244") then
set mtw=AC(UC(GetUnitTypeId(xl[Ttw])),gtw)
set Cb[Xb]="when calling replaceCity in City, line 245"
set Xb=Xb+1
if pO[Ttw]==0 then
if Ttw==0 then
call q1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call q1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call Otw(Ttw,mtw,"when calling replaceCity in City, line 194")
set Xb=Xb-1
endif
set Cb[Xb]="when calling changeOwner in City, line 247"
set Xb=Xb+1
if pO[Ttw]==0 then
if Ttw==0 then
call q1("Nullpointer exception when calling City.changeOwner","when calling error in City, line 199")
else
call q1("Called City.changeOwner on invalid object.","when calling error in City, line 199")
endif
endif
call qtw(Ttw,htw,"when calling changeOwner in City, line 199")
set Xb=Xb-1
call UnitAddAbility(xl[Ttw],1093677634)
set Xb=Xb-1
set Ftw=null
set ktw=null
endfunction
function f5 takes string b5,force y5,string p5 returns nothing
local integer e5
local integer q5
local player a5
local player n5
local force d5
set Cb[Xb]=p5
set Xb=Xb+1
set e5=0
set q5=23
loop
exitwhen e5>q5
set n5=wo[e5]
set d5=CreateForce()
call ForceAddPlayer(d5,n5)
if d5==y5 then
set a5=wo[e5]
call DisplayTimedTextToPlayer(a5,0.,0.,10.0,l5(a5,"when calling getAttentionStringForPlayer in Messages, line 116"))
call DisplayTimedTextToPlayer(a5,0.,0.,10.0,b5)
endif
set e5=e5+1
endloop
set Xb=Xb-1
set a5=null
set n5=null
set d5=null
endfunction
function jsw takes integer asw,string nsw returns nothing
local unit dsw
local boolean fsw
local unit Rsw
local integer Tsw
local player Ysw
local boolean Gsw
local real gsw
local real hsw
local real Fsw
local real ksw
set Cb[Xb]=nsw
set Xb=Xb+1
set dsw=GetTriggerUnit()
set Cb[Xb]="when calling isCity in CityManage, line 37"
set Xb=Xb+1
set Cb[Xb]="when calling isCity in UnitTools, line 5"
set Xb=Xb+1
set fsw=Knw(Bo,GetUnitTypeId(dsw),"when calling has in City, line 437")
set Xb=Xb-1-1
if fsw then
if GetUnitStatePercent(dsw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=50.0 then
set Gsw=GetOwningPlayer(dsw)!=GetOwningPlayer(GetAttacker())
else
set Gsw=false
endif
if Gsw then
set gsw=GetUnitX(dsw)
set hsw=GetUnitY(dsw)
set Rsw=GetAttacker()
set Fsw=gsw-GetUnitX(Rsw)
set ksw=hsw-GetUnitY(Rsw)
if SquareRoot(Fsw*Fsw+ksw*ksw)>300.0 then
call SetUnitState(dsw,UNIT_STATE_LIFE,GetUnitState(dsw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,50.0)*0.01)
else
set Cb[Xb]="when calling getCityId in CityManage, line 42"
set Xb=Xb+1
set asw=CC(dsw,"when calling getCityId in UnitTools, line 9")
set Xb=Xb-1
if Knw(Co,GetUnitTypeId(dsw),"when calling has in CityManage, line 44") then
call f5(hB(GetOwningPlayer(GetAttacker()))+" has just captured "+hB(GetOwningPlayer(GetTriggerUnit()))+" Capitol!",bj_FORCE_ALL_PLAYERS,"when calling attentionToForce in CityManage, line 45")
endif
set Tsw=hS[asw]
set Ysw=GetOwningPlayer(GetAttacker())
set Cb[Xb]="when calling capture in CityManage, line 46"
set Xb=Xb+1
if pO[Tsw]==0 then
if Tsw==0 then
call q1("Nullpointer exception when calling City.capture","when calling error in City, line 230")
else
call q1("Called City.capture on invalid object.","when calling error in City, line 230")
endif
endif
call Qtw(Tsw,Ysw,"when calling capture in City, line 230")
set Xb=Xb-1
endif
elseif GetUnitStatePercent(dsw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=50.0 then
call SetUnitState(dsw,UNIT_STATE_LIFE,GetUnitState(dsw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,50.0)*0.01)
endif
endif
set Xb=Xb-1
set dsw=null
set Rsw=null
set Ysw=null
endfunction
function W2 takes real j2,real x2,real v2,real m2,real Q2 returns real
set v2=GetRandomReal(v2,m2)
return (j2+x2)/2.+k2(v2)*Pow(2.718281828,-(Pow(v2,2.)/2.*Q2))/SquareRoot(6.283185482*Q2)*((x2-j2)/2.)
endfunction
function Wdw takes integer Fdw,integer kdw,string jdw returns integer
local integer xdw
local integer vdw
local integer mdw
local integer Qdw
set Cb[Xb]=jdw
set Xb=Xb+1
if Sl[Fdw]==0 then
if Fdw==0 then
call q1("Nullpointer exception when calling LinkedList.get","when calling error in LinkedList, line 50")
else
call q1("Called LinkedList.get on invalid object.","when calling error in LinkedList, line 50")
endif
endif
set Cb[Xb]="when calling get in LinkedList, line 50"
set Xb=Xb+1
set Cb[Xb]="when calling getEntry in LinkedList, line 51"
set Xb=Xb+1
if Sl[Fdw]==0 then
if Fdw==0 then
call q1("Nullpointer exception when calling LinkedList.getEntry","when calling error in LinkedList, line 366")
else
call q1("Called LinkedList.getEntry on invalid object.","when calling error in LinkedList, line 366")
endif
endif
set vdw=kb[Fdw]
set mdw=0
set Qdw=kdw
loop
exitwhen mdw>Qdw
set vdw=Yb[vdw]
set mdw=mdw+1
endloop
set Xb=Xb-1
set xdw=Rb[vdw]
set Xb=Xb-1-1
return xdw
endfunction
function eSw takes integer Xiw,unit Ciw,string Viw,integer Biw,integer Niw,string Miw returns nothing
local playerunitevent wSw
local real uSw
local real rSw
local unit sSw
local player tSw
local integer iSw
local integer SSw
local real cSw
local integer oSw
local timer OSw
local integer lSw
local timer bSw
local real ySw
local real pSw
set Cb[Xb]=Miw
set Xb=Xb+1
set Jl[Xiw]=0
set Kl[Xiw]=0.
set Ll[Xiw]=hbw("when calling new_LinkedList in City, line 104")
set Hl[Xiw]=1.0
set xl[Xiw]=Ciw
set sSw=xl[Xiw]
set ySw=GetUnitX(sSw)
set pSw=GetUnitY(sSw)
set El[Xiw]=ySw
set Zl[Xiw]=pSw
set vl[Xiw]=Viw
set Ql[Xiw]=Biw
set tSw=GetOwningPlayer(xl[Xiw])
set Wl[Xiw]=GetPlayerId(tSw)
set vl[Xiw]=SubString(Viw,0,24)
set ml[Xiw]=nS
set nS=nS+1
set wSw=EVENT_PLAYER_UNIT_DEATH
set Cb[Xb]="when calling alloc_City_City_EventListener_line121 in City, line 121"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set iSw=iO
set SO[iSw]=666
else
call q1("Out of memory: Could not create City_City_EventListener_line121.","when calling error in City, line 121")
set iSw=0
endif
else
set tO=tO-1
set iSw=sO[tO]
set SO[iSw]=666
endif
set Xb=Xb-1
set ub[iSw]=0
set rb[iSw]=0
set sb[iSw]=0
set Nl[iSw]=Xiw
set Cb[Xb]="when calling add in City, line 121"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set SSw=vS[GetHandleId(wSw)]
if SSw==0 then
set SSw=aV(wSw,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[iSw]=SSw
if ES[ub[iSw]]!=0 then
set sb[ES[ub[iSw]]]=iSw
set rb[iSw]=ES[ub[iSw]]
endif
set ES[ub[iSw]]=iSw
set Xb=Xb-1
set Pl[Xiw]=W2(fS[0],fS[1],-5.0,5.0,0.15)
set cSw=W2(Wdw(RS[Niw],0,"when calling get in City, line 133")*1.,Wdw(RS[Niw],1,"when calling get in City, line 133")*1.,-5.0,5.0,0.15)
set Ul[Xiw]=R2I(cSw)
set Dl[Xiw]=0.
set uSw=2.5+GetRandomReal(2.5,5.0)
set Cb[Xb]="when calling alloc_City_City_CallbackPeriodic_line138 in City, line 138"
set Xb=Xb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set oSw=gO
set hO[oSw]=631
else
call q1("Out of memory: Could not create City_City_CallbackPeriodic_line138.","when calling error in City, line 138")
set oSw=0
endif
else
set GO=GO-1
set oSw=YO[GO]
set hO[oSw]=631
endif
set Xb=Xb-1
set Ml[oSw]=Xiw
set Cb[Xb]="when calling doPeriodically in City, line 138"
set Xb=Xb+1
set OSw=Cww("when calling getTimer in ClosureTimers, line 57")
set Cb[Xb]="when calling doPeriodically in ClosureTimers, line 57"
set Xb=Xb+1
call anw(oSw,OSw,uSw,"when calling start in ClosureTimers, line 45")
set Xb=Xb-1-1
set rSw=60+GetRandomReal(60,120.0)
set Cb[Xb]="when calling alloc_City_City_CallbackPeriodic_line154 in City, line 154"
set Xb=Xb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set lSw=gO
set hO[lSw]=632
else
call q1("Out of memory: Could not create City_City_CallbackPeriodic_line154.","when calling error in City, line 154")
set lSw=0
endif
else
set GO=GO-1
set lSw=YO[GO]
set hO[lSw]=632
endif
set Xb=Xb-1
set wb[lSw]=Xiw
set Cb[Xb]="when calling doPeriodically in City, line 154"
set Xb=Xb+1
set bSw=Cww("when calling getTimer in ClosureTimers, line 57")
set Cb[Xb]="when calling doPeriodically in ClosureTimers, line 57"
set Xb=Xb+1
call anw(lSw,bSw,rSw,"when calling start in ClosureTimers, line 45")
set Xb=Xb-1-1-1
set wSw=null
set sSw=null
set tSw=null
set OSw=null
set bSw=null
endfunction
function Liw takes unit Piw,string Aiw,integer Diw,integer Hiw,string Jiw returns integer
local integer Kiw
set Cb[Xb]=Jiw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_City in City, line 101"
set Xb=Xb+1
if bO==0 then
if yO<32768 then
set yO=yO+1
set Kiw=yO
set pO[Kiw]=653
else
call q1("Out of memory: Could not create City.","when calling error in City, line 71")
set Kiw=0
endif
else
set bO=bO-1
set Kiw=lO[bO]
set pO[Kiw]=653
endif
set Xb=Xb-1
call eSw(Kiw,Piw,Aiw,Diw,Hiw,"when calling construct_City in City, line 101")
set Xb=Xb-1
return Kiw
endfunction
function lsw takes integer tsw,string isw returns nothing
local unit Ssw
local boolean csw
local integer osw
local unit Osw
set Cb[Xb]=isw
set Xb=Xb+1
set Ssw=GetConstructedStructure()
set Cb[Xb]="when calling isCity in CityBuilded, line 10"
set Xb=Xb+1
set Cb[Xb]="when calling isCity in UnitTools, line 5"
set Xb=Xb+1
set csw=Knw(Bo,GetUnitTypeId(Ssw),"when calling has in City, line 437")
set Xb=Xb-1-1
if csw then
set Osw=GetConstructedStructure()
set tsw=Mc[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))]
set Cb[Xb]="when calling getForceId in CityBuilded, line 11"
set Xb=Xb+1
if yl[tsw]==0 then
if tsw==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set osw=Ib[tsw]
set Xb=Xb-1
set hS[nS]=Liw(Osw,"New",osw,1,"when calling new_City in CityBuilded, line 11")
endif
set Xb=Xb-1
set Ssw=null
set Osw=null
endfunction
function qpw takes integer lpw,string bpw returns nothing
local unit ypw
local integer ppw
local boolean epw
set Cb[Xb]=bpw
set Xb=Xb+1
set ppw=Jo
set lpw=GetUnitTypeId(GetDyingUnit())
set Cb[Xb]="when calling has in OreCapture, line 10"
set Xb=Xb+1
if Sl[ppw]==0 then
if ppw==0 then
call q1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call q1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set epw=nbw(ppw,lpw)
set Xb=Xb-1
if epw then
set ypw=GetTriggerUnit()
call CreateUnitAtLoc(GetOwningPlayer(ypw),GetUnitTypeId(ypw),GetUnitLoc(ypw),bj_UNIT_FACING)
endif
set Xb=Xb-1
set ypw=null
endfunction
function Hdw takes integer Pdw,integer Adw,string Ddw returns nothing
set Cb[Xb]=Ddw
set Xb=Xb+1
if yl[Pdw]==0 then
if Pdw==0 then
call q1("Nullpointer exception when calling PlayerStats.setSelectedCityId","when calling error in PlayerStats, line 116")
else
call q1("Called PlayerStats.setSelectedCityId on invalid object.","when calling error in PlayerStats, line 116")
endif
endif
set Cb[Xb]="when calling setSelectedCityId in PlayerStats, line 116"
set Xb=Xb+1
if Adw>=0 and Adw<nS then
set Db[Pdw]=Adw
set Cb[Xb]="when calling refreshMultiboardCity in PlayerStats, line 119"
set Xb=Xb+1
if yl[Pdw]==0 then
if Pdw==0 then
call q1("Nullpointer exception when calling PlayerStats.refreshMultiboardCity","when calling error in PlayerStats, line 71")
else
call q1("Called PlayerStats.refreshMultiboardCity on invalid object.","when calling error in PlayerStats, line 71")
endif
endif
call pew(Pdw,"when calling refreshMultiboardCity in PlayerStats, line 71")
set Xb=Xb-1
endif
set Xb=Xb-1-1
endfunction
function qsw takes integer bsw,string ysw returns nothing
local unit psw
local boolean esw
set Cb[Xb]=ysw
set Xb=Xb+1
set psw=GetTriggerUnit()
set Cb[Xb]="when calling isCity in CityManage, line 10"
set Xb=Xb+1
set Cb[Xb]="when calling isCity in UnitTools, line 5"
set Xb=Xb+1
set esw=Knw(Bo,GetUnitTypeId(psw),"when calling has in City, line 437")
set Xb=Xb-1-1
if esw then
call Hdw(Mc[GetPlayerId(GetTriggerPlayer())],CC(GetTriggerUnit(),"when calling getCityId in CityManage, line 11"),"when calling setSelectedCityId in CityManage, line 11")
endif
set Xb=Xb-1
set psw=null
endfunction
function rpw takes integer Xyw,string Cyw returns nothing
local unit Vyw
local integer Byw
local integer Nyw
local integer Myw
local boolean wpw
local boolean upw
set Cb[Xb]=Cyw
set Xb=Xb+1
set Vyw=GetOrderedUnit()
if GetIssuedOrderId()==852056 then
set wpw=GetUnitAbilityLevel(Vyw,1093677904)>0
else
set wpw=false
endif
if wpw then
call UnitRemoveAbility(Vyw,1093677904)
set Byw=Xc
set Xyw=GetHandleId(Vyw)
set Cb[Xb]="when calling add in NoStarvationOnBoat, line 14"
set Xb=Xb+1
if ZO[Byw]==0 then
if Byw==0 then
call q1("Nullpointer exception when calling HashSet.add","when calling error in HashSet, line 9")
else
call q1("Called HashSet.add on invalid object.","when calling error in HashSet, line 9")
endif
endif
call Ahw(Byw,Xyw,"when calling add in HashSet, line 9")
set Xb=Xb-1
endif
if GetIssuedOrderId()==851972 then
set upw=Knw(Xc,GetHandleId(Vyw),"when calling has in NoStarvationOnBoat, line 16")
else
set upw=false
endif
if upw then
call UnitAddAbility(GetOrderedUnit(),1093677904)
set Nyw=Xc
set Myw=GetHandleId(Vyw)
set Cb[Xb]="when calling remove in NoStarvationOnBoat, line 18"
set Xb=Xb+1
if ZO[Nyw]==0 then
if Nyw==0 then
call q1("Nullpointer exception when calling HashSet.remove","when calling error in HashSet, line 16")
else
call q1("Called HashSet.remove on invalid object.","when calling error in HashSet, line 16")
endif
endif
call Ylw(Nyw,Myw,"when calling remove in HashSet, line 16")
set Xb=Xb-1
endif
set Xb=Xb-1
set Vyw=null
endfunction
function EC takes integer QC,integer WC returns integer
if QC==1 then
if WC==0 then
return 1747989059
elseif WC==1 then
return 1747990351
elseif WC==2 then
return 1747989331
elseif WC==3 then
return 1747990353
else
return 1747989059
endif
elseif QC==2 then
if WC==0 then
return 1747989060
elseif WC==1 then
return 1747990352
elseif WC==2 then
return 1747990350
elseif WC==3 then
return 1747990354
else
return 1747989060
endif
elseif QC==3 then
if WC==0 then
return 1747988844
elseif WC==1 then
return 1747990356
elseif WC==2 then
return 1747989809
elseif WC==3 then
return 1747990355
else
return 1747988844
endif
elseif WC==0 then
return 1747989059
elseif WC==1 then
return 1747990351
elseif WC==2 then
return 1747989331
elseif WC==3 then
return 1747990353
else
return 1747989059
endif
endfunction
function mC takes integer vC returns integer
if vC==1747989059 then
return 1
elseif vC==1747989060 then
return 2
elseif vC==1747988844 then
return 3
elseif vC==1747990351 then
return 1
elseif vC==1747990352 then
return 2
elseif vC==1747990356 then
return 3
elseif vC==1747989331 then
return 1
elseif vC==1747990350 then
return 2
elseif vC==1747989809 then
return 3
elseif vC==1747990353 then
return 1
elseif vC==1747990354 then
return 2
elseif vC==1747990355 then
return 3
else
return 1
endif
endfunction
function ssw takes integer Hrw,string Jrw returns nothing
local unit Krw
local player Lrw
local unit Xrw
local integer Crw
local integer Vrw
local boolean Brw
local real Nrw
local boolean Mrw
local real wsw
local real usw
local real rsw
set Cb[Xb]=Jrw
set Xb=Xb+1
set Krw=GetTriggerUnit()
if Knw(Vo,GetUnitTypeId(Krw),"when calling has in CastleCapture, line 11") then
if GetUnitStatePercent(Krw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=50.0 then
set Brw=GetOwningPlayer(Krw)!=GetOwningPlayer(GetAttacker())
else
set Brw=false
endif
if Brw then
set Nrw=GetUnitX(Krw)
set wsw=GetUnitY(Krw)
set Xrw=GetAttacker()
set usw=Nrw-GetUnitX(Xrw)
set rsw=wsw-GetUnitY(Xrw)
set Mrw=SquareRoot(usw*usw+rsw*rsw)<=300.0
else
set Mrw=false
endif
if Mrw then
set Lrw=GetOwningPlayer(GetAttacker())
call SetUnitOwner(Krw,Lrw,true)
if GetPlayerId(Lrw)!=PLAYER_NEUTRAL_AGGRESSIVE then
set Hrw=mC(GetUnitTypeId(Krw))
set Crw=Mc[GetPlayerId(Lrw)]
set Cb[Xb]="when calling getForceId in CastleCapture, line 17"
set Xb=Xb+1
if yl[Crw]==0 then
if Crw==0 then
call q1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call q1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set Vrw=Ib[Crw]
set Xb=Xb-1
call ReplaceUnitBJ(Krw,EC(Hrw,Vrw),bj_UNIT_STATE_METHOD_RELATIVE)
endif
call SetUnitState(Krw,UNIT_STATE_LIFE,GetUnitState(Krw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,60.0)*0.01)
call SetUnitState(Krw,UNIT_STATE_MANA,GetUnitState(Krw,UNIT_STATE_MAX_MANA)*RMaxBJ(0.,0.0)*0.01)
call UnitAddAbility(Krw,1093677896)
endif
endif
set Xb=Xb-1
set Krw=null
set Lrw=null
set Xrw=null
endfunction
function vlw takes integer Flw returns nothing
local unit klw=GetConstructingStructure()
local player jlw
local player xlw
if GetUnitTypeId(klw)==1747988808 then
set jlw=GetOwningPlayer(klw)
set xlw=GetOwningPlayer(klw)
set fc[GetPlayerId(jlw)]=fc[GetPlayerId(xlw)]-1
endif
set klw=null
set jlw=null
set xlw=null
endfunction
function wyw takes integer Kbw,string Lbw returns nothing
local integer Xbw
local unit Cbw
local player Vbw
local real Bbw
local real Nbw
local real Mbw
set Cb[Xb]=Lbw
set Xb=Xb+1
if GetSpellAbilityId()==1093678154 then
set Xbw=hbw("when calling new_LinkedList in MassControl, line 24")
set Cbw=GetSpellAbilityUnit()
set Vbw=GetOwningPlayer(Cbw)
set Nbw=GetSpellTargetX()
set Mbw=GetSpellTargetY()
set Bbw=Wdw(Wc,GetLearnedSkillLevel(),"when calling get in MassControl, line 27")/1000.
set Cb[Xb]="when calling alloc_MassControl_ForGroupCallback_line27 in MassControl, line 27"
set Xb=Xb+1
if qO==0 then
if aO<32768 then
set aO=aO+1
set Kbw=aO
set nO[Kbw]=691
else
call q1("Out of memory: Could not create MassControl_ForGroupCallback_line27.","when calling error in MassControl, line 27")
set Kbw=0
endif
else
set qO=qO-1
set Kbw=eO[qO]
set nO[Kbw]=691
endif
set Xb=Xb-1
set xb[Kbw]=Vbw
set vb[Kbw]=Cbw
set mb[Kbw]=Xbw
call SB(Nbw,Mbw,Bbw,Kbw,"when calling forUnitsInRange in MassControl, line 27")
call rdw(Qc,GetHandleId(Cbw),Xbw,"when calling put in MassControl, line 30")
endif
set Xb=Xb-1
set Cbw=null
set Vbw=null
endfunction
function Kaw takes integer Haw,string Jaw returns nothing
set Cb[Xb]=Jaw
set Xb=Xb+1
if SO[Haw]==0 then
if Haw==0 then
call q1("Nullpointer exception when calling EventListener.onEvent","when calling error in ClosureEvents, line 109")
else
call q1("Called EventListener.onEvent on invalid object.","when calling error in ClosureEvents, line 109")
endif
endif
if SO[Haw]<=673 then
if SO[Haw]<=667 then
if SO[Haw]<=664 then
if SO[Haw]<=663 then
if SO[Haw]<=662 then
call ssw(Haw,"when calling CastleCapture_onEvent_line8 in ClosureEvents, line 109")
else
call lsw(Haw,"when calling CityBuilded_onEvent_line9 in ClosureEvents, line 109")
endif
else
call jsw(Haw,"when calling CityManage_onEvent_line34 in ClosureEvents, line 109")
endif
elseif SO[Haw]<=666 then
if SO[Haw]<=665 then
call qsw(Haw,"when calling CityManage_onEvent_line9 in ClosureEvents, line 109")
else
call WSw(Haw)
endif
else
call fcw(Haw,"when calling Clerics_onEvent_line5 in ClosureEvents, line 109")
endif
elseif SO[Haw]<=670 then
if SO[Haw]<=669 then
if SO[Haw]<=668 then
call OOw(Haw,"when calling Garissons_onEvent_line7 in ClosureEvents, line 109")
else
call Ilw(Haw,"when calling LimitEncampments_onEvent_line12 in ClosureEvents, line 109")
endif
else
call vlw(Haw)
endif
elseif SO[Haw]<=672 then
if SO[Haw]<=671 then
call Nlw(Haw,"when calling LimitMercenaryCamps_onEvent_line12 in ClosureEvents, line 109")
else
call Jlw(Haw)
endif
else
call wyw(Haw,"when calling MassControl_onEvent_line22 in ClosureEvents, line 109")
endif
elseif SO[Haw]<=679 then
if SO[Haw]<=676 then
if SO[Haw]<=675 then
if SO[Haw]<=674 then
call dyw(Haw,"when calling MassControl_onEvent_line32 in ClosureEvents, line 109")
else
call Lyw(Haw,"when calling NoShipsNearRivers_onEvent_line7 in ClosureEvents, line 109")
endif
else
call rpw(Haw,"when calling NoStarvationOnBoat_onEvent_line9 in ClosureEvents, line 109")
endif
elseif SO[Haw]<=678 then
if SO[Haw]<=677 then
call Spw(Haw,"when calling OnPlayerLeave_onEvent_line5 in ClosureEvents, line 109")
else
call gpw(Haw,"when calling OreCapture_onEvent_line14 in ClosureEvents, line 109")
endif
else
call Upw(Haw,"when calling OreCapture_onEvent_line21 in ClosureEvents, line 109")
endif
elseif SO[Haw]<=682 then
if SO[Haw]<=681 then
if SO[Haw]<=680 then
call qpw(Haw,"when calling OreCapture_onEvent_line9 in ClosureEvents, line 109")
else
call eqw(Haw,"when calling RangeChecks_onEvent_line11 in ClosureEvents, line 109")
endif
else
call Eqw(Haw,"when calling Taxation_onEvent_line6 in ClosureEvents, line 109")
endif
elseif SO[Haw]<=683 then
call eaw(Haw,"when calling Upkeep_onEvent_line28 in ClosureEvents, line 109")
else
call Saw(Haw,"when calling Upkeep_onEvent_line6 in ClosureEvents, line 109")
endif
set Xb=Xb-1
endfunction
function PV takes string vV returns nothing
local unit mV
local integer QV
local integer WV
local integer EV
local eventid ZV
local integer UV
local boolean IV
set Cb[Xb]=vV
set Xb=Xb+1
set mV=GetTriggerUnit()
set ZV=GetTriggerEventId()
set Cb[Xb]="when calling toIntId in ClosureEvents, line 170"
set Xb=Xb+1
set UV=vS[GetHandleId(ZV)]
if UV==0 then
set UV=aV(ZV,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set QV=UV
if mV!=null then
set IV=GetUnitUserData(mV)>0
else
set IV=false
endif
if IV then
if ZS[GetUnitUserData(mV)]!=0 then
set WV=ZS[GetUnitUserData(mV)]
loop
exitwhen WV==0
if ub[WV]==QV then
call Kaw(WV,"when calling onEvent in ClosureEvents, line 177")
endif
set WV=rb[WV]
endloop
endif
endif
if ES[QV]!=0 then
set EV=ES[QV]
loop
exitwhen EV==0
call Kaw(EV,"when calling onEvent in ClosureEvents, line 183")
set EV=rb[EV]
endloop
endif
set Xb=Xb-1
set mV=null
set ZV=null
endfunction
function HFw takes nothing returns nothing
set Xb=0
call PV("ClosureEvents, line 241")
endfunction
function HG takes nothing returns nothing
local location QG
local location WG
local real EG
local real ZG
local rect UG
local group IG
local group PG
local code AG
local boolean DG
set u=GetUnitLoc(GetSpellAbilityUnit())
set QG=u
set c=Location(GetLocationX(QG)+200.00,GetLocationY(QG)+0.00)
set WG=u
set EG=GetLocationX(WG)
set ZG=GetLocationY(WG)
set O=Rect(EG-150,ZG-140,EG+150,ZG+140)
set UG=O
set IG=CreateGroup()
call GroupEnumUnitsInRect(IG,UG,null)
call DestroyBoolExpr(null)
set l=IG
set PG=l
set AG=Dy
set DG=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(PG,AG)
if DG then
call DestroyGroup(PG)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747988825,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set QG=null
set WG=null
set UG=null
set IG=null
set PG=null
endfunction
function DI takes nothing returns boolean
if GetResearched()!=1378890038 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890038,true)!=1 then
return false
endif
return true
endfunction
function HI takes nothing returns boolean
if not DI() then
return false
endif
return true
endfunction
function HJ takes nothing returns nothing
call UnitAddAbility(GetConstructedStructure(),1093677896)
endfunction
function Hg takes nothing returns nothing
local location Qg
local location Wg
local real Eg
local real Zg
local rect Ug
local group Ig
local group Pg
local code Ag
local boolean Dg
set u=GetUnitLoc(GetSpellAbilityUnit())
set Qg=u
set S=Location(GetLocationX(Qg)+0.00,GetLocationY(Qg)+200.00)
set Wg=u
set Eg=GetLocationX(Wg)
set Zg=GetLocationY(Wg)
set o=Rect(Eg-140,Zg-150,Eg+140,Zg+150)
set Ug=o
set Ig=CreateGroup()
call GroupEnumUnitsInRect(Ig,Ug,null)
call DestroyBoolExpr(null)
set l=Ig
set Pg=l
set Ag=Ny
set Dg=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Pg,Ag)
if Dg then
call DestroyGroup(Pg)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990090,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set Qg=null
set Wg=null
set Ug=null
set Ig=null
set Pg=null
endfunction
function Hh takes nothing returns nothing
local location Qh
local location Wh
local real Eh
local real Zh
local rect Uh
local group Ih
local group Ph
local code Ah
local boolean Dh
set u=GetUnitLoc(GetSpellAbilityUnit())
set Qh=u
set S=Location(GetLocationX(Qh)+0.00,GetLocationY(Qh)+200.00)
set Wh=u
set Eh=GetLocationX(Wh)
set Zh=GetLocationY(Wh)
set o=Rect(Eh-140,Zh-150,Eh+140,Zh+150)
set Uh=o
set Ih=CreateGroup()
call GroupEnumUnitsInRect(Ih,Uh,null)
call DestroyBoolExpr(null)
set l=Ih
set Ph=l
set Ah=cp
set Dh=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Ph,Ah)
if Dh then
call DestroyGroup(Ph)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989079,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set Qh=null
set Wh=null
set Uh=null
set Ih=null
set Ph=null
endfunction
function Hm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988551,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989081,0)
endfunction
function UE takes nothing returns boolean
if GetResearched()!=1378889806 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889806,true)!=1 then
return false
endif
return true
endfunction
function IE takes nothing returns boolean
if not UE() then
return false
endif
return true
endfunction
function vww takes string Fww returns boolean
local playerunitevent kww
local integer jww
local integer xww
set Cb[Xb]=Fww
set Xb=Xb+1
set kww=EVENT_PLAYER_UNIT_SPELL_CAST
set Cb[Xb]="when calling alloc_Taxation_EventListener_line6 in Taxation, line 6"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set jww=iO
set SO[jww]=682
else
call q1("Out of memory: Could not create Taxation_EventListener_line6.","when calling error in Taxation, line 6")
set jww=0
endif
else
set tO=tO-1
set jww=sO[tO]
set SO[jww]=682
endif
set Xb=Xb-1
set ub[jww]=0
set rb[jww]=0
set sb[jww]=0
set Cb[Xb]="when calling add in Taxation, line 6"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set xww=vS[GetHandleId(kww)]
if xww==0 then
set xww=aV(kww,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[jww]=xww
if ES[ub[jww]]!=0 then
set sb[ES[ub[jww]]]=jww
set rb[jww]=ES[ub[jww]]
endif
set ES[ub[jww]]=jww
set Xb=Xb-1-1
set kww=null
return true
endfunction
function IFw takes nothing returns boolean
set Xb=0
return vww("Taxation, line 1")
endfunction
function IL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function IT takes nothing returns nothing
local group ET=GetUnitsOfTypeIdAll(1747988554)
local code ZT=Gy
local boolean UT=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(ET,ZT)
if UT then
call DestroyGroup(ET)
endif
set ET=null
endfunction
function IU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989816,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989815,0)
endfunction
function IW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989301,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988790,0)
endfunction
function JF takes nothing returns nothing
local player mF=GetOwningPlayer(GetSpellTargetUnit())
local playerstate QF=PLAYER_STATE_RESOURCE_LUMBER
local playerstate WF
local playerstate EF
local player ZF
local force UF
local location IF
local real PF
local real AF
local player DF
local force HF
if QF==PLAYER_STATE_RESOURCE_GOLD then
set WF=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(mF,WF,GetPlayerState(mF,WF)+250)
elseif QF==PLAYER_STATE_RESOURCE_LUMBER then
set EF=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(mF,EF,GetPlayerState(mF,EF)+250)
endif
call SetPlayerState(mF,QF,GetPlayerState(mF,QF)+250)
call RemoveUnit(GetSpellAbilityUnit())
set ZF=GetOwningPlayer(GetSpellTargetUnit())
set UF=CreateForce()
call ForceAddPlayer(UF,ZF)
if IsPlayerInForce(GetLocalPlayer(),UF) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1229")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set DF=GetOwningPlayer(GetSpellTargetUnit())
set HF=CreateForce()
call ForceAddPlayer(HF,DF)
set IF=y
set PF=GetLocationX(IF)
set AF=GetLocationY(IF)
if IsPlayerInForce(GetLocalPlayer(),HF) then
call PingMinimap(PF,AF,2.00)
endif
call RemoveLocation(y)
set mF=null
set QF=null
set WF=null
set EF=null
set ZF=null
set UF=null
set IF=null
set DF=null
set HF=null
endfunction
function JI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989830,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989829,0)
endfunction
function Yww takes string fww,string Rww returns boolean
local integer Tww=StringLength(fww)
if StringLength(Rww)>Tww then
return false
endif
return SubString(fww,0,StringLength(Rww))==Rww
endfunction
function JN takes nothing returns boolean
return Yww(GetEventPlayerChatString(),"-")
endfunction
function HP takes nothing returns boolean
if GetResearched()!=1378890051 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890051,true)!=1 then
return false
endif
return true
endfunction
function JP takes nothing returns boolean
if not HP() then
return false
endif
return true
endfunction
function JW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989057,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988558,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988551,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989066,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651824,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651826,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988818,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989080,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989072,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989082,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988559,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988812,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651828,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989065,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989067,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989301,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651843,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988561,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988788,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988565,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988566,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988567,0)
endfunction
function HZ takes nothing returns boolean
if GetResearched()!=1378890035 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890035,true)!=1 then
return false
endif
return true
endfunction
function JZ takes nothing returns boolean
if not HZ() then
return false
endif
return true
endfunction
function Hv takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function Jv takes nothing returns boolean
if not Hv() then
return false
endif
return true
endfunction
function KB takes nothing returns boolean
local trigger DB=CreateTrigger()
local trigger AB
local integer HB
local integer JB
call TriggerAddCondition(DB,Condition(Uf))
call TriggerAddAction(DB,If)
set AB=DB
set HB=0
set JB=23
loop
exitwhen HB>JB
call TriggerRegisterPlayerChatEvent(AB,wo[HB],"-",false)
set HB=HB+1
endloop
set AB=null
set DB=null
return true
endfunction
function w0w takes integer M9 returns real
if M9==1747988785 then
return 10.0
elseif M9==1747989075 then
return 10.0
elseif M9==1747990102 then
return 10.0
elseif M9==1747989839 then
return 10.0
elseif M9==1747988568 then
return 5.0
elseif M9==1747990341 then
return 5.0
elseif M9==1747988789 then
return 15.0
elseif M9==1747990103 then
return 15.0
elseif M9==1747990064 then
return 15.0
elseif M9==1747989846 then
return 15.0
else
return 0.0
endif
endfunction
function GSw takes integer RSw,unit TSw returns nothing
local boolean YSw
if IsUnitType(TSw,UNIT_TYPE_STRUCTURE) then
set YSw=GetOwningPlayer(TSw)==wo[Wl[Cl[RSw]]]
else
set YSw=false
endif
if YSw then
set Al[Cl[RSw]]=Al[Cl[RSw]]+w0w(GetUnitTypeId(TSw))
endif
endfunction
function fSw takes integer qSw,unit aSw,string nSw returns nothing
local boolean dSw
set Cb[Xb]=nSw
set Xb=Xb+1
if not Knw(Xo,GetUnitTypeId(aSw),"when calling has in City, line 314") then
set dSw=GetOwningPlayer(aSw)==wo[Wl[Xl[qSw]]]
else
set dSw=false
endif
if dSw then
set Al[Xl[qSw]]=Al[Xl[qSw]]+0.5
endif
set Xb=Xb-1
endfunction
function iyw takes integer uyw,unit ryw,string syw returns nothing
local boolean tyw
set Cb[Xb]=syw
set Xb=Xb+1
if GetOwningPlayer(ryw)==xb[uyw]then
set tyw=not Knw(Xo,GetUnitTypeId(ryw),"when calling has in MassControl, line 28")
else
set tyw=false
endif
if tyw and ryw!=vb[uyw] and(not IsUnitType(ryw,UNIT_TYPE_STRUCTURE)) then
call Ndw(mb[uyw],GetHandleId(ryw),"when calling add in MassControl, line 29")
endif
set Xb=Xb-1
endfunction
function Snw takes integer snw,unit tnw,string inw returns nothing
set Cb[Xb]=inw
set Xb=Xb+1
if nO[snw]==0 then
if snw==0 then
call q1("Nullpointer exception when calling ForGroupCallback.callback","when calling error in ClosureForGroups, line 4")
else
call q1("Called ForGroupCallback.callback on invalid object.","when calling error in ClosureForGroups, line 4")
endif
endif
if nO[snw]<=690 then
if nO[snw]<=689 then
if nO[snw]<=688 then
call fSw(snw,tnw,"when calling City_City_callback_line313 in ClosureForGroups, line 4")
else
call GSw(snw,tnw)
endif
else
set Cb[Xb]="when calling LinkedList_callback_line514 in ClosureForGroups, line 4"
set Xb=Xb+1
call Ndw(fb[snw],GetHandleId(tnw),"when calling add in LinkedList, line 515")
set Xb=Xb-1
endif
elseif nO[snw]<=691 then
call iyw(snw,tnw,"when calling MassControl_callback_line27 in ClosureForGroups, line 4")
else
call RemoveUnit(tnw)
endif
set Xb=Xb-1
endfunction
function KFw takes nothing returns nothing
local unit JFw
set Xb=0
set Cb[Xb]="ClosureForGroups, line 14"
set Xb=Xb+1
set JFw=GetFilterUnit()
set Cb[Xb]="when calling filterCallback in ClosureForGroups, line 14"
set Xb=Xb+1
if HS<DS then
call Snw(PS[AS-1],JFw,"when calling callback in ClosureForGroups, line 18")
endif
set HS=HS+1
set Xb=Xb-1-1
set JFw=null
endfunction
function KH takes nothing returns nothing
local integer UH=1
local integer IH=1751868773
local player PH=GetOwningPlayer(GetTriggerUnit())
local rect JH=bj_mapInitialPlayableArea
local location HH=Location(GetRectCenterX(JH),GetRectCenterY(JH))
local location AH=Location(GetLocationX(HH)+100000000.00,GetLocationY(HH)+100000000.00)
local real DH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set UH=UH-1
exitwhen UH<0
call CreateUnitAtLocSaveLast(PH,IH,AH,DH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set PH=null
set AH=null
set HH=null
set JH=null
endfunction
function JL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990328 then
return false
endif
return true
endfunction
function KL takes nothing returns boolean
if not JL() then
return false
endif
return true
endfunction
function KP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989825,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989817,0)
endfunction
function JT takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989043 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function KT takes nothing returns boolean
if not JT() then
return false
endif
return true
endfunction
function JU takes nothing returns boolean
if GetResearched()!=1378890033 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890033,true)!=1 then
return false
endif
return true
endfunction
function KU takes nothing returns boolean
if not JU() then
return false
endif
return true
endfunction
function KW takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,Ee)
endfunction
function KY takes nothing returns nothing
local unit HY=GetSpellTargetUnit()
local unitstate JY=UNIT_STATE_MANA
call SetUnitState(HY,UNIT_STATE_MANA,RMaxBJ(0.,GetUnitState(GetSpellTargetUnit(),JY)-600.00))
set HY=null
set JY=null
endfunction
function KZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989582,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989583,0)
endfunction
function Kv takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988788,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988535,0)
endfunction
function KE takes nothing returns boolean
if GetResearched()!=1378889806 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889806,true)!=2 then
return false
endif
return true
endfunction
function LE takes nothing returns boolean
if not KE() then
return false
endif
return true
endfunction
function Rrw takes string nrw returns integer
local integer drw=0
local integer frw=23
loop
exitwhen drw>frw
if GetPlayerName(wo[drw])==nrw then
return drw
endif
set drw=drw+1
endloop
return -1
endfunction
function lrw takes nothing returns integer
local integer irw=0
local integer Srw=0
local integer crw=23
local player orw
local boolean Orw
loop
exitwhen Srw>crw
set orw=wo[Srw]
if GetPlayerSlotState(orw)==PLAYER_SLOT_STATE_PLAYING then
set Orw=GetPlayerController(orw)==MAP_CONTROL_USER
else
set Orw=false
endif
if Orw then
set irw=irw+1
endif
set Srw=Srw+1
endloop
set orw=null
return R2I((irw-1)*1./2)+1
endfunction
function arw takes integer brw returns nothing
local string yrw
local force prw
local string erw
local force qrw
if brw<0 then
set prw=null
set qrw=null
return
endif
if wO[brw]>=lrw() then
call CustomDefeatBJ(wo[brw],"You've been kicked from the game!")
set yrw="The player "+hB(wo[brw])+" has been kicked with the power of democracy!"
set prw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),prw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,yrw)
endif
else
set erw=I2S(wO[brw])+" |cffff0000out of|r "+I2S(lrw())+" |cffff0000voted to kick the player|r "+hB(wo[brw])+"! |cff00ffdd(player number is "+I2S(brw)+")|r"
set qrw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),qrw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,erw)
endif
endif
set prw=null
set qrw=null
endfunction
function grw takes integer Trw,player Yrw,string Grw returns nothing
set Cb[Xb]=Grw
set Xb=Xb+1
if Trw<0 then
set Xb=Xb-1
return
endif
if not Knw(uO[Trw],GetPlayerId(Yrw),"when calling has in VoteKick, line 68") then
set wO[Trw]=wO[Trw]+1
endif
set Xb=Xb-1
endfunction
function pbw takes integer Obw,integer lbw returns integer
local integer bbw=Yb[kb[Obw]]
local integer ybw=0
loop
exitwhen bbw==kb[Obw]
if Rb[bbw]==lbw then
return ybw
endif
set bbw=Yb[bbw]
set ybw=ybw+1
endloop
return -1
endfunction
function Irw takes player hrw,string Frw,string krw returns nothing
local integer jrw
local integer xrw
local integer vrw
local boolean mrw
local integer Qrw
local integer Wrw
local integer Erw
local boolean Zrw
local boolean Urw
set Cb[Xb]=krw
set Xb=Xb+1
if StringLength(Frw)<=2 then
set Zrw=S2I(Frw)>0
else
set Zrw=false
endif
if Zrw then
set Urw=S2I(Frw)<24
else
set Urw=false
endif
if Urw then
set jrw=S2I(Frw)
else
set xrw=rO
set vrw=lww(Frw,"when calling stringToIndex in VoteKick, line 77")
set Cb[Xb]="when calling has in VoteKick, line 77"
set Xb=Xb+1
if Sl[xrw]==0 then
if xrw==0 then
call q1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call q1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set mrw=nbw(xrw,vrw)
set Xb=Xb-1
if mrw then
set Qrw=rO
set Wrw=lww(Frw,"when calling stringToIndex in VoteKick, line 78")
set Cb[Xb]="when calling indexOf in VoteKick, line 78"
set Xb=Xb+1
if Sl[Qrw]==0 then
if Qrw==0 then
call q1("Nullpointer exception when calling LinkedList.indexOf","when calling error in LinkedList, line 54")
else
call q1("Called LinkedList.indexOf on invalid object.","when calling error in LinkedList, line 54")
endif
endif
set Erw=pbw(Qrw,Wrw)
set Xb=Xb-1
set jrw=Erw
elseif Rrw(Frw)!=-1 then
set jrw=Rrw(Frw)
else
set Cb[Xb]="when calling noteToPlayer in VoteKick, line 82"
set Xb=Xb+1
call DisplayTimedTextToPlayer(hrw,0.,0.,10.0,N2(hrw,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(hrw,0.,0.,10.0,"Couldn't find player: '"+Frw+"'")
set Xb=Xb-1-1
return
endif
endif
call grw(jrw,hrw,"when calling addVote in VoteKick, line 85")
call arw(jrw)
set Xb=Xb-1
endfunction
function O2 takes player i2 returns nothing
local fogstate S2
local location c2
local rect o2
call SetPlayerState(i2,PLAYER_STATE_RESOURCE_GOLD,99999999)
call SetPlayerState(i2,PLAYER_STATE_RESOURCE_LUMBER,99999999)
set S2=FOG_OF_WAR_VISIBLE
set o2=bj_mapInitialPlayableArea
set c2=Location(GetRectCenterX(o2),GetRectCenterY(o2))
set bj_lastCreatedFogModifier=CreateFogModifierRadiusLoc(i2,S2,c2,999999.00,true,false)
call FogModifierStart(bj_lastCreatedFogModifier)
set S2=null
set c2=null
set o2=null
endfunction
function daw takes integer qaw,string aaw,string naw returns nothing
set Cb[Xb]=naw
set Xb=Xb+1
if pO[qaw]==0 then
if qaw==0 then
call q1("Nullpointer exception when calling City.changeCityName","when calling error in City, line 171")
else
call q1("Called City.changeCityName on invalid object.","when calling error in City, line 171")
endif
endif
set Cb[Xb]="when calling changeCityName in City, line 171"
set Xb=Xb+1
set vl[qaw]=SubString(aaw,0,24)
set Cb[Xb]="when calling refreshMultiboardIfPossible in City, line 174"
set Xb=Xb+1
if pO[qaw]==0 then
if qaw==0 then
call q1("Nullpointer exception when calling City.refreshMultiboardIfPossible","when calling error in City, line 250")
else
call q1("Called City.refreshMultiboardIfPossible on invalid object.","when calling error in City, line 250")
endif
endif
call itw(qaw,"when calling refreshMultiboardIfPossible in City, line 250")
set Xb=Xb-1-1-1
endfunction
function vew takes integer eew,string qew returns nothing
local integer aew
local integer dew
local integer few
local integer Rew
local player Tew
local integer Yew
local integer Gew
local player gew
local integer hew
local player Few
local fogstate kew
local location jew
local rect xew
set Cb[Xb]=qew
set Xb=Xb+1
set Jb[eew]=true
set aew=GetPlayerId(Pb[eew])
set dew=0
set few=23
loop
exitwhen dew>few
set Rew=Mc[dew]
set Tew=Pb[eew]
set Yew=bj_ALLIANCE_UNALLIED
set qew="when calling setAlliance in PlayerStats, line 37"
set Cb[Xb]="when calling setAlliance in PlayerStats, line 37"
set Xb=Xb+1
if yl[Rew]==0 then
if Rew==0 then
call q1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call q1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Uew(Rew,Tew,Yew,"when calling setAlliance in PlayerStats, line 55")
set Xb=Xb-1
set Gew=Mc[aew]
set gew=wo[dew]
set hew=bj_ALLIANCE_UNALLIED
set Cb[Xb]="when calling setAlliance in PlayerStats, line 38"
set Xb=Xb+1
if yl[Gew]==0 then
if Gew==0 then
call q1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call q1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Uew(Gew,gew,hew,"when calling setAlliance in PlayerStats, line 55")
set Xb=Xb-1
set dew=dew+1
endloop
set Few=Pb[eew]
set kew=FOG_OF_WAR_VISIBLE
set xew=bj_mapInitialPlayableArea
set jew=Location(GetRectCenterX(xew),GetRectCenterY(xew))
set bj_lastCreatedFogModifier=CreateFogModifierRadiusLoc(Few,kew,jew,999999.00,true,false)
call FogModifierStart(bj_lastCreatedFogModifier)
set Xb=Xb-1
set Tew=null
set gew=null
set Few=null
set kew=null
set jew=null
set xew=null
endfunction
function HN takes string LB returns nothing
local string XB
local string array CB
local player VB
local integer BB
local integer NB
local integer MB
local string wN
local string uN
local integer rN
local boolean sN
local group tN
local player iN
local camerafield SN
local player cN
local camerafield oN
local integer ON
local integer lN
local integer bN
local unit yN
local integer pN
local integer eN
local integer qN
local integer aN
local integer nN
local integer dN
local integer fN
local integer RN
local integer TN
local integer YN
local integer GN
local player gN
local camerafield hN
local real FN
local integer kN
local boolean jN
local group xN
local unit vN
local integer mN
local string QN
local force WN
local integer EN
local integer ZN
local integer UN
local real IN
local boolean PN
local boolean AN
local boolean DN
set Cb[Xb]=LB
set Xb=Xb+1
set XB=GetEventPlayerChatString()
set LB=""
set VB=GetTriggerPlayer()
set BB=0
set NB=1
set MB=StringLength(XB)
loop
exitwhen NB>MB
set wN=SubString(XB,NB,NB+1)
if BB>0 then
set PN=NB>StringLength(CB[0])+1
else
set PN=false
endif
if PN then
set LB=LB+wN
endif
if wN!=" " then
set CB[BB]=CB[BB]+wN
else
set BB=BB+1
endif
set NB=NB+1
endloop
if CB[0]=="far" then
set iN=GetTriggerPlayer()
set SN=CAMERA_FIELD_TARGET_DISTANCE
if GetLocalPlayer()==iN then
call SetCameraField(SN,3000.0,0.)
endif
elseif CB[0]=="med" then
set cN=GetTriggerPlayer()
set oN=CAMERA_FIELD_TARGET_DISTANCE
if GetLocalPlayer()==cN then
call SetCameraField(oN,2300.0,0.)
endif
elseif CB[0]=="name" then
call SetPlayerName(GetTriggerPlayer(),SubString(LB,0,40))
elseif CB[0]=="rename" then
set ON=Mc[GetPlayerId(VB)]
set Cb[Xb]="when calling getSelectedCityId in Commands, line 51"
set Xb=Xb+1
if yl[ON]==0 then
if ON==0 then
call q1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call q1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set lN=Db[ON]
set Xb=Xb-1
if lN>=0 and lN<nS then
set bN=hS[lN]
set Cb[Xb]="when calling getCityUnit in Commands, line 53"
set Xb=Xb+1
if pO[bN]==0 then
if bN==0 then
call q1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call q1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set yN=xl[bN]
set Xb=Xb-1
if GetOwningPlayer(yN)!=VB then
set Cb[Xb]="when calling noteToPlayer in Commands, line 54"
set Xb=Xb+1
call DisplayTimedTextToPlayer(VB,0.,0.,10.0,N2(VB,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(VB,0.,0.,10.0,"The city you wanted to rename so eagerly doesn't belong to you!")
set Xb=Xb-1
else
call daw(hS[lN],LB,"when calling changeCityName in Commands, line 56")
endif
endif
elseif CB[0]=="add_mod" then
set pN=Mc[GetPlayerId(VB)]
set Cb[Xb]="when calling getSelectedCityId in Commands, line 58"
set Xb=Xb+1
if yl[pN]==0 then
if pN==0 then
call q1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call q1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set eN=Db[pN]
set Xb=Xb-1
if not gc then
set Xb=Xb-1
set VB=null
set tN=null
set iN=null
set SN=null
set cN=null
set oN=null
set yN=null
set gN=null
set hN=null
set xN=null
set vN=null
set WN=null
return
endif
if eN>=0 and eN<nS then
set uN=CB[1]
if uN=="massacred_pop" then
set qN=hS[eN]
set Cb[Xb]="when calling addModifier in Commands, line 64"
set Xb=Xb+1
if pO[qN]==0 then
if qN==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(qN,6,"when calling addModifier in City, line 368")
set Xb=Xb-1
elseif uN=="recently_conquered" then
set aN=hS[eN]
set Cb[Xb]="when calling addModifier in Commands, line 66"
set Xb=Xb+1
if pO[aN]==0 then
if aN==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(aN,0,"when calling addModifier in City, line 368")
set Xb=Xb-1
elseif uN=="recently_revolted" then
set nN=hS[eN]
set Cb[Xb]="when calling addModifier in Commands, line 68"
set Xb=Xb+1
if pO[nN]==0 then
if nN==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(nN,1,"when calling addModifier in City, line 368")
set Xb=Xb-1
elseif uN=="more_trade_estabilished" then
set dN=hS[eN]
set Cb[Xb]="when calling addModifier in Commands, line 70"
set Xb=Xb+1
if pO[dN]==0 then
if dN==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(dN,5,"when calling addModifier in City, line 368")
set Xb=Xb-1
elseif uN=="on_fire" then
set fN=hS[eN]
set Cb[Xb]="when calling addModifier in Commands, line 72"
set Xb=Xb+1
if pO[fN]==0 then
if fN==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(fN,4,"when calling addModifier in City, line 368")
set Xb=Xb-1
elseif uN=="plague_outburst" then
set RN=hS[eN]
set Cb[Xb]="when calling addModifier in Commands, line 74"
set Xb=Xb+1
if pO[RN]==0 then
if RN==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(RN,3,"when calling addModifier in City, line 368")
set Xb=Xb-1
elseif uN=="population_boom" then
set TN=hS[eN]
set Cb[Xb]="when calling addModifier in Commands, line 76"
set Xb=Xb+1
if pO[TN]==0 then
if TN==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(TN,2,"when calling addModifier in City, line 368")
set Xb=Xb-1
elseif uN=="prospering" then
set YN=hS[eN]
set Cb[Xb]="when calling addModifier in Commands, line 78"
set Xb=Xb+1
if pO[YN]==0 then
if YN==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(YN,7,"when calling addModifier in City, line 368")
set Xb=Xb-1
elseif uN=="sieged" then
set GN=hS[eN]
set Cb[Xb]="when calling addModifier in Commands, line 80"
set Xb=Xb+1
if pO[GN]==0 then
if GN==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(GN,8,"when calling addModifier in City, line 368")
set Xb=Xb-1
endif
endif
elseif CB[0]=="непереводимоесочетаниебукв" then
set gc=not gc
set Gc=not Gc
call O2(VB)
elseif CB[0]=="votekick" then
call Irw(VB,LB,"when calling voteKick in Commands, line 86")
elseif CB[0]=="zoom" then
set rN=S2I(CB[1])
set gN=GetTriggerPlayer()
set hN=CAMERA_FIELD_TARGET_DISTANCE
set FN=rN*1.
if GetLocalPlayer()==gN then
call SetCameraField(hN,FN,0.)
endif
elseif CB[0]=="observe" then
set kN=Mc[GetPlayerId(VB)]
set Cb[Xb]="when calling isObserver in Commands, line 91"
set Xb=Xb+1
if yl[kN]==0 then
if kN==0 then
call q1("Nullpointer exception when calling PlayerStats.isObserver","when calling error in PlayerStats, line 29")
else
call q1("Called PlayerStats.isObserver on invalid object.","when calling error in PlayerStats, line 29")
endif
endif
set jN=Jb[kN]
set Xb=Xb-1
if not jN then
set sN=true
set xN=CreateGroup()
call GroupEnumUnitsOfPlayer(xN,VB,null)
call DestroyBoolExpr(null)
set qc=CreateGroup()
call ForGroup(xN,Pf)
set tN=qc
loop
exitwhen FirstOfGroup(tN)==null
set vN=FirstOfGroup(tN)
call GroupRemoveUnit(tN,vN)
if not IsUnitHidden(vN) then
set AN=GetUnitTypeId(vN)!=1211118391
else
set AN=false
endif
if AN then
set DN=GetUnitTypeId(vN)!=1211118406
else
set DN=false
endif
if DN then
set sN=false
endif
endloop
call GroupClear(tN)
call DestroyGroup(tN)
if sN then
set mN=Mc[GetPlayerId(VB)]
set Cb[Xb]="when calling becomeObserver in Commands, line 98"
set Xb=Xb+1
if yl[mN]==0 then
if mN==0 then
call q1("Nullpointer exception when calling PlayerStats.becomeObserver","when calling error in PlayerStats, line 32")
else
call q1("Called PlayerStats.becomeObserver on invalid object.","when calling error in PlayerStats, line 32")
endif
endif
call vew(mN,"when calling becomeObserver in PlayerStats, line 32")
set Xb=Xb-1
set QN=hB(VB)+" has just became an observer."
set WN=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),WN) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,QN)
endif
else
set Cb[Xb]="when calling noteToPlayer in Commands, line 101"
set Xb=Xb+1
call DisplayTimedTextToPlayer(VB,0.,0.,10.0,N2(VB,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(VB,0.,0.,10.0,"To become an observer, you should have no units!")
set Xb=Xb-1
endif
endif
elseif CB[0]=="add_po" then
if not gc then
set Xb=Xb-1
set VB=null
set tN=null
set iN=null
set SN=null
set cN=null
set oN=null
set yN=null
set gN=null
set hN=null
set xN=null
set vN=null
set WN=null
return
endif
set EN=Mc[GetPlayerId(VB)]
set Cb[Xb]="when calling getSelectedCityId in Commands, line 105"
set Xb=Xb+1
if yl[EN]==0 then
if EN==0 then
call q1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call q1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set ZN=Db[EN]
set Xb=Xb-1
if ZN>=0 and ZN<nS then
set UN=hS[ZN]
set IN=S2R(CB[1])
set Cb[Xb]="when calling addPublicOrder in Commands, line 107"
set Xb=Xb+1
if pO[UN]==0 then
if UN==0 then
call q1("Nullpointer exception when calling City.addPublicOrder","when calling error in City, line 332")
else
call q1("Called City.addPublicOrder on invalid object.","when calling error in City, line 332")
endif
endif
set Dl[UN]=Dl[UN]+IN
set Xb=Xb-1
endif
else
set Cb[Xb]="when calling noteToPlayer in Commands, line 109"
set Xb=Xb+1
call DisplayTimedTextToPlayer(VB,0.,0.,10.0,N2(VB,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(VB,0.,0.,10.0,"Couldn't find command: '"+CB[0]+"'")
set Xb=Xb-1
endif
set Xb=Xb-1
set VB=null
set tN=null
set iN=null
set SN=null
set cN=null
set oN=null
set yN=null
set gN=null
set hN=null
set xN=null
set vN=null
set WN=null
endfunction
function LFw takes nothing returns nothing
set Xb=0
call HN("Commands, line 118")
endfunction
function LL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function LU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989828,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989827,0)
endfunction
function gqw takes string Yqw returns integer
local integer Gqw
set Cb[Xb]=Yqw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_Table in Table, line 5"
set Xb=Xb+1
if IO==0 then
if PO<32768 then
set PO=PO+1
set Gqw=PO
set AO[Gqw]=731
else
call q1("Out of memory: Could not create Table.","when calling error in Table, line 6")
set Gqw=0
endif
else
set IO=IO-1
set Gqw=UO[IO]
set AO[Gqw]=731
endif
set Xb=Xb-1-1
return Gqw
endfunction
function initializeTable takes string stackPos returns nothing
local integer i_2
local integer this
local integer parentKey
set Cb[Xb]=stackPos
set Xb=Xb+1
set i_2=0
loop
exitwhen i_2>15
set this=BS
set parentKey=StringHash(VS[i_2])
set stackPos="when calling saveInt in Colors, line 206"
set Cb[Xb]="when calling saveInt in Colors, line 206"
set Xb=Xb+1
if AO[this]==0 then
if this==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,this,parentKey,i_2)
set Xb=Xb-1
set i_2=i_2+1
endloop
set Xb=Xb-1
endfunction
function nB takes string aB returns boolean
set Cb[Xb]=aB
set Xb=Xb+1
set LS[0]=255
set XS[0]=2
set CS[0]=2
set LS[1]=0
set XS[1]=65
set CS[1]=255
set LS[2]=27
set XS[2]=229
set CS[2]=184
set LS[3]=83
set XS[3]=0
set CS[3]=128
set LS[4]=255
set XS[4]=252
set CS[4]=0
set LS[5]=254
set XS[5]=137
set CS[5]=13
set LS[6]=31
set XS[6]=191
set CS[6]=0
set LS[7]=228
set XS[7]=90
set CS[7]=175
set LS[8]=148
set XS[8]=149
set CS[8]=150
set LS[9]=125
set XS[9]=190
set CS[9]=241
set LS[10]=15
set XS[10]=97
set CS[10]=69
set LS[11]=77
set XS[11]=41
set CS[11]=3
set LS[12]=155
set XS[12]=0
set CS[12]=0
set LS[13]=0
set XS[13]=0
set CS[13]=195
set LS[14]=0
set XS[14]=234
set CS[14]=255
set LS[15]=190
set XS[15]=0
set CS[15]=254
set LS[16]=235
set XS[16]=205
set CS[16]=135
set LS[17]=248
set XS[17]=164
set CS[17]=139
set LS[18]=191
set XS[18]=255
set CS[18]=128
set LS[19]=220
set XS[19]=185
set CS[19]=235
set LS[20]=40
set XS[20]=40
set CS[20]=40
set LS[21]=235
set XS[21]=240
set CS[21]=255
set LS[22]=0
set XS[22]=120
set CS[22]=30
set LS[23]=164
set XS[23]=11
set CS[23]=51
set VS[0]="0"
set VS[1]="1"
set VS[2]="2"
set VS[3]="3"
set VS[4]="4"
set VS[5]="5"
set VS[6]="6"
set VS[7]="7"
set VS[8]="8"
set VS[9]="9"
set VS[10]="A"
set VS[11]="B"
set VS[12]="C"
set VS[13]="D"
set VS[14]="E"
set VS[15]="F"
set BS=gqw("when calling new_Table in Colors, line 154")
call initializeTable("when calling initializeTable in Colors, line 209")
set Xb=Xb-1
return true
endfunction
function Lhw takes nothing returns boolean
set Xb=0
return nB("Colors, line 1")
endfunction
function Kqw takes integer Jqw returns nothing
set Do[Ho]=Lb[Jqw]
set Ho=Ho+1
call TriggerEvaluate(Ao)
set Ho=Ho-1
call SetUnitUserData(Lb[Jqw],0)
endfunction
function Ldw takes integer Jdw,string Kdw returns nothing
set Cb[Xb]=Kdw
set Xb=Xb+1
if fl[Jdw]==0 then
if Jdw==0 then
call q1("Nullpointer exception when calling UnitIndex.UnitIndex","when calling error in UnitIndexer, line 172")
else
call q1("Called UnitIndex.UnitIndex on invalid object.","when calling error in UnitIndexer, line 172")
endif
endif
set Cb[Xb]="when calling destroyUnitIndex in UnitIndexer, line 172"
set Xb=Xb+1
call Kqw(Jdw)
set Cb[Xb]="when calling dealloc_UnitIndex in UnitIndexer, line 188"
set Xb=Xb+1
if fl[Jdw]==0 then
call q1("Double free: object of type UnitIndex","when calling error in UnitIndexer, line 172")
else
set al[nl]=Jdw
set nl=nl+1
set fl[Jdw]=0
endif
set Xb=Xb-1-1-1
endfunction
function Hqw takes integer Aqw,unit Dqw returns nothing
set Lb[Aqw]=Dqw
call SetUnitUserData(Lb[Aqw],Aqw)
set Do[Ho]=Dqw
set Ho=Ho+1
call TriggerEvaluate(Po)
set Ho=Ho-1
endfunction
function Pqw takes unit Zqw,string Uqw returns integer
local integer Iqw
set Cb[Xb]=Uqw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_UnitIndex in UnitIndexer, line 181"
set Xb=Xb+1
if nl==0 then
if dl<32768 then
set dl=dl+1
set Iqw=dl
set fl[Iqw]=741
else
call q1("Out of memory: Could not create UnitIndex.","when calling error in UnitIndexer, line 172")
set Iqw=0
endif
else
set nl=nl-1
set Iqw=al[nl]
set fl[Iqw]=741
endif
set Xb=Xb-1
call Hqw(Iqw,Zqw)
set Xb=Xb-1
return Iqw
endfunction
function Pww takes unit Zww,string Uww returns boolean
local integer Iww_2
set Cb[Xb]=Uww
set Xb=Xb+1
if GetUnitUserData(Zww)==0 then
set Xb=Xb-1
return false
else
set Cb[Xb]="when calling toUnitIndex in UnitIndexer, line 169"
set Xb=Xb+1
set Iww_2=GetUnitUserData(Zww)
if Iww_2==0 then
set Iww_2=Pqw(Zww,"when calling new_UnitIndex in UnitIndexer, line 135")
endif
set Xb=Xb-1
call Ldw(Iww_2,"when calling dispatch_UnitIndex_destroyUnitIndex in UnitIndexer, line 169")
set Xb=Xb-1
return true
endif
endfunction
function Kww takes string Jww returns nothing
set Cb[Xb]=Jww
set Xb=Xb+1
call Pww(Bc[Nc-1],"when calling deindex in UnitIndexer, line 197")
set Xb=Xb-1
endfunction
function MFw takes nothing returns nothing
set Xb=0
call Kww("UnitIndexer, line 197")
endfunction
function NL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988531 then
return false
endif
return true
endfunction
function ML takes nothing returns boolean
if not NL() then
return false
endif
return true
endfunction
function MP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990607,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990583,0)
endfunction
function NU takes nothing returns boolean
if GetResearched()!=1378890033 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890033,true)!=2 then
return false
endif
return true
endfunction
function MU takes nothing returns boolean
if not NU() then
return false
endif
return true
endfunction
function KOw takes string HOw returns integer
local integer JOw
set Cb[Xb]=HOw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_HashMap in HashMap, line 7"
set Xb=Xb+1
if IO==0 then
if PO<32768 then
set PO=PO+1
set JOw=PO
set AO[JOw]=732
else
call q1("Out of memory: Could not create HashMap.","when calling error in HashMap, line 8")
set JOw=0
endif
else
set IO=IO-1
set JOw=UO[IO]
set AO[JOw]=732
endif
set Xb=Xb-1
set qb[JOw]=0
set Xb=Xb-1
return JOw
endfunction
function Mhw takes nothing returns boolean
set Xb=0
set Cb[Xb]="RegisterEvents, line 1"
set Xb=Xb+1
set po=KOw("when calling new_HashMap in RegisterEvents, line 55")
call g0w(EVENT_PLAYER_UNIT_SPELL_EFFECT,null,iR,null)
set Xb=Xb-1
return true
endfunction
function Mv takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988561,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988784,0)
endfunction
function VF takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function BF takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988801 then
return false
endif
if not VF() then
return false
endif
return true
endfunction
function NF takes nothing returns boolean
if not BF() then
return false
endif
return true
endfunction
function Hww takes string Aww returns nothing
local unit Dww
set Cb[Xb]=Aww
set Xb=Xb+1
set Dww=Bc[Nc-1]
set Cb[Xb]="when calling toUnitIndex in UnitIndexer, line 196"
set Xb=Xb+1
if GetUnitUserData(Dww)==0 then
call Pqw(Dww,"when calling new_UnitIndex in UnitIndexer, line 135")
endif
set Xb=Xb-1-1
set Dww=null
endfunction
function NFw takes nothing returns nothing
set Xb=0
call Hww("UnitIndexer, line 196")
endfunction
function BH takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())==1747988531 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990328 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747989592 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990086 then
return true
endif
return false
endfunction
function NH takes nothing returns boolean
if not BH() then
return false
endif
return true
endfunction
function BP takes nothing returns boolean
if GetResearched()!=1378890051 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890051,true)!=2 then
return false
endif
return true
endfunction
function NP takes nothing returns boolean
if not BP() then
return false
endif
return true
endfunction
function NT takes nothing returns nothing
local player LT=GetOwningPlayer(GetAttacker())
local player XT=GetOwningPlayer(GetAttacker())
local player CT
local player VT
local unit BT
set r[GetPlayerId(LT)+1]=r[GetPlayerId(XT)+1]+1
set CT=GetOwningPlayer(GetTriggerUnit())
set VT=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(CT)+1]=r[GetPlayerId(VT)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set BT=GetTriggerUnit()
call SetUnitState(BT,UNIT_STATE_LIFE,GetUnitState(BT,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set LT=null
set XT=null
set CT=null
set VT=null
set BT=null
endfunction
function NX takes nothing returns boolean
local boolean VX
local boolean BX
if GetUnitTypeId(GetSpellAbilityUnit())==1747988553 then
set VX=GetUnitTypeId(GetSpellTargetUnit())==1747989297
else
set VX=false
endif
if VX then
set BX=GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))==PLAYER_NEUTRAL_AGGRESSIVE
else
set BX=false
endif
return BX
endfunction
function NY takes nothing returns nothing
set t=GetUnitLoc(GetSpellTargetUnit())
set bj_lastCreatedEffect=AddSpecialEffectLoc("Abilities\\Spells\\Orc\\Voodoo\\VoodooAuraTarget.mdl",t)
call DestroyEffect(bj_lastCreatedEffect)
set i=GetUnitLoc(GetSpellAbilityUnit())
set bj_lastCreatedEffect=AddSpecialEffectLoc("Abilities\\Spells\\Orc\\Voodoo\\VoodooAura.mdl",i)
call DestroyEffect(bj_lastCreatedEffect)
call RemoveLocation(t)
call RemoveLocation(i)
endfunction
function NZ takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,qq)
endfunction
function Nhw takes nothing returns boolean
set Xb=0
set Cb[Xb]="EventHelper, line 1"
set Xb=Xb+1
call KOw("when calling new_HashMap in EventHelper, line 6")
call KOw("when calling new_HashMap in EventHelper, line 7")
call gqw("when calling new_Table in EventHelper, line 8")
set Xb=Xb-1
return true
endfunction
function Bv takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function Nv takes nothing returns boolean
if not Bv() then
return false
endif
return true
endfunction
function oE takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function OE takes nothing returns boolean
if not oE() then
return false
endif
return true
endfunction
function OL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function OU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989814,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989825,0)
endfunction
function OW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988818,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988552,0)
endfunction
function PE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989559,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989569,0)
endfunction
function Juw takes string Quw returns boolean
local trigger Wuw
local playerunitevent Euw
local playerunitevent Zuw
local integer Uuw
local integer Iuw
local rect Puw
local region Auw
local integer Duw
local integer Huw
set Cb[Xb]=Quw
set Xb=Xb+1
set Euw=EVENT_PLAYER_UNIT_SPELL_FINISH
set Cb[Xb]="when calling alloc_Upkeep_EventListener_line6 in Upkeep, line 6"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set Uuw=iO
set SO[Uuw]=684
else
call q1("Out of memory: Could not create Upkeep_EventListener_line6.","when calling error in Upkeep, line 6")
set Uuw=0
endif
else
set tO=tO-1
set Uuw=sO[tO]
set SO[Uuw]=684
endif
set Xb=Xb-1
set ub[Uuw]=0
set rb[Uuw]=0
set sb[Uuw]=0
set Cb[Xb]="when calling add in Upkeep, line 6"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set Iuw=vS[GetHandleId(Euw)]
if Iuw==0 then
set Iuw=aV(Euw,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[Uuw]=Iuw
if ES[ub[Uuw]]!=0 then
set sb[ES[ub[Uuw]]]=Uuw
set rb[Uuw]=ES[ub[Uuw]]
endif
set ES[ub[Uuw]]=Uuw
set Xb=Xb-1
set Wuw=CreateTrigger()
set Puw=GetWorldBounds()
set Auw=CreateRegion()
call RegionAddRect(Auw,Puw)
call TriggerRegisterEnterRegion(Wuw,Auw,null)
call TriggerAddAction(Wuw,Cf)
set Zuw=EVENT_PLAYER_UNIT_DEATH
set Cb[Xb]="when calling alloc_Upkeep_EventListener_line28 in Upkeep, line 28"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set Duw=iO
set SO[Duw]=683
else
call q1("Out of memory: Could not create Upkeep_EventListener_line28.","when calling error in Upkeep, line 28")
set Duw=0
endif
else
set tO=tO-1
set Duw=sO[tO]
set SO[Duw]=683
endif
set Xb=Xb-1
set ub[Duw]=0
set rb[Duw]=0
set sb[Duw]=0
set Cb[Xb]="when calling add in Upkeep, line 28"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set Huw=vS[GetHandleId(Zuw)]
if Huw==0 then
set Huw=aV(Zuw,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[Duw]=Huw
if ES[ub[Duw]]!=0 then
set sb[ES[ub[Duw]]]=Duw
set rb[Duw]=ES[ub[Duw]]
endif
set ES[ub[Duw]]=Duw
set Xb=Xb-1-1
set Wuw=null
set Euw=null
set Zuw=null
set Puw=null
set Auw=null
return true
endfunction
function PFw takes nothing returns boolean
set Xb=0
return Juw("Upkeep, line 1")
endfunction
function IK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988809 then
return false
endif
return true
endfunction
function PK takes nothing returns boolean
if not IK() then
return false
endif
return true
endfunction
function IQ takes nothing returns boolean
if GetResearched()!=1378889799 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889799,true)!=2 then
return false
endif
return true
endfunction
function PQ takes nothing returns boolean
if not IQ() then
return false
endif
return true
endfunction
function Prw takes nothing returns boolean
return true
endfunction
function hlw takes string Glw returns integer
local integer glw
set Cb[Xb]=Glw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_HashSet in HashSet, line 4"
set Xb=Xb+1
if WO==0 then
if EO<32768 then
set EO=EO+1
set glw=EO
set ZO[glw]=696
else
call q1("Out of memory: Could not create HashSet.","when calling error in HashSet, line 5")
set glw=0
endif
else
set WO=WO-1
set glw=QO[WO]
set ZO[glw]=696
endif
set Xb=Xb-1
set eb[glw]=0
set Xb=Xb-1
return glw
endfunction
function r9 takes string N8 returns boolean
local playerunitevent M8
local integer w9
local integer u9
set Cb[Xb]=N8
set Xb=Xb+1
set Xc=hlw("when calling new_HashSet in NoStarvationOnBoat, line 6")
set M8=EVENT_PLAYER_UNIT_ISSUED_ORDER
set Cb[Xb]="when calling alloc_NoStarvationOnBoat_EventListener_line9 in NoStarvationOnBoat, line 9"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set w9=iO
set SO[w9]=676
else
call q1("Out of memory: Could not create NoStarvationOnBoat_EventListener_line9.","when calling error in NoStarvationOnBoat, line 9")
set w9=0
endif
else
set tO=tO-1
set w9=sO[tO]
set SO[w9]=676
endif
set Xb=Xb-1
set ub[w9]=0
set rb[w9]=0
set sb[w9]=0
set Cb[Xb]="when calling add in NoStarvationOnBoat, line 9"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set u9=vS[GetHandleId(M8)]
if u9==0 then
set u9=aV(M8,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[w9]=u9
if ES[ub[w9]]!=0 then
set sb[ES[ub[w9]]]=w9
set rb[w9]=ES[ub[w9]]
endif
set ES[ub[w9]]=w9
set Xb=Xb-1-1
set M8=null
return true
endfunction
function QFw takes nothing returns boolean
set Xb=0
return r9("NoStarvationOnBoat, line 1")
endfunction
function QK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function QQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988559,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989064,0)
endfunction
function Qww takes nothing returns boolean
return true
endfunction
function a9 takes unit q9 returns nothing
call UnitAddAbility(q9,1095577649)
call UnitMakeAbilityPermanent(q9,true,1095577649)
set Bc[Nc]=q9
set Nc=Nc+1
call TriggerEvaluate(Cc)
set Nc=Nc-1
endfunction
function R9 takes nothing returns nothing
call a9(GetEnumUnit())
endfunction
function RA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990595,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990608,0)
endfunction
function wV takes string VC returns boolean
local playerunitevent BC
local integer NC
local integer MC
set Cb[Xb]=VC
set Xb=Xb+1
set BC=EVENT_PLAYER_UNIT_SPELL_CAST
set Cb[Xb]="when calling alloc_Clerics_EventListener_line5 in Clerics, line 5"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set NC=iO
set SO[NC]=667
else
call q1("Out of memory: Could not create Clerics_EventListener_line5.","when calling error in Clerics, line 5")
set NC=0
endif
else
set tO=tO-1
set NC=sO[tO]
set SO[NC]=667
endif
set Xb=Xb-1
set ub[NC]=0
set rb[NC]=0
set sb[NC]=0
set Cb[Xb]="when calling add in Clerics, line 5"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set MC=vS[GetHandleId(BC)]
if MC==0 then
set MC=aV(BC,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[NC]=MC
if ES[ub[NC]]!=0 then
set sb[ES[ub[NC]]]=NC
set rb[NC]=ES[ub[NC]]
endif
set ES[ub[NC]]=NC
set Xb=Xb-1-1
set BC=null
return true
endfunction
function RFw takes nothing returns boolean
set Xb=0
return wV("Clerics, line 1")
endfunction
function fI takes nothing returns boolean
if GetResearched()!=1378890036 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890036,true)!=1 then
return false
endif
return true
endfunction
function RI takes nothing returns boolean
if not fI() then
return false
endif
return true
endfunction
function RJ takes nothing returns nothing
call UnitAddAbility(GetConstructedStructure(),1093677896)
endfunction
function Rm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988567,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988564,0)
endfunction
function S4 takes nothing returns boolean
set Gc=false
set gc=false
set hc=CreateTimer()
call TimerStart(hc,0.01,true,Jf)
return true
endfunction
function SA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651855,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651851,0)
endfunction
function e9 takes string l9 returns boolean
local integer b9
local integer y9
local integer p9
set Cb[Xb]=l9
set Xb=Xb+1
set Cc=CreateTrigger()
set Vc=CreateGroup()
set b9=0
set y9=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen b9>y9
call SetPlayerAbilityAvailable(wo[b9],1095577649,false)
set b9=b9+1
endloop
set Cb[Xb]="when calling alloc_OnUnitEnterLeave_CallbackSingle_line62 in OnUnitEnterLeave, line 62"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set p9=RO
set TO[p9]=650
else
call q1("Out of memory: Could not create OnUnitEnterLeave_CallbackSingle_line62.","when calling error in OnUnitEnterLeave, line 62")
set p9=0
endif
else
set fO=fO-1
set p9=dO[fO]
set TO[p9]=650
endif
set Xb=Xb-1
set Cb[Xb]="when calling nullTimer in OnUnitEnterLeave, line 62"
set Xb=Xb+1
call yB(0.,p9,"when calling doAfter in ClosureTimers, line 33")
set Xb=Xb-1-1
return true
endfunction
function SFw takes nothing returns boolean
set Xb=0
return e9("OnUnitEnterLeave, line 1")
endfunction
function iI takes nothing returns boolean
if GetResearched()!=1378889797 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=1 then
return false
endif
return true
endfunction
function SI takes nothing returns boolean
if not iI() then
return false
endif
return true
endfunction
function SJ takes nothing returns nothing
local integer MH=1
local integer wJ=1751343475
local player uJ=GetOwningPlayer(GetTriggerUnit())
local rect iJ=bj_mapInitialPlayableArea
local location tJ=Location(GetRectCenterX(iJ),GetRectCenterY(iJ))
local location rJ=Location(GetLocationX(tJ)+100000000.00,GetLocationY(tJ)+100000000.00)
local real sJ=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set MH=MH-1
exitwhen MH<0
call CreateUnitAtLocSaveLast(uJ,wJ,rJ,sJ)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set uJ=null
set rJ=null
set tJ=null
set iJ=null
endfunction
function Kww_2 takes timer Pww_2,string Aww returns integer
local integer Dww
local integer Hww_2
local integer Jww
set Cb[Xb]=Aww
set Xb=Xb+1
set Dww=Uo
set Hww_2=GetHandleId(Pww_2)
set Cb[Xb]="when calling loadInt in TimerUtils, line 21"
set Xb=Xb+1
if AO[Dww]==0 then
if Dww==0 then
call q1("Nullpointer exception when calling Table.loadInt","when calling error in Table, line 39")
else
call q1("Called Table.loadInt on invalid object.","when calling error in Table, line 39")
endif
endif
set Jww=LoadInteger(Wo,Dww,Hww_2)
set Xb=Xb-1-1
return Jww
endfunction
function miw takes integer giw,integer hiw,real Fiw,string kiw returns nothing
local integer jiw
local real xiw
local integer viw
set Cb[Xb]=kiw
set Xb=Xb+1
set jiw=Ul[giw]
set viw=Ul[giw]
set xiw=Fiw*GetRandomReal(Wdw(SS[hiw],0,"when calling get in City, line 403")/1000.,Wdw(SS[hiw],1,"when calling get in City, line 403")/1000.)*Ul[giw]
set Ul[giw]=viw+R2I(xiw)
set Il[giw]=Il[giw]+(Ul[giw]-jiw)
set Xb=Xb-1
endfunction
function Iiw takes integer Qiw,integer Wiw,string Eiw returns nothing
local integer Ziw
local real Uiw
set Cb[Xb]=Eiw
set Xb=Xb+1
set Ziw=gl[cdw(aS,Wiw,"when calling get in City, line 408")]
set Uiw=hl[cdw(aS,Wiw,"when calling get in City, line 409")]
set Cb[Xb]="when calling addPopulation in City, line 410"
set Xb=Xb+1
if pO[Qiw]==0 then
if Qiw==0 then
call q1("Nullpointer exception when calling City.addPopulation","when calling error in City, line 401")
else
call q1("Called City.addPopulation on invalid object.","when calling error in City, line 401")
endif
endif
call miw(Qiw,Ziw,Uiw,"when calling addPopulation in City, line 401")
set Xb=Xb-1
if Yl[cdw(aS,Wiw,"when calling get in City, line 412")]==false then
set Dl[Qiw]=Dl[Qiw]-Tl[cdw(aS,Wiw,"when calling get in City, line 413")]*5.0/Rl[cdw(aS,Wiw,"when calling get in City, line 413")]
endif
set Xb=Xb-1
endfunction
function CSw takes integer ESw,integer ZSw,string USw returns nothing
local integer ISw
local integer PSw
local integer ASw
local integer DSw
local real HSw
local integer JSw
local integer KSw
local integer LSw
local integer XSw
set Cb[Xb]=USw
set Xb=Xb+1
set Pl[Ml[ESw]]=Pl[Ml[ESw]]+GetRandomReal(-0.0001,0.00015)*Pl[Ml[ESw]]
set ZSw=Ul[Ml[ESw]]
set XSw=Ul[Ml[ESw]]
set HSw=Pow(Ul[Ml[ESw]]*Pl[Ml[ESw]],0.8)*gS[Jl[Ml[ESw]]]
set Ul[Ml[ESw]]=XSw+R2I(HSw)
set ISw=Ul[Ml[ESw]]-ZSw
set PSw=GetRandomInt(R2I(-(0.25*ISw)),R2I(0.25*ISw))
set Ul[Ml[ESw]]=Ul[Ml[ESw]]+PSw
set Il[Ml[ESw]]=Ul[Ml[ESw]]-ZSw
set JSw=Ll[Ml[ESw]]
set Cb[Xb]="when calling iterator in City, line 149"
set Xb=Xb+1
set KSw=obw(JSw,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set ASw=KSw
loop
exitwhen Yb[gb[ASw]]==Gb[ASw]
set gb[ASw]=Yb[gb[ASw]]
set DSw=Rb[gb[ASw]]
set LSw=Ml[ESw]
set Cb[Xb]="when calling getCityModifierOnFastCount in City, line 150"
set Xb=Xb+1
if pO[LSw]==0 then
if LSw==0 then
call q1("Nullpointer exception when calling City.getCityModifierOnFastCount","when calling error in City, line 407")
else
call q1("Called City.getCityModifierOnFastCount on invalid object.","when calling error in City, line 407")
endif
endif
call Iiw(LSw,DSw,"when calling getCityModifierOnFastCount in City, line 407")
set Xb=Xb-1
endloop
set Cb[Xb]="when calling close in City, line 149"
set Xb=Xb+1
if Fb[ASw]then
call Rdw(ASw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1-1
endfunction
function Eyw takes integer jyw,integer xyw,string vyw returns nothing
local integer myw
local boolean Qyw
local integer Wyw
set Cb[Xb]=vyw
set Xb=Xb+1
set xyw=0
set myw=23
loop
exitwhen xyw>myw
set jyw=Mc[xyw]
set Cb[Xb]="when calling isInGame in MultiboardCityUpdate, line 27"
set Xb=Xb+1
if yl[jyw]==0 then
if jyw==0 then
call q1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call q1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set Qyw=Ab[jyw]
set Xb=Xb-1
if Qyw then
set Wyw=Mc[xyw]
set vyw="when calling refreshMultiboardCity in MultiboardCityUpdate, line 28"
set Cb[Xb]="when calling refreshMultiboardCity in MultiboardCityUpdate, line 28"
set Xb=Xb+1
if yl[Wyw]==0 then
if Wyw==0 then
call q1("Nullpointer exception when calling PlayerStats.refreshMultiboardCity","when calling error in PlayerStats, line 71")
else
call q1("Called PlayerStats.refreshMultiboardCity on invalid object.","when calling error in PlayerStats, line 71")
endif
endif
call pew(Wyw,"when calling refreshMultiboardCity in PlayerStats, line 71")
set Xb=Xb-1
endif
set xyw=xyw+1
endloop
set Xb=Xb-1
endfunction
function Jcw takes integer Acw,integer Dcw returns nothing
local integer Hcw
set Ob[Acw]=Ob[Acw]-1.
set Hcw=0
set Dcw=23
loop
exitwhen Hcw>Dcw
call MultiboardSetTitleText(Lc[Hcw],"Income: "+I2S(R2I(Ob[Acw]/60.))+":"+I2S(R2I(ModuloReal(Ob[Acw],60.)/10.))+I2S(R2I(ModuloReal(ModuloReal(Ob[Acw],60.),10.))))
set Hcw=Hcw+1
endloop
if Ob[Acw]<=0. then
set Ob[Acw]=120.0
endif
endfunction
function gow takes integer pow,integer eow,string qow returns nothing
local integer aow
local integer now
local multiboard dow
local integer fow
local boolean Row
local integer Tow
local integer Yow
local string Gow
set Cb[Xb]=qow
set Xb=Xb+1
set aow=0
set now=23
loop
exitwhen aow>now
set fow=Mc[aow]
set Cb[Xb]="when calling isInGame in Economy, line 49"
set Xb=Xb+1
if yl[fow]==0 then
if fow==0 then
call q1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call q1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set Row=Ab[fow]
set Xb=Xb-1
if Row then
set dow=Lc[aow]
set Tow=Ic[0]
set Yow=Ic[1]
set eow=Mc[aow]
set qow="when calling getUpkeep in Economy, line 51"
set Cb[Xb]="when calling getUpkeep in Economy, line 51"
set Xb=Xb+1
if yl[eow]==0 then
if eow==0 then
call q1("Nullpointer exception when calling PlayerStats.getUpkeep","when calling error in PlayerStats, line 48")
else
call q1("Called PlayerStats.getUpkeep on invalid object.","when calling error in PlayerStats, line 48")
endif
endif
set pow=Hb[eow]
set Xb=Xb-1
set Gow=dww(pow)
call MultiboardSetItemValue(MultiboardGetItem(dow,Yow,Tow),Gow)
endif
set aow=aow+1
endloop
set Xb=Xb-1
set dow=null
endfunction
function r1 takes string J3 returns nothing
local integer K3
local integer L3
local integer X3
local integer C3
local integer V3
local real B3
local integer N3
local integer M3
local integer w1
local integer u1
set Cb[Xb]=J3
set Xb=Xb+1
set K3=0
set L3=23
loop
exitwhen K3>L3
set wc[K3]=rc[K3]
set uc[K3]=0
set K3=K3+1
endloop
set X3=R2I(nS*0.5/10.0)+1
set C3=0
set V3=R2I(20)-1
loop
exitwhen C3>V3
set B3=C3*0.5
set J3="when calling alloc_Economy_CallbackSingle_line34 in Economy, line 34"
set Cb[Xb]="when calling alloc_Economy_CallbackSingle_line34 in Economy, line 34"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set N3=RO
set TO[N3]=644
else
call q1("Out of memory: Could not create Economy_CallbackSingle_line34.","when calling error in Economy, line 34")
set N3=0
endif
else
set fO=fO-1
set N3=dO[fO]
set TO[N3]=644
endif
set Xb=Xb-1
set yb[N3]=C3
set pb[N3]=X3
call yB(B3,N3,"when calling doAfter in Economy, line 34")
set M3=nS-1
set w1=(C3+1)*X3-1
if M3<2147483647 then
set u1=M3
else
set u1=2147483647
endif
if w1<u1 then
set u1=w1
endif
exitwhen u1==nS-1
set C3=C3+1
endloop
set Xb=Xb-1
endfunction
function wOw takes integer how,integer Fow,string kow returns nothing
local integer jow
local multiboard xow
local integer vow
local integer mow
local integer Qow
local integer Wow
local integer Eow
local boolean Zow
local integer Uow
local string Iow
local integer Aow
local integer Dow
local string How
local integer Jow
local integer Kow
local integer Low
local boolean Xow
local integer Cow
local integer Vow
local integer Bow
local player Now
local playerstate Mow
set Cb[Xb]=kow
set Xb=Xb+1
set sc=sc+1
set jow=0
set Fow=23
loop
exitwhen jow>Fow
set Eow=Mc[jow]
set Cb[Xb]="when calling isInGame in Economy, line 57"
set Xb=Xb+1
if yl[Eow]==0 then
if Eow==0 then
call q1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call q1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set Zow=Ab[Eow]
set Xb=Xb-1
if Zow then
set xow=Lc[jow]
set Uow=Uc[0]
set how=Uc[1]
set Iow=dww(wc[jow])
call MultiboardSetItemValue(MultiboardGetItem(xow,how,Uow),Iow)
set Aow=Ic[0]
set Dow=Ic[1]
set Jow=Mc[jow]
set kow="when calling getUpkeep in Economy, line 60"
set Cb[Xb]="when calling getUpkeep in Economy, line 60"
set Xb=Xb+1
if yl[Jow]==0 then
if Jow==0 then
call q1("Nullpointer exception when calling PlayerStats.getUpkeep","when calling error in PlayerStats, line 48")
else
call q1("Called PlayerStats.getUpkeep on invalid object.","when calling error in PlayerStats, line 48")
endif
endif
set Kow=Hb[Jow]
set Xb=Xb-1
set How=dww(Kow)
call MultiboardSetItemValue(MultiboardGetItem(xow,Dow,Aow),How)
endif
set jow=jow+1
endloop
if sc==R2I(12) then
set sc=0
set vow=0
set mow=23
loop
exitwhen vow>mow
set Low=Mc[vow]
set Cb[Xb]="when calling isInGame in Economy, line 65"
set Xb=Xb+1
if yl[Low]==0 then
if Low==0 then
call q1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call q1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set Xow=Ab[Low]
set Xb=Xb-1
if Xow then
set Qow=GetPlayerState(wo[vow],PLAYER_STATE_RESOURCE_GOLD)
set Wow=GetPlayerState(wo[vow],PLAYER_STATE_RESOURCE_LUMBER)
set Now=wo[vow]
set Mow=PLAYER_STATE_RESOURCE_GOLD
set Bow=Qow+wc[vow]
set Cow=Mc[vow]
set Cb[Xb]="when calling getUpkeep in Economy, line 68"
set Xb=Xb+1
if yl[Cow]==0 then
if Cow==0 then
call q1("Nullpointer exception when calling PlayerStats.getUpkeep","when calling error in PlayerStats, line 48")
else
call q1("Called PlayerStats.getUpkeep on invalid object.","when calling error in PlayerStats, line 48")
endif
endif
set Vow=Hb[Cow]
set Xb=Xb-1
call SetPlayerState(Now,Mow,Bow+Vow)
call SetPlayerState(wo[vow],PLAYER_STATE_RESOURCE_LUMBER,Wow+uc[vow])
endif
set vow=vow+1
endloop
endif
call r1("when calling countIncomeForAll in Economy, line 72")
set Xb=Xb-1
set xow=null
set Now=null
set Mow=null
endfunction
function ycw takes integer VSw,integer BSw,string NSw returns nothing
local integer MSw
local real wcw
local integer ucw
local real rcw
local integer scw
local real tcw
local integer icw
local real Scw
local integer ccw
local real ocw
local integer Ocw
local integer lcw
local integer bcw
set Cb[Xb]=NSw
set Xb=Xb+1
set wcw=Gl[cdw(aS,2,"when calling get in City, line 155")]
if GetRandomReal(0.0,1.0)<=wcw then
set ucw=wb[VSw]
set Cb[Xb]="when calling addModifier in City, line 156"
set Xb=Xb+1
if pO[ucw]==0 then
if ucw==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(ucw,2,"when calling addModifier in City, line 368")
set Xb=Xb-1
endif
set rcw=Gl[cdw(aS,5,"when calling get in City, line 157")]
if GetRandomReal(0.0,1.0)<=rcw then
set scw=wb[VSw]
set Cb[Xb]="when calling addModifier in City, line 158"
set Xb=Xb+1
if pO[scw]==0 then
if scw==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(scw,5,"when calling addModifier in City, line 368")
set Xb=Xb-1
endif
set tcw=Gl[cdw(aS,7,"when calling get in City, line 159")]
if GetRandomReal(0.0,1.0)<=tcw then
set icw=wb[VSw]
set Cb[Xb]="when calling addModifier in City, line 160"
set Xb=Xb+1
if pO[icw]==0 then
if icw==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(icw,7,"when calling addModifier in City, line 368")
set Xb=Xb-1
endif
set Scw=Gl[cdw(aS,3,"when calling get in City, line 161")]
if GetRandomReal(0.0,1.0)<=Scw then
set ccw=wb[VSw]
set Cb[Xb]="when calling addModifier in City, line 162"
set Xb=Xb+1
if pO[ccw]==0 then
if ccw==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(ccw,3,"when calling addModifier in City, line 368")
set Xb=Xb-1
endif
set ocw=Gl[cdw(aS,4,"when calling get in City, line 163")]
if GetRandomReal(0.0,1.0)<=ocw then
set Ocw=wb[VSw]
set Cb[Xb]="when calling addModifier in City, line 164"
set Xb=Xb+1
if pO[Ocw]==0 then
if Ocw==0 then
call q1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call q1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call Bsw(Ocw,4,"when calling addModifier in City, line 368")
set Xb=Xb-1
endif
set lcw=Ll[wb[VSw]]
set Cb[Xb]="when calling iterator in City, line 166"
set Xb=Xb+1
set bcw=obw(lcw,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set MSw=bcw
loop
exitwhen Yb[gb[MSw]]==Gb[MSw]
set gb[MSw]=Yb[gb[MSw]]
set BSw=wb[VSw]
set Cb[Xb]="when calling getCityModifierOnLongCount in City, line 167"
set Xb=Xb+1
if pO[BSw]==0 then
if BSw==0 then
call q1("Nullpointer exception when calling City.getCityModifierOnLongCount","when calling error in City, line 416")
else
call q1("Called City.getCityModifierOnLongCount on invalid object.","when calling error in City, line 416")
endif
endif
set Xb=Xb-1
endloop
set Cb[Xb]="when calling close in City, line 166"
set Xb=Xb+1
if Fb[MSw]then
call Rdw(MSw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1-1
endfunction
function bnw takes integer cnw,integer onw,string Onw returns nothing
local force lnw
set Cb[Xb]=Onw
set Xb=Xb+1
if hO[cnw]==0 then
if cnw==0 then
call q1("Nullpointer exception when calling CallbackPeriodic.call","when calling error in ClosureTimers, line 130")
else
call q1("Called CallbackPeriodic.call on invalid object.","when calling error in ClosureTimers, line 130")
endif
endif
if hO[cnw]<=634 then
if hO[cnw]<=632 then
if hO[cnw]<=631 then
call CSw(cnw,onw,"when calling City_City_call_line138 in ClosureTimers, line 130")
else
call ycw(cnw,onw,"when calling City_City_call_line154 in ClosureTimers, line 130")
endif
elseif hO[cnw]<=633 then
set lnw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),lnw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,20.0,"Enjoying the map? Join the |cffe100ffofficial CoE discord channel|r! Link: |cffffff00discord.gg/V6kmxsy|r")
endif
else
call Jcw(cnw,onw)
endif
elseif hO[cnw]<=636 then
if hO[cnw]<=635 then
call gow(cnw,onw,"when calling Economy_call_line47 in ClosureTimers, line 130")
else
call wOw(cnw,onw,"when calling Economy_call_line54 in ClosureTimers, line 130")
endif
else
call Eyw(cnw,onw,"when calling MultiboardCityUpdate_call_line25 in ClosureTimers, line 130")
endif
set Xb=Xb-1
set lnw=null
endfunction
function Skw takes nothing returns nothing
local integer ikw
set Xb=0
set Cb[Xb]="ClosureTimers, line 135"
set Xb=Xb+1
set ikw=Kww_2(GetExpiredTimer(),"when calling getData in ClosureTimers, line 138")
call bnw(ikw,ikw,"when calling call in ClosureTimers, line 139")
set Xb=Xb-1
endfunction
function Sm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988565,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988563,0)
endfunction
function Sv takes nothing returns nothing
call SetMapFlag(MAP_LOCK_RESOURCE_TRADING,false)
endfunction
function T3 takes nothing returns boolean
return true
endfunction
function jhw takes integer rhw,integer shw,integer thw,integer ihw,integer Shw,integer chw,integer ohw,integer Ohw,integer lhw,integer bhw,integer yhw,integer phw,integer ehw,integer qhw,integer ahw,integer nhw,integer dhw,integer fhw,integer Rhw,integer Thw,integer Yhw,integer Ghw,integer ghw,integer hhw,string Fhw returns integer
local integer khw
set Cb[Xb]=Fhw
set Xb=Xb+1
set khw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(khw,rhw,"when calling add in LinkedList, line 393")
call Ndw(khw,shw,"when calling add in LinkedList, line 393")
call Ndw(khw,thw,"when calling add in LinkedList, line 393")
call Ndw(khw,ihw,"when calling add in LinkedList, line 393")
call Ndw(khw,Shw,"when calling add in LinkedList, line 393")
call Ndw(khw,chw,"when calling add in LinkedList, line 393")
call Ndw(khw,ohw,"when calling add in LinkedList, line 393")
call Ndw(khw,Ohw,"when calling add in LinkedList, line 393")
call Ndw(khw,lhw,"when calling add in LinkedList, line 393")
call Ndw(khw,bhw,"when calling add in LinkedList, line 393")
call Ndw(khw,yhw,"when calling add in LinkedList, line 393")
call Ndw(khw,phw,"when calling add in LinkedList, line 393")
call Ndw(khw,ehw,"when calling add in LinkedList, line 393")
call Ndw(khw,qhw,"when calling add in LinkedList, line 393")
call Ndw(khw,ahw,"when calling add in LinkedList, line 393")
call Ndw(khw,nhw,"when calling add in LinkedList, line 393")
call Ndw(khw,dhw,"when calling add in LinkedList, line 393")
call Ndw(khw,fhw,"when calling add in LinkedList, line 393")
call Ndw(khw,Rhw,"when calling add in LinkedList, line 393")
call Ndw(khw,Thw,"when calling add in LinkedList, line 393")
call Ndw(khw,Yhw,"when calling add in LinkedList, line 393")
call Ndw(khw,Ghw,"when calling add in LinkedList, line 393")
call Ndw(khw,ghw,"when calling add in LinkedList, line 393")
call Ndw(khw,hhw,"when calling add in LinkedList, line 393")
set Xb=Xb-1
return khw
endfunction
function trw takes string urw returns boolean
local integer rrw
local integer srw
set Cb[Xb]=urw
set Xb=Xb+1
set rrw=0
set srw=23
loop
exitwhen rrw>srw
set uO[rrw]=hlw("when calling new_HashSet in VoteKick, line 10")
set rrw=rrw+1
endloop
set rO=jhw(lww("red","when calling stringToIndex in VoteKick, line 13"),lww("blue","when calling stringToIndex in VoteKick, line 14"),lww("teal","when calling stringToIndex in VoteKick, line 15"),lww("purple","when calling stringToIndex in VoteKick, line 16"),lww("yellow","when calling stringToIndex in VoteKick, line 17"),lww("orange","when calling stringToIndex in VoteKick, line 18"),lww("green","when calling stringToIndex in VoteKick, line 19"),lww("pink","when calling stringToIndex in VoteKick, line 20"),lww("grey","when calling stringToIndex in VoteKick, line 21"),lww("light blue","when calling stringToIndex in VoteKick, line 22"),lww("dark green","when calling stringToIndex in VoteKick, line 23"),lww("brown","when calling stringToIndex in VoteKick, line 24"),lww("maroon","when calling stringToIndex in VoteKick, line 25"),lww("navy","when calling stringToIndex in VoteKick, line 26"),lww("turquoise","when calling stringToIndex in VoteKick, line 27"),lww("violet","when calling stringToIndex in VoteKick, line 28"),lww("wheat","when calling stringToIndex in VoteKick, line 29"),lww("peach","when calling stringToIndex in VoteKick, line 30"),lww("mint","when calling stringToIndex in VoteKick, line 31"),lww("lavender","when calling stringToIndex in VoteKick, line 32"),lww("coal","when calling stringToIndex in VoteKick, line 33"),lww("snow","when calling stringToIndex in VoteKick, line 34"),lww("emerald","when calling stringToIndex in VoteKick, line 35"),lww("peanut","when calling stringToIndex in VoteKick, line 36"),"when calling asList in VoteKick, line 12")
set Xb=Xb-1
return true
endfunction
function TFw takes nothing returns boolean
set Xb=0
return trw("VoteKick, line 1")
endfunction
function TH takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988553 then
return false
endif
return true
endfunction
function TI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989836,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989837,0)
endfunction
function RP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function TP takes nothing returns boolean
if not RP() then
return false
endif
return true
endfunction
function RZ takes nothing returns boolean
if GetResearched()!=1378889810 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889810,true)!=1 then
return false
endif
return true
endfunction
function TZ takes nothing returns boolean
if not RZ() then
return false
endif
return true
endfunction
function fx takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747990581 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990580 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989813 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747988569 then
return true
endif
return false
endfunction
function Rx takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989048 then
return false
endif
if not fx() then
return false
endif
return true
endfunction
function Tx takes nothing returns boolean
if not Rx() then
return false
endif
return true
endfunction
function U9 takes nothing returns boolean
set ro=ConvertPlayerColor(24)
set so=ConvertPlayerColor(25)
set io=ConvertPlayerColor(26)
set So=ConvertPlayerColor(27)
set co[0]=PLAYER_COLOR_RED
set co[1]=PLAYER_COLOR_BLUE
set co[2]=PLAYER_COLOR_CYAN
set co[3]=PLAYER_COLOR_PURPLE
set co[4]=PLAYER_COLOR_YELLOW
set co[5]=PLAYER_COLOR_ORANGE
set co[6]=PLAYER_COLOR_GREEN
set co[7]=PLAYER_COLOR_PINK
set co[8]=PLAYER_COLOR_LIGHT_GRAY
set co[9]=PLAYER_COLOR_LIGHT_BLUE
set co[10]=PLAYER_COLOR_AQUA
set co[11]=PLAYER_COLOR_BROWN
set co[12]=PLAYER_COLOR_MAROON
set co[13]=PLAYER_COLOR_NAVY
set co[14]=PLAYER_COLOR_TURQUOISE
set co[15]=PLAYER_COLOR_VIOLET
set co[16]=PLAYER_COLOR_WHEAT
set co[17]=PLAYER_COLOR_PEACH
set co[18]=PLAYER_COLOR_MINT
set co[19]=PLAYER_COLOR_LAVENDER
set co[20]=PLAYER_COLOR_COAL
set co[21]=PLAYER_COLOR_SNOW
set co[22]=PLAYER_COLOR_EMERALD
set co[23]=PLAYER_COLOR_PEANUT
set co[24]=ro
set co[25]=so
set co[26]=io
set co[27]=So
return true
endfunction
function Tqw takes string qqw,string aqw,integer nqw,integer dqw,integer fqw,string Rqw returns integer
set Cb[Xb]=Rqw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_ReligionClass in Religion, line 15"
set Xb=Xb+1
if el==0 then
if ql<32768 then
set ql=ql+1
set nqw=ql
else
call q1("Out of memory: Could not create ReligionClass.","when calling error in Religion, line 10")
set nqw=0
endif
else
set el=el-1
set nqw=pl[el]
endif
set Xb=Xb-1-1
return nqw
endfunction
function UFw takes nothing returns boolean
set Xb=0
set Cb[Xb]="Religion, line 1"
set Xb=Xb+1
call Tqw("Catholicism","Catholic",244,255,96,"when calling new_ReligionClass in Religion, line 29")
call Tqw("Orthodoxy","Orthodox",234,0,255,"when calling new_ReligionClass in Religion, line 35")
call Tqw("Islam","Muslim",0,151,0,"when calling new_ReligionClass in Religion, line 41")
call Tqw("Orthodoxy","Orthodox",234,0,255,"when calling new_ReligionClass in Religion, line 47")
set Xb=Xb-1
return true
endfunction
function ZL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990086 then
return false
endif
return true
endfunction
function UL takes nothing returns boolean
if not ZL() then
return false
endif
return true
endfunction
function UP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990594,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990584,0)
endfunction
function ZU takes nothing returns boolean
if GetResearched()!=1378890034 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890034,true)!=2 then
return false
endif
return true
endfunction
function UU takes nothing returns boolean
if not ZU() then
return false
endif
return true
endfunction
function ZW takes nothing returns boolean
if GetResearched()!=1378889783 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889783,true)!=2 then
return false
endif
return true
endfunction
function UW takes nothing returns boolean
if not ZW() then
return false
endif
return true
endfunction
function UZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651832,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651830,0)
endfunction
function Uj takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988791 then
return false
endif
return true
endfunction
function Ek takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function Zk takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988793 then
return false
endif
if not Ek() then
return false
endif
return true
endfunction
function Uk takes nothing returns boolean
if not Zk() then
return false
endif
return true
endfunction
function Uv takes nothing returns nothing
local player hv=GetOwningPlayer(GetKillingUnit())
local playerstate Fv=PLAYER_STATE_RESOURCE_LUMBER
local playerstate kv
local playerstate jv
local player xv
local force vv
local location mv
local real Qv
local real Wv
local player Ev
local force Zv
if Fv==PLAYER_STATE_RESOURCE_GOLD then
set kv=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(hv,kv,GetPlayerState(hv,kv)+500)
elseif Fv==PLAYER_STATE_RESOURCE_LUMBER then
set jv=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(hv,jv,GetPlayerState(hv,jv)+500)
endif
call SetPlayerState(hv,Fv,GetPlayerState(hv,Fv)+500)
set xv=GetOwningPlayer(GetKillingUnit())
set vv=CreateForce()
call ForceAddPlayer(vv,xv)
if IsPlayerInForce(GetLocalPlayer(),vv) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_084")
endif
set y=GetUnitLoc(GetDyingUnit())
set Ev=GetOwningPlayer(GetDyingUnit())
set Zv=CreateForce()
call ForceAddPlayer(Zv,Ev)
set mv=y
set Qv=GetLocationX(mv)
set Wv=GetLocationY(mv)
if IsPlayerInForce(GetLocalPlayer(),Zv) then
call PingMinimap(Qv,Wv,2.00)
endif
call RemoveLocation(y)
set hv=null
set Fv=null
set kv=null
set jv=null
set xv=null
set vv=null
set mv=null
set Ev=null
set Zv=null
endfunction
function V9 takes nothing returns boolean
return true
endfunction
function CA takes nothing returns boolean
if GetResearched()!=1378890052 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890052,true)!=1 then
return false
endif
return true
endfunction
function VA takes nothing returns boolean
if not CA() then
return false
endif
return true
endfunction
function t2 takes string I4 returns nothing
local fogmodifier array P4
local integer A4
local integer D4
local integer H4
local integer J4
local integer K4
local player L4
local fogstate X4
local location C4
local rect V4
local force B4
local integer N4
local integer M4
local integer w2
local integer u2
local string r2
local force s2
set Cb[Xb]=I4
set Xb=Xb+1
if gc then
set Xb=Xb-1
set L4=null
set X4=null
set C4=null
set V4=null
set B4=null
set s2=null
return
endif
set A4=0
set D4=23
loop
exitwhen A4>D4
set L4=wo[A4]
set X4=FOG_OF_WAR_VISIBLE
set V4=bj_mapInitialPlayableArea
set C4=Location(GetRectCenterX(V4),GetRectCenterY(V4))
set bj_lastCreatedFogModifier=CreateFogModifierRadiusLoc(L4,X4,C4,999999.00,true,false)
call FogModifierStart(bj_lastCreatedFogModifier)
set P4[A4]=bj_lastCreatedFogModifier
call FogModifierStart(P4[A4])
set A4=A4+1
endloop
set B4=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),B4) then
call ShowInterface(false,0.50)
endif
set N4=Tc
set Cb[Xb]="when calling iterator in MainInit, line 89"
set Xb=Xb+1
set M4=obw(N4,"when calling new_LLIterator in LinkedList, line 165")
set Xb=Xb-1
set H4=M4
loop
exitwhen Yb[gb[H4]]==Gb[H4]
set gb[H4]=Yb[gb[H4]]
set w2=Rb[gb[H4]]
set Cb[Xb]="when calling stringFromIndex in MainInit, line 89"
set Xb=Xb+1
set u2=Io
set Cb[Xb]="when calling loadString in TypeCasting, line 35"
set Xb=Xb+1
if AO[u2]==0 then
if u2==0 then
call q1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call q1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set r2=LoadStr(Wo,u2,w2)
set Xb=Xb-1
set I4=r2
set Xb=Xb-1
if not Yc then
set s2=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),s2) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,r2)
endif
call TriggerSleepAction(12.5)
endif
endloop
set Cb[Xb]="when calling close in MainInit, line 89"
set Xb=Xb+1
if Fb[H4]then
call Rdw(H4,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Xb=Xb-1
call CinematicModeExBJ(false,bj_FORCE_ALL_PLAYERS,bj_CINEMODE_INTERFACEFADE)
set J4=0
set K4=23
loop
exitwhen J4>K4
call FogModifierStop(P4[J4])
set J4=J4+1
endloop
set Yc=true
set Xb=Xb-1
set L4=null
set X4=null
set C4=null
set V4=null
set B4=null
set s2=null
endfunction
function VFw takes nothing returns nothing
set Xb=0
call t2("MainInit, line 138")
endfunction
function VI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989815,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989816,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989825,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989814,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989830,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651844,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989833,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989832,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989835,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989836,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651848,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651846,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989828,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989826,0)
endfunction
function CJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990352 then
return false
endif
return true
endfunction
function VJ takes nothing returns boolean
if not CJ() then
return false
endif
return true
endfunction
function VW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990097,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989594,0)
endfunction
function Cm takes nothing returns boolean
if GetResearched()!=1378889798 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889798,true)!=2 then
return false
endif
return true
endfunction
function Vm takes nothing returns boolean
if not Cm() then
return false
endif
return true
endfunction
function QA takes nothing returns boolean
if GetResearched()!=1378890054 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890054,true)!=1 then
return false
endif
return true
endfunction
function WA takes nothing returns boolean
if not QA() then
return false
endif
return true
endfunction
function O9 takes string i9 returns boolean
local playerevent S9
local integer c9
local integer o9
set Cb[Xb]=i9
set Xb=Xb+1
set S9=EVENT_PLAYER_LEAVE
set Cb[Xb]="when calling alloc_OnPlayerLeave_EventListener_line5 in OnPlayerLeave, line 5"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set c9=iO
set SO[c9]=677
else
call q1("Out of memory: Could not create OnPlayerLeave_EventListener_line5.","when calling error in OnPlayerLeave, line 5")
set c9=0
endif
else
set tO=tO-1
set c9=sO[tO]
set SO[c9]=677
endif
set Xb=Xb-1
set ub[c9]=0
set rb[c9]=0
set sb[c9]=0
set Cb[Xb]="when calling add in OnPlayerLeave, line 5"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set o9=vS[GetHandleId(S9)]
if o9==0 then
set o9=aV(S9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[c9]=o9
if ES[ub[c9]]!=0 then
set sb[ES[ub[c9]]]=c9
set rb[c9]=ES[ub[c9]]
endif
set ES[ub[c9]]=c9
set Xb=Xb-1-1
set S9=null
return true
endfunction
function WFw takes nothing returns boolean
set Xb=0
return O9("OnPlayerLeave, line 1")
endfunction
function QJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990356 then
return false
endif
return true
endfunction
function WJ takes nothing returns boolean
if not QJ() then
return false
endif
return true
endfunction
function WT takes nothing returns nothing
call ReplaceUnitBJ(GetEnumUnit(),1747988553,bj_UNIT_STATE_METHOD_RELATIVE)
endfunction
function Qm takes nothing returns boolean
if GetResearched()!=1378889796 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889796,true)!=2 then
return false
endif
return true
endfunction
function Wm takes nothing returns boolean
if not Qm() then
return false
endif
return true
endfunction
function Www takes nothing returns boolean
return true
endfunction
function Wx takes nothing returns nothing
local player Yx=GetOwningPlayer(GetSpellTargetUnit())
local playerstate Gx=PLAYER_STATE_RESOURCE_LUMBER
local playerstate gx
local playerstate hx
local player Fx
local force kx
local location jx
local real xx
local real vx
local player mx
local force Qx
if Gx==PLAYER_STATE_RESOURCE_GOLD then
set gx=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Yx,gx,GetPlayerState(Yx,gx)+500)
elseif Gx==PLAYER_STATE_RESOURCE_LUMBER then
set hx=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Yx,hx,GetPlayerState(Yx,hx)+500)
endif
call SetPlayerState(Yx,Gx,GetPlayerState(Yx,Gx)+500)
call RemoveUnit(GetSpellAbilityUnit())
set Fx=GetOwningPlayer(GetSpellTargetUnit())
set kx=CreateForce()
call ForceAddPlayer(kx,Fx)
if IsPlayerInForce(GetLocalPlayer(),kx) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1232")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set mx=GetOwningPlayer(GetSpellTargetUnit())
set Qx=CreateForce()
call ForceAddPlayer(Qx,mx)
set jx=y
set xx=GetLocationX(jx)
set vx=GetLocationY(jx)
if IsPlayerInForce(GetLocalPlayer(),Qx) then
call PingMinimap(xx,vx,2.00)
endif
call RemoveLocation(y)
set Yx=null
set Gx=null
set gx=null
set hx=null
set Fx=null
set kx=null
set jx=null
set mx=null
set Qx=null
endfunction
function LD takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())==1747989040 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747990361 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747989831 then
return true
endif
return false
endfunction
function XD takes nothing returns boolean
if e[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]!=false then
return false
endif
if not LD() then
return false
endif
return true
endfunction
function XE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989557,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989559,0)
endfunction
function R3 takes string y3 returns boolean
local integer p3
local integer e3
local boolean q3
local integer a3
local boolean n3
local boolean d3
local boolean f3
set Cb[Xb]=y3
set Xb=Xb+1
if GetOwningPlayer(GetSpellAbilityUnit())==GetOwningPlayer(GetSpellTargetUnit()) then
set d3=true
else
set e3=Mc[GetPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]
set Cb[Xb]="when calling isObserver in Diplomacy, line 107"
set Xb=Xb+1
if yl[e3]==0 then
if e3==0 then
call q1("Nullpointer exception when calling PlayerStats.isObserver","when calling error in PlayerStats, line 29")
else
call q1("Called PlayerStats.isObserver on invalid object.","when calling error in PlayerStats, line 29")
endif
endif
set q3=Jb[e3]
set Xb=Xb-1
set d3=q3
endif
if d3 then
set f3=true
else
set a3=Mc[GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))]
set Cb[Xb]="when calling isObserver in Diplomacy, line 108"
set Xb=Xb+1
if yl[a3]==0 then
if a3==0 then
call q1("Nullpointer exception when calling PlayerStats.isObserver","when calling error in PlayerStats, line 29")
else
call q1("Called PlayerStats.isObserver on invalid object.","when calling error in PlayerStats, line 29")
endif
endif
set n3=Jb[a3]
set Xb=Xb-1
set f3=n3
endif
if f3 then
set Xb=Xb-1
return false
endif
set p3=GetSpellAbilityId()
set Xb=Xb-1
return p3==1093677396 or p3==1093677397 or p3==1093677398 or p3==1093677400 or p3==1093677399
endfunction
function XFw takes nothing returns boolean
set Xb=0
return R3("Diplomacy, line 118")
endfunction
function LK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989060 then
return false
endif
return true
endfunction
function XK takes nothing returns boolean
if not LK() then
return false
endif
return true
endfunction
function LQ takes nothing returns boolean
if GetResearched()!=1378889801 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889801,true)!=1 then
return false
endif
return true
endfunction
function XQ takes nothing returns boolean
if not LQ() then
return false
endif
return true
endfunction
function XV takes nothing returns boolean
set IS=CreateGroup()
set DS=2147483647
set JS=Filter(Zf)
return true
endfunction
function uww takes string Mww_2 returns boolean
local integer www
set Cb[Xb]=Mww_2
set Xb=Xb+1
set Io=gqw("when calling new_Table in TypeCasting, line 6")
set Cb[Xb]="when calling initTypecastData in TypeCasting, line 14"
set Xb=Xb+1
set www=Io
set Cb[Xb]="when calling saveString in TypeCasting, line 11"
set Xb=Xb+1
if AO[www]==0 then
if www==0 then
call q1("Nullpointer exception when calling Table.saveString","when calling error in Table, line 60")
else
call q1("Called Table.saveString on invalid object.","when calling error in Table, line 60")
endif
endif
call SaveStr(Wo,www,0,"")
set Xb=Xb-1-1-1
return true
endfunction
function Xhw takes nothing returns boolean
set Xb=0
return uww("TypeCasting, line 1")
endfunction
function TF takes nothing returns boolean
local unitstate RF=UNIT_STATE_MANA
if GetUnitState(GetEnumUnit(),RF)>0.00 then
set RF=null
return false
endif
set RF=null
return true
endfunction
function YF takes nothing returns nothing
if TF() then
call KillUnit(GetEnumUnit())
endif
endfunction
function CN takes string KN returns boolean
local integer LN
local timer XN
set Cb[Xb]=KN
set Xb=Xb+1
set Cb[Xb]="when calling alloc_Credits_CallbackPeriodic_line5 in Credits, line 5"
set Xb=Xb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set LN=gO
set hO[LN]=633
else
call q1("Out of memory: Could not create Credits_CallbackPeriodic_line5.","when calling error in Credits, line 5")
set LN=0
endif
else
set GO=GO-1
set LN=YO[GO]
set hO[LN]=633
endif
set Xb=Xb-1
set Cb[Xb]="when calling doPeriodically in Credits, line 5"
set Xb=Xb+1
set XN=Cww("when calling getTimer in ClosureTimers, line 57")
set Cb[Xb]="when calling doPeriodically in ClosureTimers, line 57"
set Xb=Xb+1
call anw(LN,XN,600,"when calling start in ClosureTimers, line 45")
set Xb=Xb-1-1-1
set XN=null
return true
endfunction
function YFw takes nothing returns boolean
set Xb=0
return CN("Credits, line 1")
endfunction
function TL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990085 then
return false
endif
return true
endfunction
function YL takes nothing returns boolean
if not TL() then
return false
endif
return true
endfunction
function YP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990323,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990106,0)
endfunction
function TU takes nothing returns boolean
if GetResearched()!=1378890037 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890037,true)!=2 then
return false
endif
return true
endfunction
function YU takes nothing returns boolean
if not TU() then
return false
endif
return true
endfunction
function TW takes nothing returns boolean
if GetResearched()!=1378889803 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889803,true)!=1 then
return false
endif
return true
endfunction
function YW takes nothing returns boolean
if not TW() then
return false
endif
return true
endfunction
function YY takes nothing returns nothing
local player nY=GetOwningPlayer(GetAttacker())
local player dY=GetOwningPlayer(GetAttacker())
local player fY
local player RY
local unit TY
set r[GetPlayerId(nY)+1]=r[GetPlayerId(dY)+1]+1
set fY=GetOwningPlayer(GetTriggerUnit())
set RY=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(fY)+1]=r[GetPlayerId(RY)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set TY=GetTriggerUnit()
call SetUnitState(TY,UNIT_STATE_LIFE,GetUnitState(TY,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set nY=null
set dY=null
set fY=null
set RY=null
set TY=null
endfunction
function YZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989573,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989572,0)
endfunction
function Z2 takes nothing returns boolean
return true
endfunction
function Z9 takes nothing returns boolean
return true
endfunction
function gfw takes integer Mdw,integer wfw,integer ufw,integer rfw,integer sfw,integer tfw,integer ifw,integer Sfw,integer cfw,integer ofw,integer Ofw,integer lfw,integer bfw,integer yfw,integer pfw,integer efw,integer qfw,integer afw,integer nfw,integer dfw,integer ffw,integer Rfw,integer Tfw,string Yfw returns integer
local integer Gfw
set Cb[Xb]=Yfw
set Xb=Xb+1
set Gfw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(Gfw,Mdw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,wfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,ufw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,rfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,sfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,tfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,ifw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,Sfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,cfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,ofw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,Ofw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,lfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,bfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,yfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,pfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,efw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,qfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,afw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,nfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,dfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,ffw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,Rfw,"when calling add in LinkedList, line 393")
call Ndw(Gfw,Tfw,"when calling add in LinkedList, line 393")
set Xb=Xb-1
return Gfw
endfunction
function S0w takes string r0w returns boolean
local playerunitevent s0w
local integer t0w
local integer i0w
set Cb[Xb]=r0w
set Xb=Xb+1
set lo=gfw(1747988557,1747989075,1747990102,1747988785,1747989839,1747990101,1747989554,1747989041,1747990344,1747989059,1747989060,1747988844,1747990351,1747990352,1747990356,1747989331,1747990350,1747989809,1747990353,1747990354,1747990355,1747988568,1747990341,"when calling asList in RangeChecks, line 5")
set s0w=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Cb[Xb]="when calling alloc_RangeChecks_EventListener_line11 in RangeChecks, line 11"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set t0w=iO
set SO[t0w]=681
else
call q1("Out of memory: Could not create RangeChecks_EventListener_line11.","when calling error in RangeChecks, line 11")
set t0w=0
endif
else
set tO=tO-1
set t0w=sO[tO]
set SO[t0w]=681
endif
set Xb=Xb-1
set ub[t0w]=0
set rb[t0w]=0
set sb[t0w]=0
set Cb[Xb]="when calling add in RangeChecks, line 11"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set i0w=vS[GetHandleId(s0w)]
if i0w==0 then
set i0w=aV(s0w,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[t0w]=i0w
if ES[ub[t0w]]!=0 then
set sb[ES[ub[t0w]]]=t0w
set rb[t0w]=ES[ub[t0w]]
endif
set ES[ub[t0w]]=t0w
set Xb=Xb-1-1
set s0w=null
return true
endfunction
function ZFw takes nothing returns boolean
set Xb=0
return S0w("RangeChecks, line 1")
endfunction
function EH takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())==1747988530 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990327 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747989591 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990085 then
return true
endif
return false
endfunction
function ZH takes nothing returns boolean
if not EH() then
return false
endif
return true
endfunction
function ZI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651844,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651845,0)
endfunction
function EP takes nothing returns boolean
if GetResearched()!=1378890049 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890049,true)!=2 then
return false
endif
return true
endfunction
function ZP takes nothing returns boolean
if not EP() then
return false
endif
return true
endfunction
function EZ takes nothing returns boolean
if GetResearched()!=1378889808 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889808,true)!=1 then
return false
endif
return true
endfunction
function ZZ takes nothing returns boolean
if not EZ() then
return false
endif
return true
endfunction
function a1 takes nothing returns boolean
set ic=CreateForce()
set Sc=CreateForce()
set cc=CreateForce()
set oc=CreateForce()
set Oc[0]=ic
set Oc[1]=Sc
set Oc[2]=cc
set Oc[3]=oc
set lc[0]=62
set bc[0]=194
set yc[0]=255
set lc[1]=255
set bc[1]=238
set yc[1]=0
set lc[2]=0
set bc[2]=201
set yc[2]=10
set lc[3]=219
set bc[3]=0
set yc[3]=201
return true
endfunction
function qE takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function aE takes nothing returns boolean
if not qE() then
return false
endif
return true
endfunction
function TX takes string nX returns boolean
local playerunitevent dX
local integer fX
local integer RX
set Cb[Xb]=nX
set Xb=Xb+1
set dX=EVENT_PLAYER_UNIT_ATTACKED
set Cb[Xb]="when calling alloc_CastleCapture_EventListener_line8 in CastleCapture, line 8"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set fX=iO
set SO[fX]=662
else
call q1("Out of memory: Could not create CastleCapture_EventListener_line8.","when calling error in CastleCapture, line 8")
set fX=0
endif
else
set tO=tO-1
set fX=sO[tO]
set SO[fX]=662
endif
set Xb=Xb-1
set ub[fX]=0
set rb[fX]=0
set sb[fX]=0
set Cb[Xb]="when calling add in CastleCapture, line 8"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set RX=vS[GetHandleId(dX)]
if RX==0 then
set RX=aV(dX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[fX]=RX
if ES[ub[fX]]!=0 then
set sb[ES[ub[fX]]]=fX
set rb[fX]=ES[ub[fX]]
endif
set ES[ub[fX]]=fX
set Xb=Xb-1-1
set dX=null
return true
endfunction
function aFw takes nothing returns boolean
set Xb=0
return TX("CastleCapture, line 1")
endfunction
function aH takes nothing returns nothing
local integer OH=1
local integer lH=1751277938
local player bH=GetOwningPlayer(GetConstructedStructure())
local rect qH=bj_mapInitialPlayableArea
local location eH=Location(GetRectCenterX(qH),GetRectCenterY(qH))
local location yH=Location(GetLocationX(eH)+100000000.00,GetLocationY(eH)+1000000000.00)
local real pH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set OH=OH-1
exitwhen OH<0
call CreateUnitAtLocSaveLast(bH,lH,yH,pH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set p[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]=true
set bH=null
set yH=null
set eH=null
set qH=null
endfunction
function aL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function aU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651846,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651847,0)
endfunction
function aW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989080,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988818,0)
endfunction
function aX takes nothing returns boolean
return true
endfunction
function qY takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989042 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function aY takes nothing returns boolean
if not qY() then
return false
endif
return true
endfunction
function initMapBounds takes nothing returns nothing
local rect cond_result
local region receiver
local real temp
local real tuple_temp
set kc=bj_mapInitialPlayableArea
call RegionAddRect(CreateRegion(),kc)
set cond_result=GetWorldBounds()
set jc=cond_result
set receiver=CreateRegion()
call RegionAddRect(receiver,jc)
set xc=receiver
set temp=GetRectMaxX(jc)
set tuple_temp=GetRectMaxY(jc)
set vc=temp
set mc=tuple_temp
endfunction
function b2 takes nothing returns boolean
call initMapBounds()
return true
endfunction
function bD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990598,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990597,0)
endfunction
function iG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988824 then
return false
endif
return true
endfunction
function SG takes nothing returns boolean
if not iG() then
return false
endif
return true
endfunction
function OG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989079 then
return false
endif
return true
endfunction
function lG takes nothing returns boolean
if not OG() then
return false
endif
return true
endfunction
function cG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988826 then
return false
endif
return true
endfunction
function oG takes nothing returns boolean
if not cG() then
return false
endif
return true
endfunction
function sG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988825 then
return false
endif
return true
endfunction
function tG takes nothing returns boolean
if not sG() then
return false
endif
return true
endfunction
function bG takes nothing returns nothing
if tG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989047,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if SG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989046,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if oG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989077,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if lG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989078,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
endfunction
function bK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function bQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651826,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651824,0)
endfunction
function c0w takes nothing returns boolean
set bo=-340282366920938000000000000000000000000.
return true
endfunction
function cB takes nothing returns boolean
set KS=200
return true
endfunction
function cF takes nothing returns nothing
local location Nh
local location Mh
local real wF
local real uF
local rect rF
local group sF
local group tF
local code iF
local boolean SF
set u=GetUnitLoc(GetSpellAbilityUnit())
set Nh=u
set S=Location(GetLocationX(Nh)+0.00,GetLocationY(Nh)+200.00)
set Mh=u
set wF=GetLocationX(Mh)
set uF=GetLocationY(Mh)
set o=Rect(wF-140,uF-150,wF+140,uF+150)
set rF=o
set sF=CreateGroup()
call GroupEnumUnitsInRect(sF,rF,null)
call DestroyBoolExpr(null)
set l=sF
set tF=l
set iF=lp
set SF=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(tF,iF)
if SF then
call DestroyGroup(tF)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990072,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set Nh=null
set Mh=null
set rF=null
set sF=null
set tF=null
endfunction
function sV takes string uV returns boolean
local integer rV
set Cb[Xb]=uV
set Xb=Xb+1
set FS=ConvertPlayerEvent(96)
set QS=KOw("when calling new_HashMap in ClosureEvents, line 99")
set WS=KOw("when calling new_HashMap in ClosureEvents, line 100")
set kS=CreateTrigger()
set jS=CreateTrigger()
set xS=CreateTrigger()
call TriggerAddCondition(Po,Condition(Qf))
call TriggerAddCondition(Ao,Condition(Wf))
set Cb[Xb]="when calling alloc_ClosureEvents_CallbackSingle_line290 in ClosureEvents, line 290"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set rV=RO
set TO[rV]=640
else
call q1("Out of memory: Could not create ClosureEvents_CallbackSingle_line290.","when calling error in ClosureEvents, line 290")
set rV=0
endif
else
set fO=fO-1
set rV=dO[fO]
set TO[rV]=640
endif
set Xb=Xb-1
set Cb[Xb]="when calling nullTimer in ClosureEvents, line 290"
set Xb=Xb+1
call yB(0.,rV,"when calling doAfter in ClosureTimers, line 33")
set Xb=Xb-1-1
return true
endfunction
function cFw takes nothing returns boolean
set Xb=0
return sV("ClosureEvents, line 1")
endfunction
function cI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989833,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989834,0)
endfunction
function SP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function cP takes nothing returns boolean
if not SP() then
return false
endif
return true
endfunction
function SZ takes nothing returns boolean
if GetResearched()!=1378889809 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889809,true)!=2 then
return false
endif
return true
endfunction
function cZ takes nothing returns boolean
if not SZ() then
return false
endif
return true
endfunction
function cg takes nothing returns nothing
local location NG
local location MG
local real wg
local real ug
local rect rg
local group sg
local group tg
local code ig
local boolean Sg
set u=GetUnitLoc(GetSpellAbilityUnit())
set NG=u
set c=Location(GetLocationX(NG)+200.00,GetLocationY(NG)+0.00)
set MG=u
set wg=GetLocationX(MG)
set ug=GetLocationY(MG)
set O=Rect(wg-150,ug-140,wg+150,ug+140)
set rg=O
set sg=CreateGroup()
call GroupEnumUnitsInRect(sg,rg,null)
call DestroyBoolExpr(null)
set l=sg
set tg=l
set ig=Ky
set Sg=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(tg,ig)
if Sg then
call DestroyGroup(tg)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990092,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set NG=null
set MG=null
set rg=null
set sg=null
set tg=null
endfunction
function ch takes nothing returns nothing
local location Ng
local location Mg
local real wh
local real uh
local rect rh
local group sh
local group th
local code ih
local boolean Sh
set u=GetUnitLoc(GetSpellAbilityUnit())
set Ng=u
set c=Location(GetLocationX(Ng)+200.00,GetLocationY(Ng)+0.00)
set Mg=u
set wh=GetLocationX(Mg)
set uh=GetLocationY(Mg)
set O=Rect(wh-150,uh-140,wh+150,uh+140)
set rh=O
set sh=CreateGroup()
call GroupEnumUnitsInRect(sh,rh,null)
call DestroyBoolExpr(null)
set l=sh
set th=l
set ih=up
set Sh=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(th,ih)
if Sh then
call DestroyGroup(th)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747988826,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set Ng=null
set Mg=null
set rh=null
set sh=null
set th=null
endfunction
function Nww takes timer Vww,string Bww returns nothing
set Cb[Xb]=Bww
set Xb=Xb+1
if Vww==null then
call q1("Trying to release a null timer","when calling error in TimerUtils, line 37")
set Xb=Xb-1
return
endif
if Kww_2(Vww,"when calling getData in TimerUtils, line 39")==679645218 then
call q1("ReleaseTimer: Double free!","when calling error in TimerUtils, line 40")
set Xb=Xb-1
return
endif
call Iww(Vww,679645218,"when calling setData in TimerUtils, line 42")
call PauseTimer(Vww)
set Eo[Zo]=Vww
set Zo=Zo+1
set Xb=Xb-1
endfunction
function Pcw takes integer Ucw,string Icw returns nothing
set Cb[Xb]=Icw
set Xb=Xb+1
set Cb[Xb]="when calling CallbackSingle_onDestroy in ClosureTimers, line 123"
set Xb=Xb+1
call Nww(ob[Ucw],"when calling release in ClosureTimers, line 124")
set Xb=Xb-1
set Cb[Xb]="when calling dealloc_CallbackSingle in ClosureTimers, line 123"
set Xb=Xb+1
if TO[Ucw]==0 then
call q1("Double free: object of type CallbackSingle","when calling error in ClosureTimers, line 107")
else
set dO[fO]=Ucw
set fO=fO+1
set TO[Ucw]=0
endif
set Xb=Xb-1-1
endfunction
function wB takes group CV,integer VV,string BV returns nothing
local group NV
local unit MV
set Cb[Xb]=BV
set Xb=Xb+1
set NV=CV
loop
exitwhen FirstOfGroup(NV)==null
set MV=FirstOfGroup(NV)
call GroupRemoveUnit(NV,MV)
call Snw(VV,MV,"when calling callback in ClosureForGroups, line 40")
endloop
call rnw(VV,"when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 41")
set Xb=Xb-1
set NV=null
set MV=null
endfunction
function C9 takes string K9 returns nothing
local group L9
local integer X9
set Cb[Xb]=K9
set Xb=Xb+1
call RemoveUnit(Oo)
set L9=oo
set Cb[Xb]="when calling alloc_Preloader_ForGroupCallback_line45 in Preloader, line 45"
set Xb=Xb+1
if qO==0 then
if aO<32768 then
set aO=aO+1
set X9=aO
set nO[X9]=692
else
call q1("Out of memory: Could not create Preloader_ForGroupCallback_line45.","when calling error in Preloader, line 45")
set X9=0
endif
else
set qO=qO-1
set X9=eO[qO]
set nO[X9]=692
endif
set Xb=Xb-1
call wB(L9,X9,"when calling forEachFrom in Preloader, line 45")
call DestroyGroup(oo)
set oo=null
set Xb=Xb-1
set L9=null
endfunction
function Drw takes string Arw returns nothing
endfunction
function Gcw takes integer Rcw returns nothing
local integer Tcw
local trigger Ycw
call TriggerAddAction(kS,Vf)
call TriggerAddAction(jS,Bf)
call TriggerAddAction(xS,Nf)
set Rcw=0
set Tcw=bj_MAX_PLAYERS-1
loop
exitwhen Rcw>Tcw
call TriggerRegisterPlayerEvent(jS,wo[Rcw],EVENT_PLAYER_LEAVE)
set Ycw=xS
call TriggerRegisterPlayerEvent(Ycw,wo[Rcw],EVENT_PLAYER_ARROW_DOWN_DOWN)
call TriggerRegisterPlayerEvent(Ycw,wo[Rcw],EVENT_PLAYER_ARROW_DOWN_UP)
call TriggerRegisterPlayerEvent(Ycw,wo[Rcw],EVENT_PLAYER_ARROW_UP_DOWN)
call TriggerRegisterPlayerEvent(Ycw,wo[Rcw],EVENT_PLAYER_ARROW_UP_UP)
call TriggerRegisterPlayerEvent(Ycw,wo[Rcw],EVENT_PLAYER_ARROW_LEFT_DOWN)
call TriggerRegisterPlayerEvent(Ycw,wo[Rcw],EVENT_PLAYER_ARROW_LEFT_UP)
call TriggerRegisterPlayerEvent(Ycw,wo[Rcw],EVENT_PLAYER_ARROW_RIGHT_DOWN)
call TriggerRegisterPlayerEvent(Ycw,wo[Rcw],EVENT_PLAYER_ARROW_RIGHT_UP)
call TriggerRegisterPlayerEvent(Ycw,wo[Rcw],EVENT_PLAYER_END_CINEMATIC)
call TriggerRegisterPlayerChatEvent(Ycw,wo[Rcw],"",false)
set Rcw=Rcw+1
endloop
call g0w(EVENT_PLAYER_UNIT_SPELL_EFFECT,null,Mf,null)
set Ycw=null
endfunction
function Daw takes integer Iaw,integer Paw,string Aaw returns nothing
set Cb[Xb]=Aaw
set Xb=Xb+1
if pO[Iaw]==0 then
if Iaw==0 then
call q1("Nullpointer exception when calling City.getCityModifierOnRemove","when calling error in City, line 425")
else
call q1("Called City.getCityModifierOnRemove on invalid object.","when calling error in City, line 425")
endif
endif
set Cb[Xb]="when calling getCityModifierOnRemove in City, line 425"
set Xb=Xb+1
if Yl[cdw(aS,Paw,"when calling get in City, line 426")]then
set Dl[Iaw]=Dl[Iaw]-Tl[cdw(aS,Paw,"when calling get in City, line 427")]
endif
set Hl[Iaw]=Hl[Iaw]-Fl[cdw(aS,Paw,"when calling get in City, line 428")]
set Xb=Xb-1-1
endfunction
function ndw takes integer qdw,string adw returns nothing
set Cb[Xb]=adw
set Xb=Xb+1
if NO[qdw]==0 then
if qdw==0 then
call q1("Nullpointer exception when calling LLEntry.LLEntry","when calling error in LinkedList, line 396")
else
call q1("Called LLEntry.LLEntry on invalid object.","when calling error in LinkedList, line 396")
endif
endif
set Cb[Xb]="when calling destroyLLEntry in LinkedList, line 396"
set Xb=Xb+1
set Cb[Xb]="when calling dealloc_LLEntry in LinkedList, line 396"
set Xb=Xb+1
if NO[qdw]==0 then
call q1("Double free: object of type LLEntry","when calling error in LinkedList, line 396")
else
set CO[VO]=qdw
set VO=VO+1
set NO[qdw]=0
endif
set Xb=Xb-1-1-1
endfunction
function Idw takes integer Edw,integer Zdw,string Udw returns nothing
set Cb[Xb]=Udw
set Xb=Xb+1
if Sl[Edw]==0 then
if Edw==0 then
call q1("Nullpointer exception when calling LinkedList.removeEntry","when calling error in LinkedList, line 373")
else
call q1("Called LinkedList.removeEntry on invalid object.","when calling error in LinkedList, line 373")
endif
endif
set Cb[Xb]="when calling removeEntry in LinkedList, line 373"
set Xb=Xb+1
set Yb[Tb[Zdw]]=Yb[Zdw]
set Tb[Yb[Zdw]]=Tb[Zdw]
call ndw(Zdw,"when calling dispatch_LLEntry_destroyLLEntry in LinkedList, line 376")
set jb[Edw]=jb[Edw]-1
set Xb=Xb-1-1
endfunction
function Ybw takes integer dbw,integer fbw,string Rbw returns nothing
local integer Tbw
set Cb[Xb]=Rbw
set Xb=Xb+1
set Tbw=Yb[kb[dbw]]
loop
exitwhen Tbw==kb[dbw]
if Rb[Tbw]==fbw then
call Idw(dbw,Tbw,"when calling removeEntry in LinkedList, line 126")
set Xb=Xb-1
return
endif
set Tbw=Yb[Tbw]
endloop
set Xb=Xb-1
endfunction
function Giw takes integer niw,integer diw,string fiw returns boolean
local integer Riw
local boolean Tiw
local integer Yiw
set Cb[Xb]=fiw
set Xb=Xb+1
set Riw=Ll[niw]
set Cb[Xb]="when calling has in City, line 379"
set Xb=Xb+1
if Sl[Riw]==0 then
if Riw==0 then
call q1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call q1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Tiw=nbw(Riw,diw)
set Xb=Xb-1
if not Tiw then
set Xb=Xb-1
return false
endif
set Yiw=Ll[niw]
set Cb[Xb]="when calling remove in City, line 381"
set Xb=Xb+1
if Sl[Yiw]==0 then
if Yiw==0 then
call q1("Nullpointer exception when calling LinkedList.remove","when calling error in LinkedList, line 122")
else
call q1("Called LinkedList.remove on invalid object.","when calling error in LinkedList, line 122")
endif
endif
call Ybw(Yiw,diw,"when calling remove in LinkedList, line 122")
set Xb=Xb-1
call I2("Removed a modifier "+kl[cdw(aS,diw,"when calling get in City, line 382")])
call Daw(niw,diw,"when calling getCityModifierOnRemove in City, line 383")
set Xb=Xb-1
return true
endfunction
function Opw takes integer cpw returns nothing
local group opw
call TriggerRegisterEnterRegion(CreateTrigger(),xc,Filter(uR))
call g0w(EVENT_PLAYER_UNIT_ISSUED_ORDER,null,rR,null)
call GroupEnumUnitsInRect(Vc,jc,null)
call ForGroup(Vc,sR)
set opw=Vc
call GroupClear(opw)
call DestroyGroup(opw)
set opw=null
endfunction
function W8 takes multiboard k8,integer j8,integer x8,real v8,string m8 returns nothing
local multiboarditem Q8=MultiboardGetItem(k8,x8,j8)
call MultiboardSetItemWidth(Q8,v8)
call MultiboardSetItemValue(Q8,m8)
set Q8=null
endfunction
function U5 takes string h5 returns multiboard
local multiboard F5
local integer k5
local integer j5
local integer x5
local integer v5
local integer m5
local integer Q5
local integer W5
local integer E5
local real Z5
set Cb[Xb]=h5
set Xb=Xb+1
set F5=CreateMultiboardBJ(6,10,"Income: 2:00")
call MultiboardMinimize(F5,true)
call MultiboardSetItemsStyle(F5,true,false)
set k5=0
set j5=23
loop
exitwhen k5>j5
if uo==wo[k5]then
call MultiboardDisplay(F5,false)
endif
set k5=k5+1
endloop
set x5=0
set v5=9
loop
exitwhen x5>v5
set m5=0
set Q5=5
loop
exitwhen m5>Q5
set Z5=Wdw(Zc[x5],m5,"when calling get in MultiboardCityUpdate, line 14")/1000.
set W5=Wdw(Kc[x5],m5,"when calling get in MultiboardCityUpdate, line 14")
set Cb[Xb]="when calling stringFromIndex in MultiboardCityUpdate, line 14"
set Xb=Xb+1
set E5=Io
set Cb[Xb]="when calling loadString in TypeCasting, line 35"
set Xb=Xb+1
if AO[E5]==0 then
if E5==0 then
call q1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call q1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set h5=LoadStr(Wo,E5,W5)
set Xb=Xb-1-1
call W8(F5,m5,x5,Z5,h5)
set m5=m5+1
endloop
set x5=x5+1
endloop
set Xb=Xb-1
set cR=F5
set F5=null
return cR
endfunction
function kyw takes integer fyw,string Ryw returns nothing
local integer Tyw
local integer Yyw
local integer Gyw
local integer gyw
local boolean hyw
local multiboard Fyw
set Cb[Xb]=Ryw
set Xb=Xb+1
set Tyw=0
set Yyw=23
loop
exitwhen Tyw>Yyw
set gyw=Mc[Tyw]
set Ryw="when calling isInGame in MultiboardCityUpdate, line 20"
set Cb[Xb]="when calling isInGame in MultiboardCityUpdate, line 20"
set Xb=Xb+1
if yl[gyw]==0 then
if gyw==0 then
call q1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call q1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set hyw=Ab[gyw]
set Xb=Xb-1
if hyw then
set Lc[Tyw]=U5("when calling createCoEMultiboard in MultiboardCityUpdate, line 21")
endif
set Tyw=Tyw+1
endloop
set Gyw=0
set fyw=23
loop
exitwhen Gyw>fyw
set Fyw=Lc[Gyw]
if uo==wo[Gyw]then
call MultiboardDisplay(Fyw,true)
endif
set Gyw=Gyw+1
endloop
set Xb=Xb-1
set Fyw=null
endfunction
function yow takes integer Ccw,string Vcw returns nothing
local integer Bcw
local integer Ncw
local integer Mcw
local integer wow
local integer uow
local integer row
local integer sow
local unit tow
local player iow
local integer Sow
local unit cow
local integer oow
local integer Oow
local boolean low
local integer bow
set Cb[Xb]=Vcw
set Xb=Xb+1
set Bcw=yb[Ccw]*pb[Ccw]
set wow=nS-1
set uow=(yb[Ccw]+1)*pb[Ccw]-1
if wow<2147483647 then
set row=wow
else
set row=2147483647
endif
if uow<row then
set row=uow
endif
set Ncw=row
loop
exitwhen Bcw>Ncw
set sow=hS[Bcw]
set Cb[Xb]="when calling getCityUnit in Economy, line 36"
set Xb=Xb+1
if pO[sow]==0 then
if sow==0 then
call q1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call q1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set tow=xl[sow]
set Xb=Xb-1
set Mcw=GetPlayerId(GetOwningPlayer(tow))
set Sow=hS[Bcw]
set Cb[Xb]="when calling getCityUnit in Economy, line 37"
set Xb=Xb+1
if pO[Sow]==0 then
if Sow==0 then
call q1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call q1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set cow=xl[Sow]
set Xb=Xb-1
set iow=GetOwningPlayer(cow)
if GetPlayerSlotState(iow)==PLAYER_SLOT_STATE_PLAYING then
set low=GetPlayerController(iow)==MAP_CONTROL_USER
else
set low=false
endif
if low then
set bow=wc[Mcw]
set oow=hS[Bcw]
set Vcw="when calling countTax in Economy, line 38"
set Cb[Xb]="when calling countTax in Economy, line 38"
set Xb=Xb+1
if pO[oow]==0 then
if oow==0 then
call q1("Nullpointer exception when calling City.countTax","when calling error in City, line 279")
else
call q1("Called City.countTax on invalid object.","when calling error in City, line 279")
endif
endif
set Oow=Ctw(oow,"when calling countTax in City, line 279")
set Xb=Xb-1
set wc[Mcw]=bow+Oow
endif
set Bcw=Bcw+1
endloop
set Xb=Xb-1
set tow=null
set iow=null
set cow=null
endfunction
function Ynw takes integer nnw,string dnw returns nothing
local integer fnw
local integer Rnw
local integer Tnw
set Cb[Xb]=dnw
set Xb=Xb+1
if TO[nnw]==0 then
if nnw==0 then
call q1("Nullpointer exception when calling CallbackSingle.call","when calling error in ClosureTimers, line 109")
else
call q1("Called CallbackSingle.call on invalid object.","when calling error in ClosureTimers, line 109")
endif
endif
if TO[nnw]<=645 then
if TO[nnw]<=642 then
if TO[nnw]<=640 then
if TO[nnw]<=639 then
set Cb[Xb]="when calling City_City_call_line374 in ClosureTimers, line 109"
set Xb=Xb+1
set fnw=Vl[nnw]
set Rnw=Bl[nnw]
set Cb[Xb]="when calling removeModifier in City, line 375"
set Xb=Xb+1
if pO[fnw]==0 then
if fnw==0 then
call q1("Nullpointer exception when calling City.removeModifier","when calling error in City, line 378")
else
call q1("Called City.removeModifier on invalid object.","when calling error in City, line 378")
endif
endif
call Giw(fnw,Rnw,"when calling removeModifier in City, line 378")
set Xb=Xb-1-1
else
call Gcw(nnw)
endif
elseif TO[nnw]<=641 then
set KS=KS+50
else
set KS=KS*2
endif
elseif TO[nnw]<=644 then
if TO[nnw]<=643 then
set KS=KS/2
set Tnw=KS
if Tnw!=250 then
call Drw("Expected <"+I2S(250)+">, Actual <"+I2S(Tnw)+">")
endif
else
call yow(nnw,"when calling Economy_call_line34 in ClosureTimers, line 109")
endif
else
call IssueImmediateOrderById(nb[nnw],851976)
endif
elseif TO[nnw]<=649 then
if TO[nnw]<=647 then
if TO[nnw]<=646 then
call IssueImmediateOrderById(db[nnw],851976)
else
call IssuePointOrderById(Qb[nnw],Wb[nnw],Eb[nnw],Zb[nnw])
endif
elseif TO[nnw]<=648 then
call kyw(nnw,"when calling MultiboardCityUpdate_call_line18 in ClosureTimers, line 109")
else
call IssueImmediateOrderById(Ub[nnw],851976)
endif
elseif TO[nnw]<=651 then
if TO[nnw]<=650 then
call Opw(nnw)
else
set Cb[Xb]="when calling Preloader_call_line54 in ClosureTimers, line 109"
set Xb=Xb+1
call C9("when calling finishPreload in Preloader, line 54")
set Xb=Xb-1
endif
else
call IssueImmediateOrderById(Kb[nnw],851976)
endif
set Xb=Xb-1
endfunction
function qB takes string pB returns nothing
local integer eB
set Cb[Xb]=pB
set Xb=Xb+1
set eB=Kww_2(GetExpiredTimer(),"when calling getData in ClosureTimers, line 119")
call Ynw(eB,"when calling call in ClosureTimers, line 120")
set Cb[Xb]="when calling dispatch_CallbackSingle_destroyCallbackSingle in ClosureTimers, line 121"
set Xb=Xb+1
if TO[eB]==0 then
if eB==0 then
call q1("Nullpointer exception when calling CallbackSingle.CallbackSingle","when calling error in ClosureTimers, line 107")
else
call q1("Called CallbackSingle.CallbackSingle on invalid object.","when calling error in ClosureTimers, line 107")
endif
endif
call Pcw(eB,"when calling destroyCallbackSingle in ClosureTimers, line 107")
set Xb=Xb-1-1
endfunction
function ckw takes nothing returns nothing
set Xb=0
set Cb[Xb]="ClosureTimers, line 114"
set Xb=Xb+1
call qB("when calling staticCallback in ClosureTimers, line 114")
set Xb=Xb-1
endfunction
function cv takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747989049 then
return false
endif
return true
endfunction
function d1 takes nothing returns nothing
set ec=ec+0.030
endfunction
function dD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651850,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651849,0)
endfunction
function dF takes nothing returns nothing
local group qF
local code aF
local boolean nF
set w=GetUnitsOfTypeIdAll(1747988790)
set qF=w
set aF=pp
set nF=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(qF,aF)
if nF then
call DestroyGroup(qF)
endif
call DestroyGroup(w)
set qF=null
endfunction
function CX takes string vX returns boolean
local trigger mX
local playerunitevent QX
local playerunitevent WX
local integer EX
local integer ZX
local player UX
local location IX
local real PX
local integer AX
local integer DX
local trigger HX
local playerunitevent JX
local integer KX
local integer LX
local integer XX
set Cb[Xb]=vX
set Xb=Xb+1
if gc then
set EX=5
set ZX=1747988553
set UX=wo[0]
set IX=Location(-3000.0,1700.0)
set PX=0.
call GroupClear(bj_lastCreatedGroup)
loop
set EX=EX-1
exitwhen EX<0
call CreateUnitAtLocSaveLast(UX,ZX,IX,PX)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
endif
set QX=EVENT_PLAYER_UNIT_SELECTED
set Cb[Xb]="when calling alloc_CityManage_EventListener_line9 in CityManage, line 9"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set AX=iO
set SO[AX]=665
else
call q1("Out of memory: Could not create CityManage_EventListener_line9.","when calling error in CityManage, line 9")
set AX=0
endif
else
set tO=tO-1
set AX=sO[tO]
set SO[AX]=665
endif
set Xb=Xb-1
set ub[AX]=0
set rb[AX]=0
set sb[AX]=0
set Cb[Xb]="when calling add in CityManage, line 9"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set DX=vS[GetHandleId(QX)]
if DX==0 then
set DX=aV(QX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[AX]=DX
if ES[ub[AX]]!=0 then
set sb[ES[ub[AX]]]=AX
set rb[AX]=ES[ub[AX]]
endif
set ES[ub[AX]]=AX
set Xb=Xb-1
set mX=CreateTrigger()
call TriggerAddCondition(mX,Condition(vf))
call TriggerAddAction(mX,mf)
set HX=mX
set JX=EVENT_PLAYER_UNIT_SPELL_CAST
set KX=0
loop
call TriggerRegisterPlayerUnitEvent(HX,Player(KX),JX,null)
set KX=KX+1
exitwhen KX==bj_MAX_PLAYER_SLOTS
endloop
set WX=EVENT_PLAYER_UNIT_ATTACKED
set Cb[Xb]="when calling alloc_CityManage_EventListener_line34 in CityManage, line 34"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set LX=iO
set SO[LX]=664
else
call q1("Out of memory: Could not create CityManage_EventListener_line34.","when calling error in CityManage, line 34")
set LX=0
endif
else
set tO=tO-1
set LX=sO[tO]
set SO[LX]=664
endif
set Xb=Xb-1
set ub[LX]=0
set rb[LX]=0
set sb[LX]=0
set Cb[Xb]="when calling add in CityManage, line 34"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set XX=vS[GetHandleId(WX)]
if XX==0 then
set XX=aV(WX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[LX]=XX
if ES[ub[LX]]!=0 then
set sb[ES[ub[LX]]]=LX
set rb[LX]=ES[ub[LX]]
endif
set ES[ub[LX]]=LX
set Xb=Xb-1-1
set mX=null
set QX=null
set WX=null
set UX=null
set IX=null
set HX=null
set JX=null
return true
endfunction
function dFw takes nothing returns boolean
set Xb=0
return CX("CityManage, line 1")
endfunction
function dK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function dQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989065,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989296,0)
endfunction
function pF takes nothing returns boolean
local unitstate yF=UNIT_STATE_MANA
if GetUnitState(GetEnumUnit(),yF)>0.00 then
set yF=null
return false
endif
set yF=null
return true
endfunction
function eF takes nothing returns nothing
if pF() then
call KillUnit(GetEnumUnit())
endif
endfunction
function eFw takes nothing returns boolean
local integer OFw
local integer lFw
local integer bFw
local integer yFw
local integer pFw
set Xb=0
set Cb[Xb]="City, line 1"
set Xb=Xb+1
set dS=120.0
set fS[0]=0.0020
set fS[1]=0.0025
set Cb[Xb]="when calling asList in City, line 37"
set Xb=Xb+1
set OFw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(OFw,10000,"when calling add in LinkedList, line 393")
call Ndw(OFw,20000,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set RS[0]=OFw
set Cb[Xb]="when calling asList in City, line 38"
set Xb=Xb+1
set lFw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(lFw,30000,"when calling add in LinkedList, line 393")
call Ndw(lFw,40000,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set RS[1]=lFw
set Cb[Xb]="when calling asList in City, line 39"
set Xb=Xb+1
set bFw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(bFw,60000,"when calling add in LinkedList, line 393")
call Ndw(bFw,90000,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set RS[2]=bFw
set Cb[Xb]="when calling asList in City, line 40"
set Xb=Xb+1
set yFw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(yFw,120000,"when calling add in LinkedList, line 393")
call Ndw(yFw,160000,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set RS[3]=yFw
set Cb[Xb]="when calling asList in City, line 41"
set Xb=Xb+1
set pFw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(pFw,180000,"when calling add in LinkedList, line 393")
call Ndw(pFw,220000,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set RS[4]=pFw
set TS[0]=1.0
set TS[1]=0.5
set TS[2]=1.6
set TS[3]=2.0
set YS[0]=0.0
set YS[1]=20.0
set YS[2]=-25.0
set YS[3]=-60.0
set GS[0]=0.05
set GS[1]=0.0
set GS[2]=0.15
set GS[3]=0.30
set gS[0]=1.0
set gS[1]=1.1
set gS[2]=0.85
set gS[3]=0.7
set Xb=Xb-1
return true
endfunction
function eI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989832,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989833,0)
endfunction
function pP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function eP takes nothing returns boolean
if not pP() then
return false
endif
return true
endfunction
function eX takes nothing returns boolean
set tS=wo[PLAYER_NEUTRAL_PASSIVE]
return true
endfunction
function pZ takes nothing returns boolean
if GetResearched()!=1378889811 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889811,true)!=1 then
return false
endif
return true
endfunction
function eZ takes nothing returns boolean
if not pZ() then
return false
endif
return true
endfunction
function pg takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function eg takes nothing returns nothing
if pg() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function ph takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function eh takes nothing returns nothing
if ph() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function ej takes nothing returns nothing
local player sj=GetOwningPlayer(GetKillingUnit())
local playerstate tj=PLAYER_STATE_RESOURCE_LUMBER
local playerstate ij
local playerstate Sj
local player cj
local force oj
local location Oj
local real lj
local real bj
local player yj
local force pj
if tj==PLAYER_STATE_RESOURCE_GOLD then
set ij=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(sj,ij,GetPlayerState(sj,ij)+125)
elseif tj==PLAYER_STATE_RESOURCE_LUMBER then
set Sj=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(sj,Sj,GetPlayerState(sj,Sj)+125)
endif
call SetPlayerState(sj,tj,GetPlayerState(sj,tj)+125)
set cj=GetOwningPlayer(GetKillingUnit())
set oj=CreateForce()
call ForceAddPlayer(oj,cj)
if IsPlayerInForce(GetLocalPlayer(),oj) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_089")
endif
set y=GetUnitLoc(GetDyingUnit())
set yj=GetOwningPlayer(GetDyingUnit())
set pj=CreateForce()
call ForceAddPlayer(pj,yj)
set Oj=y
set lj=GetLocationX(Oj)
set bj=GetLocationY(Oj)
if IsPlayerInForce(GetLocalPlayer(),pj) then
call PingMinimap(lj,bj,2.00)
endif
call RemoveLocation(y)
set sj=null
set tj=null
set ij=null
set Sj=null
set cj=null
set oj=null
set Oj=null
set yj=null
set pj=null
endfunction
function eww takes nothing returns boolean
return true
endfunction
function ex takes nothing returns nothing
local player sx=GetOwningPlayer(GetKillingUnit())
local playerstate tx=PLAYER_STATE_RESOURCE_GOLD
local playerstate ix
local playerstate Sx
local player cx
local force ox
local location Ox
local real lx
local real bx
local player yx
local force px
if tx==PLAYER_STATE_RESOURCE_GOLD then
set ix=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(sx,ix,GetPlayerState(sx,ix)+250)
elseif tx==PLAYER_STATE_RESOURCE_LUMBER then
set Sx=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(sx,Sx,GetPlayerState(sx,Sx)+250)
endif
call SetPlayerState(sx,tx,GetPlayerState(sx,tx)+250)
set cx=GetOwningPlayer(GetKillingUnit())
set ox=CreateForce()
call ForceAddPlayer(ox,cx)
if IsPlayerInForce(GetLocalPlayer(),ox) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_092")
endif
set y=GetUnitLoc(GetDyingUnit())
set yx=GetOwningPlayer(GetDyingUnit())
set px=CreateForce()
call ForceAddPlayer(px,yx)
set Ox=y
set lx=GetLocationX(Ox)
set bx=GetLocationY(Ox)
if IsPlayerInForce(GetLocalPlayer(),px) then
call PingMinimap(lx,bx,2.00)
endif
call RemoveLocation(y)
set sx=null
set tx=null
set ix=null
set Sx=null
set cx=null
set ox=null
set Ox=null
set yx=null
set px=null
endfunction
function f9 takes nothing returns nothing
local unit d9=GetTriggerUnit()
if GetUnitAbilityLevel(d9,1095577649)==0 then
set Bc[Nc]=d9
set Nc=Nc+1
call TriggerExecute(Cc)
set Nc=Nc-1
endif
set d9=null
endfunction
function dA takes nothing returns boolean
if GetResearched()!=1378890040 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890040,true)!=1 then
return false
endif
return true
endfunction
function fA takes nothing returns boolean
if not dA() then
return false
endif
return true
endfunction
function Dsw takes string xsw,string vsw,real msw,real Qsw,real Wsw,integer Esw,real Zsw,real Usw,boolean Isw,string Psw returns integer
local integer Asw
set Cb[Xb]=Psw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_CityModifierClass in CityModifiers, line 37"
set Xb=Xb+1
if oO==0 then
if OO<32768 then
set OO=OO+1
set Asw=OO
else
call q1("Out of memory: Could not create CityModifierClass.","when calling error in CityModifiers, line 26")
set Asw=0
endif
else
set oO=oO-1
set Asw=cO[oO]
endif
set Xb=Xb-1
set Rl[Asw]=msw
set Tl[Asw]=Usw
set Yl[Asw]=Isw
set Gl[Asw]=Qsw
set gl[Asw]=Esw
set hl[Asw]=Zsw
set Fl[Asw]=Wsw
set kl[Asw]=xsw
set jl[Asw]=vsw
set Xb=Xb-1
return Asw
endfunction
function xC takes string qC returns boolean
local integer aC
local integer nC
local integer dC
local integer fC
local integer RC
local integer TC
local integer YC
local integer GC
local integer gC
local integer hC
local integer FC
local integer kC
local integer jC
set Cb[Xb]=qC
set Xb=Xb+1
set nC=R2I(0.5)
set dC=R2I(1)
set Cb[Xb]="when calling asList in CityModifiers, line 7"
set Xb=Xb+1
set fC=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(fC,nC,"when calling add in LinkedList, line 393")
call Ndw(fC,dC,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set SS[0]=fC
set RC=R2I(1)
set TC=R2I(3)
set Cb[Xb]="when calling asList in CityModifiers, line 8"
set Xb=Xb+1
set YC=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(YC,RC,"when calling add in LinkedList, line 393")
call Ndw(YC,TC,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set SS[1]=YC
set GC=R2I(3)
set gC=R2I(10)
set Cb[Xb]="when calling asList in CityModifiers, line 9"
set Xb=Xb+1
set hC=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(hC,GC,"when calling add in LinkedList, line 393")
call Ndw(hC,gC,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set SS[2]=hC
set FC=R2I(10)
set kC=R2I(20)
set Cb[Xb]="when calling asList in CityModifiers, line 10"
set Xb=Xb+1
set jC=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(jC,FC,"when calling add in LinkedList, line 393")
call Ndw(jC,kC,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set SS[3]=jC
set cS=Dsw("|cffff0000Just conquered|r","|cffc00000-PO -pop|r",240,1.0,0.0,1,-1.0,-30.0,false,"when calling new_CityModifierClass in CityModifiers, line 68")
set oS=Dsw("|cfffffb00Just revolted|r","|cff00af00+PO|r|cffc00000 -pop|r",120.0,1.0,0.0,0,0.,30.0,false,"when calling new_CityModifierClass in CityModifiers, line 76")
set OS=Dsw("|cff33ff00Population Boom|r","|cff33ff00++pop|r",120.0,0.01,0.,0,0.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 84")
set lS=Dsw("|cffff0000Plague outburst|r","|cffff0000--pop|r",240,0.03,0.,2,-1.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 92")
set bS=Dsw("|cffaf0000Big Fire|r","|cffc00000-pop|r",30,0.01,0.,2,-1.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 100")
set yS=Dsw("|cff15ff00More trade estabilished|r","|cff00af00+tax +pop|r",240,0.01,0.15,0,1.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 108")
set pS=Dsw("|cffff0000Massacred population|r","|cff00af00+PO |r|cffff0000--pop|r",30,0.05,0.,3,-1.,10.,true,"when calling new_CityModifierClass in CityModifiers, line 116")
set eS=Dsw("|cff00ff00Prospering|r","|cff00af00+PO +pop +tax|r",240,0.01,0.10,1,1.,20.0,true,"when calling new_CityModifierClass in CityModifiers, line 124")
set qS=Dsw("|cffff0000Sieged|r","|cffc00000-PO -pop|r",5,1.0,0.,0,-1.,-10.0,true,"when calling new_CityModifierClass in CityModifiers, line 132")
set aS=KOw("when calling new_HashMap in CityModifiers, line 142")
set aC=aS
call rdw(aC,0,cS,"when calling put in CityModifiers, line 149")
call rdw(aC,1,oS,"when calling put in CityModifiers, line 150")
call rdw(aC,2,OS,"when calling put in CityModifiers, line 151")
call rdw(aC,3,lS,"when calling put in CityModifiers, line 152")
call rdw(aC,4,bS,"when calling put in CityModifiers, line 153")
call rdw(aC,5,yS,"when calling put in CityModifiers, line 154")
call rdw(aC,6,pS,"when calling put in CityModifiers, line 155")
call rdw(aC,7,eS,"when calling put in CityModifiers, line 156")
call rdw(aC,8,qS,"when calling put in CityModifiers, line 157")
set Xb=Xb-1
return true
endfunction
function fFw takes nothing returns boolean
set Xb=0
return xC("CityModifiers, line 1")
endfunction
function dJ takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747990353 then
return false
endif
return true
endfunction
function fJ takes nothing returns boolean
if not dJ() then
return false
endif
return true
endfunction
function fj takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988801 then
return false
endif
return true
endfunction
function dm takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function fm takes nothing returns boolean
if not dm() then
return false
endif
return true
endfunction
function fv takes nothing returns nothing
local player ov=GetOwningPlayer(GetKillingUnit())
local playerstate Ov=PLAYER_STATE_RESOURCE_GOLD
local playerstate lv
local playerstate bv
local player yv
local force pv
local location ev
local real qv
local real av
local player nv
local force dv
if Ov==PLAYER_STATE_RESOURCE_GOLD then
set lv=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(ov,lv,GetPlayerState(ov,lv)+500)
elseif Ov==PLAYER_STATE_RESOURCE_LUMBER then
set bv=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(ov,bv,GetPlayerState(ov,bv)+500)
endif
call SetPlayerState(ov,Ov,GetPlayerState(ov,Ov)+500)
set yv=GetOwningPlayer(GetKillingUnit())
set pv=CreateForce()
call ForceAddPlayer(pv,yv)
if IsPlayerInForce(GetLocalPlayer(),pv) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_083")
endif
set y=GetUnitLoc(GetDyingUnit())
set nv=GetOwningPlayer(GetDyingUnit())
set dv=CreateForce()
call ForceAddPlayer(dv,nv)
set ev=y
set qv=GetLocationX(ev)
set av=GetLocationY(ev)
if IsPlayerInForce(GetLocalPlayer(),dv) then
call PingMinimap(qv,av,2.00)
endif
call RemoveLocation(y)
set ov=null
set Ov=null
set lv=null
set bv=null
set yv=null
set pv=null
set ev=null
set nv=null
set dv=null
endfunction
function g1 takes nothing returns boolean
call CreateGroup()
return true
endfunction
function gD takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,Qa)
endfunction
function gE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989570,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989571,0)
endfunction
function MN takes string VN returns boolean
local integer BN
local timer NN
set Cb[Xb]=VN
set Xb=Xb+1
set Cb[Xb]="when calling alloc_DateTime_CallbackPeriodic_line31 in DateTime, line 31"
set Xb=Xb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set BN=gO
set hO[BN]=634
else
call q1("Out of memory: Could not create DateTime_CallbackPeriodic_line31.","when calling error in DateTime, line 31")
set BN=0
endif
else
set GO=GO-1
set BN=YO[GO]
set hO[BN]=634
endif
set Xb=Xb-1
set Ob[BN]=120.0
set Cb[Xb]="when calling doPeriodically in DateTime, line 31"
set Xb=Xb+1
set NN=Cww("when calling getTimer in ClosureTimers, line 57")
set Cb[Xb]="when calling doPeriodically in ClosureTimers, line 57"
set Xb=Xb+1
call anw(BN,NN,1.0,"when calling start in ClosureTimers, line 45")
set Xb=Xb-1-1-1
set NN=null
return true
endfunction
function gFw takes nothing returns boolean
set Xb=0
return MN("DateTime, line 1")
endfunction
function YG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990072 then
return false
endif
return true
endfunction
function GG takes nothing returns boolean
if not YG() then
return false
endif
return true
endfunction
function RG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990081 then
return false
endif
return true
endfunction
function TG takes nothing returns boolean
if not RG() then
return false
endif
return true
endfunction
function dG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990090 then
return false
endif
return true
endfunction
function fG takes nothing returns boolean
if not dG() then
return false
endif
return true
endfunction
function aG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990092 then
return false
endif
return true
endfunction
function nG takes nothing returns boolean
if not aG() then
return false
endif
return true
endfunction
function gG takes nothing returns nothing
if nG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990091,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if fG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990089,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if TG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990073,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if GG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990071,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
endfunction
function GK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989809 then
return false
endif
return true
endfunction
function gK takes nothing returns boolean
if not GK() then
return false
endif
return true
endfunction
function GQ takes nothing returns boolean
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=2 then
return false
endif
return true
endfunction
function gQ takes nothing returns boolean
if not GQ() then
return false
endif
return true
endfunction
function gg takes nothing returns nothing
local location qg
local location ag
local real ng
local real dg
local rect fg
local group Rg
local group Tg
local code Yg
local boolean Gg
set u=GetUnitLoc(GetSpellAbilityUnit())
set qg=u
set S=Location(GetLocationX(qg)+0.00,GetLocationY(qg)+200.00)
set ag=u
set ng=GetLocationX(ag)
set dg=GetLocationY(ag)
set o=Rect(ng-140,dg-150,ng+140,dg+150)
set fg=o
set Rg=CreateGroup()
call GroupEnumUnitsInRect(Rg,fg,null)
call DestroyBoolExpr(null)
set l=Rg
set Tg=l
set Yg=Cy
set Gg=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Tg,Yg)
if Gg then
call DestroyGroup(Tg)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747988824,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set qg=null
set ag=null
set fg=null
set Rg=null
set Tg=null
endfunction
function gh takes nothing returns nothing
local location qh
local location ah
local real nh
local real dh
local rect fh
local group Rh
local group Th
local code Yh
local boolean Gh
set u=GetUnitLoc(GetSpellAbilityUnit())
set qh=u
set c=Location(GetLocationX(qh)+200.00,GetLocationY(qh)+0.00)
set ah=u
set nh=GetLocationX(ah)
set dh=GetLocationY(ah)
set O=Rect(nh-150,dh-140,nh+150,dh+140)
set fh=O
set Rh=CreateGroup()
call GroupEnumUnitsInRect(Rh,fh,null)
call DestroyBoolExpr(null)
set l=Rh
set Th=l
set Yh=tp
set Gh=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Th,Yh)
if Gh then
call DestroyGroup(Th)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990081,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set qh=null
set ah=null
set fh=null
set Rh=null
set Th=null
endfunction
function gv takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747989048 then
return false
endif
return true
endfunction
function gww_2 takes nothing returns boolean
set Wo=InitHashtable()
return true
endfunction
function h1 takes nothing returns nothing
call GroupAddUnit(qc,GetEnumUnit())
endfunction
function h2 takes nothing returns boolean
return true
endfunction
function G1 takes string f1 returns boolean
local playerunitevent R1
local integer T1
local integer Y1
set Cb[Xb]=f1
set Xb=Xb+1
set R1=EVENT_PLAYER_UNIT_ATTACKED
set Cb[Xb]="when calling alloc_Garissons_EventListener_line7 in Garissons, line 7"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set T1=iO
set SO[T1]=668
else
call q1("Out of memory: Could not create Garissons_EventListener_line7.","when calling error in Garissons, line 7")
set T1=0
endif
else
set tO=tO-1
set T1=sO[tO]
set SO[T1]=668
endif
set Xb=Xb-1
set ub[T1]=0
set rb[T1]=0
set sb[T1]=0
set Cb[Xb]="when calling add in Garissons, line 7"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set Y1=vS[GetHandleId(R1)]
if Y1==0 then
set Y1=aV(R1,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[T1]=Y1
if ES[ub[T1]]!=0 then
set sb[ES[ub[T1]]]=T1
set rb[T1]=ES[ub[T1]]
endif
set ES[ub[T1]]=T1
set Xb=Xb-1-1
set R1=null
return true
endfunction
function hFw takes nothing returns boolean
set Xb=0
return G1("Garissons, line 1")
endfunction
function hK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function hQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989067,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989065,0)
endfunction
function hww takes nothing returns boolean
return true
endfunction
function i4 takes nothing returns boolean
return true
endfunction
function tA takes nothing returns boolean
if GetResearched()!=1378890053 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890053,true)!=1 then
return false
endif
return true
endfunction
function iA takes nothing returns boolean
if not tA() then
return false
endif
return true
endfunction
function iFw takes nothing returns boolean
set Xb=0
set Cb[Xb]="ObjectIdGenerator, line 1"
set Xb=Xb+1
set Cb[Xb]="when calling new_IdGenerator in ObjectIdGenerator, line 7"
set Xb=Xb+1
set Cb[Xb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Xb=Xb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call q1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Xb=Xb-1-1
set Cb[Xb]="when calling new_IdGenerator in ObjectIdGenerator, line 8"
set Xb=Xb+1
set Cb[Xb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Xb=Xb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call q1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Xb=Xb-1-1
set Cb[Xb]="when calling new_IdGenerator in ObjectIdGenerator, line 9"
set Xb=Xb+1
set Cb[Xb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Xb=Xb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call q1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Xb=Xb-1-1
set Cb[Xb]="when calling new_IdGenerator in ObjectIdGenerator, line 10"
set Xb=Xb+1
set Cb[Xb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Xb=Xb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call q1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Xb=Xb-1-1
set Cb[Xb]="when calling new_IdGenerator in ObjectIdGenerator, line 11"
set Xb=Xb+1
set Cb[Xb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Xb=Xb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call q1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Xb=Xb-1-1
set Cb[Xb]="when calling new_IdGenerator in ObjectIdGenerator, line 12"
set Xb=Xb+1
set Cb[Xb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Xb=Xb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call q1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Xb=Xb-1-1-1
return true
endfunction
function tm takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function im takes nothing returns boolean
if not tm() then
return false
endif
return true
endfunction
function j0w takes nothing returns boolean
return true
endfunction
function j1 takes nothing returns boolean
return true
endfunction
function jD takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())==1747988535 then
call ReplaceUnitBJ(GetEnumUnit(),1747988788,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990325 then
call ReplaceUnitBJ(GetEnumUnit(),1747990324,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747989594 then
call ReplaceUnitBJ(GetEnumUnit(),1747990097,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988784 then
call ReplaceUnitBJ(GetEnumUnit(),1747988561,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988563 then
call ReplaceUnitBJ(GetEnumUnit(),1747988565,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988562 then
call ReplaceUnitBJ(GetEnumUnit(),1747988566,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988564 then
call ReplaceUnitBJ(GetEnumUnit(),1747988567,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990104 then
call ReplaceUnitBJ(GetEnumUnit(),1747990321,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990105 then
call ReplaceUnitBJ(GetEnumUnit(),1747990322,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990106 then
call ReplaceUnitBJ(GetEnumUnit(),1747990323,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747989811 then
call ReplaceUnitBJ(GetEnumUnit(),1747989812,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990095 then
call ReplaceUnitBJ(GetEnumUnit(),1747990098,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990096 then
call ReplaceUnitBJ(GetEnumUnit(),1747990099,bj_UNIT_STATE_METHOD_RELATIVE)
endif
endfunction
function Mew takes player Hew,string Jew returns integer
local integer Kew
local integer Lew
local integer Xew
local player Cew
local integer Vew
local integer Bew
local boolean New
set Cb[Xb]=Jew
set Xb=Xb+1
set Cb[Xb]="when calling alloc_PlayerStats in PlayerStats, line 16"
set Xb=Xb+1
if ll==0 then
if bl<32768 then
set bl=bl+1
set Lew=bl
set yl[Lew]=717
else
call q1("Out of memory: Could not create PlayerStats.","when calling error in PlayerStats, line 6")
set Lew=0
endif
else
set ll=ll-1
set Lew=Ol[ll]
set yl[Lew]=717
endif
set Xb=Xb-1
set Kew=Lew
set Xew=Lew
set Cew=Hew
set Cb[Xb]="when calling construct_PlayerStats in PlayerStats, line 16"
set Xb=Xb+1
set Ab[Lew]=false
set Jb[Lew]=false
set Hb[Lew]=0
set Ib[Lew]=-1
set Db[Lew]=-1
set Pb[Lew]=Hew
if GetPlayerSlotState(Hew)==PLAYER_SLOT_STATE_PLAYING then
set New=GetPlayerController(Hew)==MAP_CONTROL_USER
else
set New=false
endif
set Ab[Lew]=New
set Vew=0
set Bew=23
loop
exitwhen Vew>Bew
if wo[Vew]==Cew then
call ykw(Xew,Vew,-1,"when writing array PlayerStats_alliance_states in PlayerStats, line 25")
else
call ykw(Xew,Vew,bj_ALLIANCE_UNALLIED,"when writing array PlayerStats_alliance_states in PlayerStats, line 27")
endif
set Vew=Vew+1
endloop
set Xb=Xb-1-1
set Cew=null
return Kew
endfunction
function U4 takes string Y4 returns nothing
local integer G4
local integer g4
local real h4
local player F4
local integer k4
local integer j4
local integer x4
local boolean v4
local location m4
local integer Q4
local real W4
local real E4
local real Z4
set Cb[Xb]=Y4
set Xb=Xb+1
set G4=24
set g4=6
set h4=100.0
loop
exitwhen G4<=0
set k4=1
set j4=g4
loop
exitwhen k4>j4
set W4=k4*6.28318/g4
set E4=311.2+h4*Cos(W4)
set Z4=5166.7+h4*Sin(W4)
set F4=wo[24-G4+k4-1]
set x4=Mc[GetPlayerId(F4)]
set Y4="when calling isInGame in MainInit, line 54"
set Cb[Xb]="when calling isInGame in MainInit, line 54"
set Xb=Xb+1
if yl[x4]==0 then
if x4==0 then
call q1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call q1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set v4=Ab[x4]
set Xb=Xb-1
if v4 then
set m4=Location(E4,Z4)
call CreateNUnitsAtLoc(1,1747988554,F4,m4,AngleBetweenPoints(m4,Location(311.2,5166.7)))
endif
set k4=k4+1
endloop
set h4=h4+50.0
set G4=G4-g4
set g4=g4+2
if G4<2147483647 then
set Q4=G4
else
set Q4=2147483647
endif
if g4<Q4 then
set Q4=g4
endif
set g4=Q4
endloop
set Xb=Xb-1
set F4=null
set m4=null
endfunction
function yww takes rect iww,string Sww,integer cww,integer oww,string Oww returns nothing
local group lww_2
local unit bww
set Cb[Xb]=Oww
set Xb=Xb+1
set lww_2=CreateGroup()
call GroupEnumUnitsInRect(lww_2,iww,null)
call DestroyBoolExpr(null)
set bww=FirstOfGroup(lww_2)
call GroupRemoveUnit(lww_2,bww)
set hS[nS]=Liw(bww,Sww,cww,oww,"when calling new_City in SettingCities, line 8")
set Xb=Xb-1
set lww_2=null
set bww=null
endfunction
function T4 takes string c4 returns boolean
local integer o4
local integer O4
local trigger l4
local integer b4
local integer y4
local integer p4
local integer e4
local integer q4
local player a4
local integer n4
local player d4
local boolean f4
local boolean R4
set Cb[Xb]=c4
set Xb=Xb+1
set b4=lww("You're playing |cffffff65Crusade over Europe|r.\n\nUse your |cff0011ffsettler|r to choose the foundation of your new kingdom.\nThe location you choose will |cffff0000determine the faction you will get|r.\nUse the |cff00ffffF1|r menu to create alliances.\nExpand quickly, Capture cities and ores to |cffff0000increase your income|r.\nUse the |cff00fff2F2|r menu to set the taxes of your newly acquired |cff0026ffcities|r.\nFor more information, please, go to |cff00d3f8F9 menu|r.","when calling stringToIndex in MainInit, line 21")
set Cb[Xb]="when calling asList in MainInit, line 20"
set Xb=Xb+1
set y4=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(y4,b4,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Tc=y4
set p4=0
set e4=0
set q4=23
loop
exitwhen e4>q4
set a4=wo[e4]
if GetPlayerSlotState(a4)==PLAYER_SLOT_STATE_PLAYING then
set f4=GetPlayerController(a4)==MAP_CONTROL_USER
else
set f4=false
endif
if f4 then
set p4=p4+1
endif
set e4=e4+1
endloop
if Gc then
call I2("Debug info is enabled. Only for Red.")
endif
if gc then
call DisplayTimedTextToPlayer(uo,0.,0.,45.,"Debug mode is on.")
endif
set Cb[Xb]="when calling setupCities in MainInit, line 106"
set Xb=Xb+1
call yww(h,"Adrianopolis",3,1,"when calling newCity in SettingCities, line 27")
call yww(Ss,"Arta",3,0,"when calling newCity in SettingCities, line 28")
call yww(Br,"Athens",3,1,"when calling newCity in SettingCities, line 29")
call yww(Vr,"Ragusa",3,0,"when calling newCity in SettingCities, line 30")
call yww(ls,"Canakkale",3,0,"when calling newCity in SettingCities, line 31")
call yww(cs,"Candia",3,0,"when calling newCity in SettingCities, line 32")
call yww(k,"Constantinople",3,4,"when calling newCity in SettingCities, line 33")
call yww(is,"Corinth",3,0,"when calling newCity in SettingCities, line 34")
call yww(g,"Durazzo",3,0,"when calling newCity in SettingCities, line 35")
call yww(ws,"Nikomedeia",3,0,"when calling newCity in SettingCities, line 36")
call yww(lu,"Kutaisi",3,0,"when calling newCity in SettingCities, line 37")
call yww(Dw,"Nicae",3,2,"when calling newCity in SettingCities, line 38")
call yww(Zw,"Nicosia",3,0,"when calling newCity in SettingCities, line 39")
call yww(Nr,"Rhodes",3,0,"when calling newCity in SettingCities, line 40")
call yww(x,"Scopia",3,0,"when calling newCity in SettingCities, line 41")
call yww(Pw,"Smyrna",3,0,"when calling newCity in SettingCities, line 42")
call yww(bu,"Tbilisi",3,0,"when calling newCity in SettingCities, line 43")
call yww(Ew,"Trebizond",3,1,"when calling newCity in SettingCities, line 44")
call yww(F,"Thessalonika",3,3,"when calling newCity in SettingCities, line 45")
call yww(Qu,"Astrakhan'",1,2,"when calling newCity in SettingCities, line 49")
call yww(Gw,"Azaq",1,0,"when calling newCity in SettingCities, line 50")
call yww(ru,"Baia",1,0,"when calling newCity in SettingCities, line 51")
call yww(cu,"Bryansk",1,0,"when calling newCity in SettingCities, line 52")
call yww(sw,"Caffa",1,0,"when calling newCity in SettingCities, line 53")
call yww(U,"Constanta",1,0,"when calling newCity in SettingCities, line 54")
call yww(iu,"Dnipro",1,0,"when calling newCity in SettingCities, line 55")
call yww(nw,"Halych",1,0,"when calling newCity in SettingCities, line 56")
call yww(gw,"Kiev",1,2,"when calling newCity in SettingCities, line 57")
call yww(N,"Konigsberg",1,0,"when calling newCity in SettingCities, line 58")
call yww(uw,"Hrodna",1,0,"when calling newCity in SettingCities, line 59")
call yww(hw,"Minsk",1,1,"when calling newCity in SettingCities, line 60")
call yww(Su,"Moscow",1,0,"when calling newCity in SettingCities, line 61")
call yww(Sw,"Novgorod",1,0,"when calling newCity in SettingCities, line 62")
call yww(tu,"Olesh'e",1,0,"when calling newCity in SettingCities, line 63")
call yww(cw,"Polotsk",1,0,"when calling newCity in SettingCities, line 64")
call yww(tw,"Pskov",1,0,"when calling newCity in SettingCities, line 65")
call yww(iw,"Reval",1,0,"when calling newCity in SettingCities, line 66")
call yww(M,"Riga",1,1,"when calling newCity in SettingCities, line 67")
call yww(bs,"Bulgar",1,0,"when calling newCity in SettingCities, line 68")
call yww(Wu,"Ryazan'",1,0,"when calling newCity in SettingCities, line 69")
call yww(Ou,"Sarkel",1,0,"when calling newCity in SettingCities, line 70")
call yww(Fw,"Smolensk",1,1,"when calling newCity in SettingCities, line 71")
call yww(L,"Sofia",1,0,"when calling newCity in SettingCities, line 72")
call yww(I,"Targovitse",1,1,"when calling newCity in SettingCities, line 73")
call yww(uu,"Tmutarakan'",1,0,"when calling newCity in SettingCities, line 74")
call yww(Mr,"Turku",1,0,"when calling newCity in SettingCities, line 75")
call yww(rw,"Vilnius",1,1,"when calling newCity in SettingCities, line 76")
call yww(su,"Zhytomir",1,0,"when calling newCity in SettingCities, line 77")
call yww(au,"Acre",2,2,"when calling newCity in SettingCities, line 81")
call yww(mw,"Adana",2,0,"when calling newCity in SettingCities, line 82")
call yww(as,"Alamut",2,0,"when calling newCity in SettingCities, line 83")
call yww(nu,"Al-Aqaba",2,0,"when calling newCity in SettingCities, line 84")
call yww(Nw,"Alexandria",2,2,"when calling newCity in SettingCities, line 85")
call yww(Kw,"Algiers",2,0,"when calling newCity in SettingCities, line 86")
call yww(Aw,"Ankara",2,1,"when calling newCity in SettingCities, line 87")
call yww(Ww,"Antioch",2,2,"when calling newCity in SettingCities, line 88")
call yww(us,"Badajoz",2,0,"when calling newCity in SettingCities, line 89")
call yww(Os,"Baghdad",2,4,"when calling newCity in SettingCities, line 90")
call yww(ns,"Baku",2,0,"when calling newCity in SettingCities, line 91")
call yww(Cw,"Benghazi",2,1,"when calling newCity in SettingCities, line 92")
call yww(es,"Beleb-el-Anab",2,0,"when calling newCity in SettingCities, line 93")
call yww(wu,"Cairo",2,3,"when calling newCity in SettingCities, line 94")
call yww(Tr,"Cordoba",2,4,"when calling newCity in SettingCities, line 95")
call yww(yu,"Damascus",2,2,"when calling newCity in SettingCities, line 96")
call yww(Mw,"Damietta",2,1,"when calling newCity in SettingCities, line 97")
call yww(Ru,"Diyarbakir",2,0,"when calling newCity in SettingCities, line 98")
call yww(Iw,"Edessa",2,1,"when calling newCity in SettingCities, line 99")
call yww(Tu,"Erez",2,1,"when calling newCity in SettingCities, line 100")
call yww(Hw,"Fes",2,3,"when calling newCity in SettingCities, line 101")
call yww(eu,"Gaza",2,0,"when calling newCity in SettingCities, line 102")
call yww(Rr,"Granada",2,2,"when calling newCity in SettingCities, line 103")
call yww(xw,"Isparta",2,0,"when calling newCity in SettingCities, line 104")
call yww(Uw,"Jerusalem",2,3,"when calling newCity in SettingCities, line 105")
call yww(vw,"Kayseri",2,1,"when calling newCity in SettingCities, line 106")
call yww(os,"Kerak",2,0,"when calling newCity in SettingCities, line 107")
call yww(ds,"Kermanshah",2,0,"when calling newCity in SettingCities, line 108")
call yww(Qw,"Konya",2,0,"when calling newCity in SettingCities, line 109")
call yww(Sr,"Lisbon",2,0,"when calling newCity in SettingCities, line 110")
call yww(Ur,"Luxor",2,0,"when calling newCity in SettingCities, line 111")
call yww(tr,"Madrid",2,0,"when calling newCity in SettingCities, line 112")
call yww(Lw,"Mahdya",2,0,"when calling newCity in SettingCities, line 113")
call yww(Zr,"Marrakesh",2,3,"when calling newCity in SettingCities, line 114")
call yww(Bw,"Medina",2,2,"when calling newCity in SettingCities, line 115")
call yww(ps,"Melilla",2,0,"when calling newCity in SettingCities, line 116")
call yww(qu,"Mosul",2,1,"when calling newCity in SettingCities, line 117")
call yww(Yr,"Murcia",2,1,"when calling newCity in SettingCities, line 118")
call yww(Jw,"Oran",2,0,"when calling newCity in SettingCities, line 119")
call yww(mu,"Palma",2,1,"when calling newCity in SettingCities, line 120")
call yww(du,"Quarisiya",2,1,"when calling newCity in SettingCities, line 121")
call yww(Er,"Silves",2,0,"when calling newCity in SettingCities, line 122")
call yww(jw,"Sinop",2,0,"when calling newCity in SettingCities, line 123")
call yww(fu,"Tamiya",2,0,"when calling newCity in SettingCities, line 124")
call yww(pu,"Tartus",2,0,"when calling newCity in SettingCities, line 125")
call yww(qs,"Tabriz",2,0,"when calling newCity in SettingCities, line 126")
call yww(Xw,"Tripoli",2,1,"when calling newCity in SettingCities, line 127")
call yww(Yw,"Tunis",2,1,"when calling newCity in SettingCities, line 128")
call yww(Gr,"Valencia",2,0,"when calling newCity in SettingCities, line 129")
call yww(ou,"Yerevan",2,0,"when calling newCity in SettingCities, line 130")
call yww(J,"Aarhus",0,1,"when calling newCity in SettingCities, line 134")
call yww(Zu,"Aberdeen",0,1,"when calling newCity in SettingCities, line 135")
call yww(Ar,"Ajaccio",0,0,"when calling newCity in SettingCities, line 136")
call yww(dr,"Ancona",0,1,"when calling newCity in SettingCities, line 137")
call yww(Pr,"Angers",0,0,"when calling newCity in SettingCities, line 138")
call yww(yr,"Antwerp",0,0,"when calling newCity in SettingCities, line 139")
call yww(ur,"Barcelona",0,1,"when calling newCity in SettingCities, line 140")
call yww(Kr,"Bari",0,0,"when calling newCity in SettingCities, line 141")
call yww(A,"Belgrade",0,1,"when calling newCity in SettingCities, line 142")
call yww(mr,"Bergen",0,1,"when calling newCity in SettingCities, line 143")
call yww(hr,"Bern",0,0,"when calling newCity in SettingCities, line 144")
call yww(ar,"Bologna",0,1,"when calling newCity in SettingCities, line 145")
call yww(Mu,"Bordeaux",0,1,"when calling newCity in SettingCities, line 146")
call yww(P,"Brasov",0,0,"when calling newCity in SettingCities, line 147")
call yww(br,"Bruges",0,0,"when calling newCity in SettingCities, line 148")
call yww(f,"Burgh",0,0,"when calling newCity in SettingCities, line 149")
call yww(sr,"Burgos",0,1,"when calling newCity in SettingCities, line 150")
call yww(Lu,"Caen",0,0,"when calling newCity in SettingCities, line 151")
call yww(Du,"Caenarfon",0,0,"when calling newCity in SettingCities, line 152")
call yww(Dr,"Cagliari",0,0,"when calling newCity in SettingCities, line 153")
call yww(R,"Cardiff",0,0,"when calling newCity in SettingCities, line 154")
call yww(Bu,"Clermont",0,1,"when calling newCity in SettingCities, line 155")
call yww(ju,"Cologne",0,1,"when calling newCity in SettingCities, line 156")
call yww(Vu,"Dijon",0,0,"when calling newCity in SettingCities, line 157")
call yww(Pu,"Dublin",0,0,"when calling newCity in SettingCities, line 158")
call yww(Eu,"Edinburgh",0,0,"when calling newCity in SettingCities, line 159")
call yww(vr,"Eikundarsund",0,0,"when calling newCity in SettingCities, line 160")
call yww(Q,"Esztergom",0,1,"when calling newCity in SettingCities, line 161")
call yww(Ku,"Exeter",0,0,"when calling newCity in SettingCities, line 162")
call yww(ww,"Gdansk",0,0,"when calling newCity in SettingCities, line 163")
call yww(D,"Flensburg",0,0,"when calling newCity in SettingCities, line 164")
call yww(xu,"Frankfurt",0,1,"when calling newCity in SettingCities, line 165")
call yww(T,"Galway",0,0,"when calling newCity in SettingCities, line 166")
call yww(pr,"Genoa",0,2,"when calling newCity in SettingCities, line 167")
call yww(Tw,"Groningen",0,0,"when calling newCity in SettingCities, line 168")
call yww(ku,"Innsbruck",0,0,"when calling newCity in SettingCities, line 169")
call yww(Uu,"Inverness",0,0,"when calling newCity in SettingCities, line 170")
call yww(Au,"Desmond",0,0,"when calling newCity in SettingCities, line 171")
call yww(Jr,"Reggio",0,0,"when calling newCity in SettingCities, line 173")
call yww(ts,"Kalmar",0,0,"when calling newCity in SettingCities, line 174")
call yww(V,"Kassa",0,0,"when calling newCity in SettingCities, line 175")
call yww(E,"Krakow",0,2,"when calling newCity in SettingCities, line 176")
call yww(rr,"Leon",0,1,"when calling newCity in SettingCities, line 177")
call yww(Hu,"London",0,0,"when calling newCity in SettingCities, line 178")
call yww(kr,"Lund",0,0,"when calling newCity in SettingCities, line 179")
call yww(Fr,"Lyon",0,0,"when calling newCity in SettingCities, line 180")
call yww(K,"Madgeburg",0,0,"when calling newCity in SettingCities, line 181")
call yww(lr,"Marsellie",0,1,"when calling newCity in SettingCities, line 182")
call yww(Cr,"Metz",0,0,"when calling newCity in SettingCities, line 183")
call yww(er,"Milan",0,1,"when calling newCity in SettingCities, line 184")
call yww(Hr,"Naples",0,1,"when calling newCity in SettingCities, line 185")
call yww(gr,"Nuremburg",0,0,"when calling newCity in SettingCities, line 186")
call yww(Wr,"Nykoping",0,0,"when calling newCity in SettingCities, line 187")
call yww(rs,"Oporto",0,0,"when calling newCity in SettingCities, line 188")
call yww(xr,"Oslo",0,1,"when calling newCity in SettingCities, line 189")
call yww(ys,"Buda",0,1,"when calling newCity in SettingCities, line 190")
call yww(Lr,"Palermo",0,3,"when calling newCity in SettingCities, line 191")
call yww(cr,"Pamplona",0,0,"when calling newCity in SettingCities, line 192")
call yww(Cu,"Paris",0,1,"when calling newCity in SettingCities, line 193")
call yww(nr,"Pisa",0,0,"when calling newCity in SettingCities, line 194")
call yww(X,"Plock",0,0,"when calling newCity in SettingCities, line 195")
call yww(C,"Poznan",0,1,"when calling newCity in SettingCities, line 196")
call yww(m,"Prague",0,0,"when calling newCity in SettingCities, line 197")
call yww(G,"Zadar",0,0,"when calling newCity in SettingCities, line 198")
call yww(Ir,"Rennes",0,0,"when calling newCity in SettingCities, line 199")
call yww(Xu,"Rheims",0,0,"when calling newCity in SettingCities, line 200")
call yww(fr,"Rome",0,1,"when calling newCity in SettingCities, line 201")
call yww(H,"Roskilde",0,0,"when calling newCity in SettingCities, line 202")
call yww(ir,"Salamanca",0,0,"when calling newCity in SettingCities, line 203")
call yww(Fu,"Salzburg",0,0,"when calling newCity in SettingCities, line 204")
call yww(jr,"Skara",0,0,"when calling newCity in SettingCities, line 205")
call yww(W,"Stettin",0,0,"when calling newCity in SettingCities, line 206")
call yww(ss,"Stockholm",0,1,"when calling newCity in SettingCities, line 207")
call yww(Xr,"Syracuse",0,0,"when calling newCity in SettingCities, line 208")
call yww(Nu,"Toulouse",0,0,"when calling newCity in SettingCities, line 209")
call yww(B,"Varad",0,0,"when calling newCity in SettingCities, line 210")
call yww(qr,"Venice",0,2,"when calling newCity in SettingCities, line 211")
call yww(v,"Vienna",0,0,"when calling newCity in SettingCities, line 212")
call yww(Qr,"Visby",0,0,"when calling newCity in SettingCities, line 213")
call yww(j,"Warwick",0,0,"when calling newCity in SettingCities, line 214")
call yww(Ju,"Winchester",0,1,"when calling newCity in SettingCities, line 215")
call yww(Z,"Wroclaw",0,0,"when calling newCity in SettingCities, line 216")
call yww(Iu,"York",0,1,"when calling newCity in SettingCities, line 217")
call yww(Y,"Zagreb",0,0,"when calling newCity in SettingCities, line 218")
call yww(wr,"Zaragoza",0,0,"when calling newCity in SettingCities, line 219")
call yww(vu,"Hamburg",0,1,"when calling newCity in SettingCities, line 220")
set Xb=Xb-1
call SetForceAllianceStateBJ(bj_FORCE_ALL_PLAYERS,bj_FORCE_PLAYER[PLAYER_NEUTRAL_PASSIVE],bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(bj_FORCE_ALL_PLAYERS,bj_FORCE_ALL_PLAYERS,bj_ALLIANCE_UNALLIED)
call SetForceAllianceStateBJ(ic,ic,bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(Sc,Sc,bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(cc,cc,bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(oc,oc,bj_ALLIANCE_NEUTRAL)
set o4=0
set O4=23
loop
exitwhen o4>O4
call SetPlayerState(wo[o4],PLAYER_STATE_RESOURCE_GOLD,200)
call SetPlayerState(wo[o4],PLAYER_STATE_RESOURCE_LUMBER,200)
if gc then
call O2(wo[o4])
endif
call SetPlayerTechMaxAllowed(wo[o4],1747988789,1)
set Mc[o4]=Mew(wo[o4],"when calling new_PlayerStats in MainInit, line 129")
set n4=Mc[o4]
set d4=wo[o4]
if GetPlayerSlotState(d4)==PLAYER_SLOT_STATE_PLAYING then
set R4=GetPlayerController(d4)==MAP_CONTROL_USER
else
set R4=false
endif
set Cb[Xb]="when calling setInGame in MainInit, line 130"
set Xb=Xb+1
if yl[n4]==0 then
if n4==0 then
call q1("Nullpointer exception when calling PlayerStats.setInGame","when calling error in PlayerStats, line 45")
else
call q1("Called PlayerStats.setInGame on invalid object.","when calling error in PlayerStats, line 45")
endif
endif
set Ab[n4]=R4
set Xb=Xb-1
set o4=o4+1
endloop
call U4("when calling setPlayersAtStart in MainInit, line 132")
set l4=CreateTrigger()
call TriggerRegisterTimerEvent(l4,0.01,false)
call TriggerAddAction(l4,Kf)
set Xb=Xb-1
set l4=null
set a4=null
set d4=null
return true
endfunction
function jFw takes nothing returns boolean
set Xb=0
return T4("MainInit, line 1")
endfunction
function jI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989835,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989836,0)
endfunction
function kP takes nothing returns boolean
if GetResearched()!=1378890049 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890049,true)!=1 then
return false
endif
return true
endfunction
function jP takes nothing returns boolean
if not kP() then
return false
endif
return true
endfunction
function kY takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989044 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function jY takes nothing returns boolean
if not kY() then
return false
endif
return true
endfunction
function kZ takes nothing returns boolean
if GetResearched()!=1378889810 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889810,true)!=2 then
return false
endif
return true
endfunction
function jZ takes nothing returns boolean
if not kZ() then
return false
endif
return true
endfunction
function k1 takes nothing returns boolean
set dc=InitHashtable()
return true
endfunction
function kA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990596,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990595,0)
endfunction
function kD takes nothing returns boolean
return IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)==true
endfunction
function C1 takes string A1 returns boolean
local playerunitevent D1
local playerunitevent H1
local integer J1
local integer K1
local integer L1
local integer X1
set Cb[Xb]=A1
set Xb=Xb+1
set D1=EVENT_PLAYER_UNIT_DEATH
set Cb[Xb]="when calling alloc_LimitMercenaryCamps_EventListener_line8 in LimitMercenaryCamps, line 8"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set J1=iO
set SO[J1]=672
else
call q1("Out of memory: Could not create LimitMercenaryCamps_EventListener_line8.","when calling error in LimitMercenaryCamps, line 8")
set J1=0
endif
else
set tO=tO-1
set J1=sO[tO]
set SO[J1]=672
endif
set Xb=Xb-1
set ub[J1]=0
set rb[J1]=0
set sb[J1]=0
set Cb[Xb]="when calling add in LimitMercenaryCamps, line 8"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set K1=vS[GetHandleId(D1)]
if K1==0 then
set K1=aV(D1,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[J1]=K1
if ES[ub[J1]]!=0 then
set sb[ES[ub[J1]]]=J1
set rb[J1]=ES[ub[J1]]
endif
set ES[ub[J1]]=J1
set Xb=Xb-1
set H1=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Cb[Xb]="when calling alloc_LimitMercenaryCamps_EventListener_line12 in LimitMercenaryCamps, line 12"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set L1=iO
set SO[L1]=671
else
call q1("Out of memory: Could not create LimitMercenaryCamps_EventListener_line12.","when calling error in LimitMercenaryCamps, line 12")
set L1=0
endif
else
set tO=tO-1
set L1=sO[tO]
set SO[L1]=671
endif
set Xb=Xb-1
set ub[L1]=0
set rb[L1]=0
set sb[L1]=0
set Cb[Xb]="when calling add in LimitMercenaryCamps, line 12"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set X1=vS[GetHandleId(H1)]
if X1==0 then
set X1=aV(H1,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[L1]=X1
if ES[ub[L1]]!=0 then
set sb[ES[ub[L1]]]=L1
set rb[L1]=ES[ub[L1]]
endif
set ES[ub[L1]]=L1
set Xb=Xb-1-1
set D1=null
set H1=null
return true
endfunction
function kFw takes nothing returns boolean
set Xb=0
return C1("LimitMercenaryCamps, line 1")
endfunction
function FI takes nothing returns boolean
if GetResearched()!=1378890036 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890036,true)!=2 then
return false
endif
return true
endfunction
function kI takes nothing returns boolean
if not FI() then
return false
endif
return true
endfunction
function kJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function km takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989057,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989058,0)
endfunction
function l2 takes nothing returns nothing
set Fc=Fc+0.01
endfunction
function OD takes nothing returns boolean
if GetResearched()!=1378889818 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889818,true)!=1 then
return false
endif
return true
endfunction
function lD takes nothing returns boolean
if not OD() then
return false
endif
return true
endfunction
function lE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990098,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990095,0)
endfunction
function OK takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747989331 then
return false
endif
return true
endfunction
function lK takes nothing returns boolean
if not OK() then
return false
endif
return true
endfunction
function OQ takes nothing returns boolean
if GetResearched()!=1378889802 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889802,true)!=2 then
return false
endif
return true
endfunction
function lQ takes nothing returns boolean
if not OQ() then
return false
endif
return true
endfunction
function lY takes nothing returns nothing
local player iY=GetOwningPlayer(GetAttacker())
local player SY=GetOwningPlayer(GetAttacker())
local player cY
local player oY
local unit OY
set r[GetPlayerId(iY)+1]=r[GetPlayerId(SY)+1]+1
set cY=GetOwningPlayer(GetTriggerUnit())
set oY=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(cY)+1]=r[GetPlayerId(oY)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set OY=GetTriggerUnit()
call SetUnitState(OY,UNIT_STATE_LIFE,GetUnitState(OY,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set iY=null
set SY=null
set cY=null
set oY=null
set OY=null
endfunction
function lk takes nothing returns nothing
local player MF=GetOwningPlayer(GetSpellTargetUnit())
local playerstate wk=PLAYER_STATE_RESOURCE_LUMBER
local playerstate uk
local playerstate rk
local player sk
local force tk
local location ik
local real Sk
local real ck
local player ok
local force Ok
if wk==PLAYER_STATE_RESOURCE_GOLD then
set uk=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(MF,uk,GetPlayerState(MF,uk)+500)
elseif wk==PLAYER_STATE_RESOURCE_LUMBER then
set rk=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(MF,rk,GetPlayerState(MF,rk)+500)
endif
call SetPlayerState(MF,wk,GetPlayerState(MF,wk)+500)
call RemoveUnit(GetSpellAbilityUnit())
set sk=GetOwningPlayer(GetSpellTargetUnit())
set tk=CreateForce()
call ForceAddPlayer(tk,sk)
if IsPlayerInForce(GetLocalPlayer(),tk) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1228")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set ok=GetOwningPlayer(GetSpellTargetUnit())
set Ok=CreateForce()
call ForceAddPlayer(Ok,ok)
set ik=y
set Sk=GetLocationX(ik)
set ck=GetLocationY(ik)
if IsPlayerInForce(GetLocalPlayer(),Ok) then
call PingMinimap(Sk,ck,2.00)
endif
call RemoveLocation(y)
set MF=null
set wk=null
set uk=null
set rk=null
set sk=null
set tk=null
set ik=null
set ok=null
set Ok=null
endfunction
function mE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989556,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989570,0)
endfunction
function B8 takes string L8 returns boolean
local playerunitevent X8
local integer C8
local integer V8
set Cb[Xb]=L8
set Xb=Xb+1
set X8=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Cb[Xb]="when calling alloc_NoShipsNearRivers_EventListener_line7 in NoShipsNearRivers, line 7"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set C8=iO
set SO[C8]=675
else
call q1("Out of memory: Could not create NoShipsNearRivers_EventListener_line7.","when calling error in NoShipsNearRivers, line 7")
set C8=0
endif
else
set tO=tO-1
set C8=sO[tO]
set SO[C8]=675
endif
set Xb=Xb-1
set ub[C8]=0
set rb[C8]=0
set sb[C8]=0
set Cb[Xb]="when calling add in NoShipsNearRivers, line 7"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set V8=vS[GetHandleId(X8)]
if V8==0 then
set V8=aV(X8,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[C8]=V8
if ES[ub[C8]]!=0 then
set sb[ES[ub[C8]]]=C8
set rb[C8]=ES[ub[C8]]
endif
set ES[ub[C8]]=C8
set Xb=Xb-1-1
set X8=null
return true
endfunction
function mFw takes nothing returns boolean
set Xb=0
return B8("NoShipsNearRivers, line 1")
endfunction
function vG takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function mG takes nothing returns nothing
if vG() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function vK takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747989059 then
return false
endif
return true
endfunction
function mK takes nothing returns boolean
if not vK() then
return false
endif
return true
endfunction
function vQ takes nothing returns boolean
if GetResearched()!=1378889799 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889799,true)!=1 then
return false
endif
return true
endfunction
function mQ takes nothing returns boolean
if not vQ() then
return false
endif
return true
endfunction
function vg takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function mg takes nothing returns nothing
if vg() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function vh takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function mh takes nothing returns nothing
if vh() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function mj takes nothing returns nothing
local player Rj=GetOwningPlayer(GetKillingUnit())
local playerstate Tj=PLAYER_STATE_RESOURCE_LUMBER
local playerstate Yj
local playerstate Gj
local player gj
local force hj
local location Fj
local real kj
local real jj
local player xj
local force vj
if Tj==PLAYER_STATE_RESOURCE_GOLD then
set Yj=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Rj,Yj,GetPlayerState(Rj,Yj)+250)
elseif Tj==PLAYER_STATE_RESOURCE_LUMBER then
set Gj=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Rj,Gj,GetPlayerState(Rj,Gj)+250)
endif
call SetPlayerState(Rj,Tj,GetPlayerState(Rj,Tj)+250)
set gj=GetOwningPlayer(GetKillingUnit())
set hj=CreateForce()
call ForceAddPlayer(hj,gj)
if IsPlayerInForce(GetLocalPlayer(),hj) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_090")
endif
set y=GetUnitLoc(GetDyingUnit())
set xj=GetOwningPlayer(GetDyingUnit())
set vj=CreateForce()
call ForceAddPlayer(vj,xj)
set Fj=y
set kj=GetLocationX(Fj)
set jj=GetLocationY(Fj)
if IsPlayerInForce(GetLocalPlayer(),vj) then
call PingMinimap(kj,jj,2.00)
endif
call RemoveLocation(y)
set Rj=null
set Tj=null
set Yj=null
set Gj=null
set gj=null
set hj=null
set Fj=null
set xj=null
set vj=null
endfunction
function mww_2 takes nothing returns boolean
return true
endfunction
function n1 takes nothing returns boolean
set pc=CreateTimer()
call TimerStart(pc,100000.,false,null)
call TimerStart(CreateTimer(),0.030,true,Hf)
return true
endfunction
function n9 takes nothing returns nothing
call a9(GetFilterUnit())
endfunction
function aD takes nothing returns boolean
if GetResearched()!=1378890041 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890041,true)!=1 then
return false
endif
return true
endfunction
function nD takes nothing returns boolean
if not aD() then
return false
endif
return true
endfunction
function nE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990099,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990096,0)
endfunction
function xX takes string hX returns boolean
local playerunitevent FX
local integer kX
local integer jX
set Cb[Xb]=hX
set Xb=Xb+1
set FX=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set Cb[Xb]="when calling alloc_CityBuilded_EventListener_line9 in CityBuilded, line 9"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set kX=iO
set SO[kX]=663
else
call q1("Out of memory: Could not create CityBuilded_EventListener_line9.","when calling error in CityBuilded, line 9")
set kX=0
endif
else
set tO=tO-1
set kX=sO[tO]
set SO[kX]=663
endif
set Xb=Xb-1
set ub[kX]=0
set rb[kX]=0
set sb[kX]=0
set Cb[Xb]="when calling add in CityBuilded, line 9"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set jX=vS[GetHandleId(FX)]
if jX==0 then
set jX=aV(FX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[kX]=jX
if ES[ub[kX]]!=0 then
set sb[ES[ub[kX]]]=kX
set rb[kX]=ES[ub[kX]]
endif
set ES[ub[kX]]=kX
set Xb=Xb-1-1
set FX=null
return true
endfunction
function nFw takes nothing returns boolean
set Xb=0
return xX("CityBuilded, line 1")
endfunction
function aK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990350 then
return false
endif
return true
endfunction
function nK takes nothing returns boolean
if not aK() then
return false
endif
return true
endfunction
function aQ takes nothing returns boolean
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=1 then
return false
endif
return true
endfunction
function nQ takes nothing returns boolean
if not aQ() then
return false
endif
return true
endfunction
function qk takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function ak takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988791 then
return false
endif
if not qk() then
return false
endif
return true
endfunction
function nk takes nothing returns boolean
if not ak() then
return false
endif
return true
endfunction
function gX takes string YX returns boolean
local integer GX
set Cb[Xb]=YX
set Xb=Xb+1
set iS=KOw("when calling new_HashMap in CityBaseTaxes, line 5")
set GX=iS
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 9"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747988529,20)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 10"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747988530,50)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 11"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747988531,120)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 12"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747990326,20)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 13"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747990327,50)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 14"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747990328,120)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 15"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747990084,20)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 16"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747990087,50)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 17"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747990086,120)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 18"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747989590,20)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 19"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747989591,50)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 20"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747989592,120)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 22"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747989555,5)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 23"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747989297,10)
set Xb=Xb-1
set Cb[Xb]="when calling saveInt in CityBaseTaxes, line 24"
set Xb=Xb+1
if AO[GX]==0 then
if GX==0 then
call q1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call q1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Wo,GX,1747989325,30)
set Xb=Xb-1-1
return true
endfunction
function oFw takes nothing returns boolean
set Xb=0
return gX("CityBaseTaxes, line 1")
endfunction
function cH takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())==1747988545 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747989577 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747990320 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747989845 then
return true
endif
return false
endfunction
function oH takes nothing returns boolean
if p[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]!=false then
return false
endif
if not cH() then
return false
endif
return true
endfunction
function cL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989591 then
return false
endif
return true
endfunction
function oL takes nothing returns boolean
if not cL() then
return false
endif
return true
endfunction
function oP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990321,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990104,0)
endfunction
function cU takes nothing returns boolean
if GetResearched()!=1378889818 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889818,true)!=2 then
return false
endif
return true
endfunction
function oU takes nothing returns boolean
if not cU() then
return false
endif
return true
endfunction
function cW takes nothing returns boolean
if GetResearched()!=1378889800 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889800,true)!=1 then
return false
endif
return true
endfunction
function oW takes nothing returns boolean
if not cW() then
return false
endif
return true
endfunction
function oZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651833,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651841,0)
endfunction
function pA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651852,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651855,0)
endfunction
function yI takes nothing returns boolean
if GetResearched()!=1378889797 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=2 then
return false
endif
return true
endfunction
function pI takes nothing returns boolean
if not yI() then
return false
endif
return true
endfunction
function pJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function pX takes nothing returns boolean
return true
endfunction
function pm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988566,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988562,0)
endfunction
function pww takes nothing returns boolean
return true
endfunction
function h8 takes string I5 returns boolean
local integer P5
local integer A5
local integer D5
local integer H5
local integer J5
local integer K5
local integer L5
local integer X5
local integer C5
local integer V5
local integer B5
local integer N5
local integer M5
local integer w6
local integer u6
local integer r6
local integer s6
local integer t6
local integer i6
local integer S6
local integer c6
local integer o6
local integer O6
local integer l6
local integer b6
local integer y6
local integer p6
local integer e6
local integer q6
local integer a6
local integer n6
local integer d6
local integer f6
local integer R6
local integer T6
local integer Y6
local integer G6
local integer g6
local integer h6
local integer F6
local integer k6
local integer j6
local integer x6
local integer v6
local integer m6
local integer Q6
local integer W6
local integer E6
local integer Z6
local integer U6
local integer I6
local integer P6
local integer A6
local integer D6
local integer H6
local integer J6
local integer K6
local integer L6
local integer X6
local integer C6
local integer V6
local integer B6
local integer N6
local integer M6
local integer w7
local integer u7
local integer r7
local integer s7
local integer t7
local integer i7
local integer S7
local integer c7
local integer o7
local integer O7
local integer l7
local integer b7
local integer y7
local integer p7
local integer e7
local integer q7
local integer a7
local integer n7
local integer d7
local integer f7
local integer R7
local integer T7
local integer Y7
local integer G7
local integer g7
local integer h7
local integer F7
local integer k7
local integer j7
local integer x7
local integer v7
local integer m7
local integer Q7
local integer W7
local integer E7
local integer Z7
local integer U7
local integer I7
local integer P7
local integer A7
local integer D7
local integer H7
local integer J7
local integer K7
local integer L7
local integer X7
local integer C7
local integer V7
local integer B7
local integer N7
local integer M7
local integer w8
local integer u8
local integer r8
local integer s8
local integer t8
local integer i8
local integer S8
local integer c8
local integer o8
local integer O8
local integer l8
local integer b8
local integer y8
local integer p8
local integer e8
local integer q8
local integer a8
local integer n8
local integer d8
local integer f8
local integer R8
local integer T8
local integer Y8
local integer G8
local integer g8
set Cb[Xb]=I5
set Xb=Xb+1
set P5=R2I(70)
set A5=R2I(30)
set D5=R2I(10)
set H5=R2I(70)
set J5=R2I(30)
set K5=R2I(140)
set Cb[Xb]="when calling asList in Multiboards, line 23"
set Xb=Xb+1
set L5=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(L5,P5,"when calling add in LinkedList, line 393")
call Ndw(L5,A5,"when calling add in LinkedList, line 393")
call Ndw(L5,D5,"when calling add in LinkedList, line 393")
call Ndw(L5,H5,"when calling add in LinkedList, line 393")
call Ndw(L5,J5,"when calling add in LinkedList, line 393")
call Ndw(L5,K5,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[0]=L5
set X5=R2I(70)
set C5=R2I(30)
set V5=R2I(10)
set B5=R2I(70)
set N5=R2I(30)
set M5=R2I(140)
set Cb[Xb]="when calling asList in Multiboards, line 24"
set Xb=Xb+1
set w6=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(w6,X5,"when calling add in LinkedList, line 393")
call Ndw(w6,C5,"when calling add in LinkedList, line 393")
call Ndw(w6,V5,"when calling add in LinkedList, line 393")
call Ndw(w6,B5,"when calling add in LinkedList, line 393")
call Ndw(w6,N5,"when calling add in LinkedList, line 393")
call Ndw(w6,M5,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[1]=w6
set u6=R2I(70)
set r6=R2I(30)
set s6=R2I(10)
set t6=R2I(70)
set i6=R2I(30)
set S6=R2I(140)
set Cb[Xb]="when calling asList in Multiboards, line 25"
set Xb=Xb+1
set c6=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(c6,u6,"when calling add in LinkedList, line 393")
call Ndw(c6,r6,"when calling add in LinkedList, line 393")
call Ndw(c6,s6,"when calling add in LinkedList, line 393")
call Ndw(c6,t6,"when calling add in LinkedList, line 393")
call Ndw(c6,i6,"when calling add in LinkedList, line 393")
call Ndw(c6,S6,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[2]=c6
set o6=R2I(2.5)
set O6=R2I(2.5)
set l6=R2I(400)
set b6=R2I(2.5)
set y6=R2I(2.5)
set p6=R2I(2.5)
set Cb[Xb]="when calling asList in Multiboards, line 27"
set Xb=Xb+1
set e6=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(e6,o6,"when calling add in LinkedList, line 393")
call Ndw(e6,O6,"when calling add in LinkedList, line 393")
call Ndw(e6,l6,"when calling add in LinkedList, line 393")
call Ndw(e6,b6,"when calling add in LinkedList, line 393")
call Ndw(e6,y6,"when calling add in LinkedList, line 393")
call Ndw(e6,p6,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[3]=e6
set q6=R2I(70)
set a6=R2I(30)
set n6=R2I(30)
set d6=R2I(10)
set f6=R2I(126)
set R6=R2I(84.000007629)
set Cb[Xb]="when calling asList in Multiboards, line 28"
set Xb=Xb+1
set T6=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(T6,q6,"when calling add in LinkedList, line 393")
call Ndw(T6,a6,"when calling add in LinkedList, line 393")
call Ndw(T6,n6,"when calling add in LinkedList, line 393")
call Ndw(T6,d6,"when calling add in LinkedList, line 393")
call Ndw(T6,f6,"when calling add in LinkedList, line 393")
call Ndw(T6,R6,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[4]=T6
set Y6=R2I(70)
set G6=R2I(30)
set g6=R2I(30)
set h6=R2I(10)
set F6=R2I(126)
set k6=R2I(84.000007629)
set Cb[Xb]="when calling asList in Multiboards, line 29"
set Xb=Xb+1
set j6=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(j6,Y6,"when calling add in LinkedList, line 393")
call Ndw(j6,G6,"when calling add in LinkedList, line 393")
call Ndw(j6,g6,"when calling add in LinkedList, line 393")
call Ndw(j6,h6,"when calling add in LinkedList, line 393")
call Ndw(j6,F6,"when calling add in LinkedList, line 393")
call Ndw(j6,k6,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[5]=j6
set x6=R2I(70)
set v6=R2I(30)
set m6=R2I(30)
set Q6=R2I(10)
set W6=R2I(126)
set E6=R2I(84.000007629)
set Cb[Xb]="when calling asList in Multiboards, line 30"
set Xb=Xb+1
set Z6=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(Z6,x6,"when calling add in LinkedList, line 393")
call Ndw(Z6,v6,"when calling add in LinkedList, line 393")
call Ndw(Z6,m6,"when calling add in LinkedList, line 393")
call Ndw(Z6,Q6,"when calling add in LinkedList, line 393")
call Ndw(Z6,W6,"when calling add in LinkedList, line 393")
call Ndw(Z6,E6,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[6]=Z6
set U6=R2I(70)
set I6=R2I(30)
set P6=R2I(30)
set A6=R2I(10)
set D6=R2I(126)
set H6=R2I(84.000007629)
set Cb[Xb]="when calling asList in Multiboards, line 31"
set Xb=Xb+1
set J6=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(J6,U6,"when calling add in LinkedList, line 393")
call Ndw(J6,I6,"when calling add in LinkedList, line 393")
call Ndw(J6,P6,"when calling add in LinkedList, line 393")
call Ndw(J6,A6,"when calling add in LinkedList, line 393")
call Ndw(J6,D6,"when calling add in LinkedList, line 393")
call Ndw(J6,H6,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[7]=J6
set K6=R2I(70)
set L6=R2I(30)
set X6=R2I(30)
set C6=R2I(10)
set V6=R2I(126)
set B6=R2I(84.000007629)
set Cb[Xb]="when calling asList in Multiboards, line 32"
set Xb=Xb+1
set N6=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(N6,K6,"when calling add in LinkedList, line 393")
call Ndw(N6,L6,"when calling add in LinkedList, line 393")
call Ndw(N6,X6,"when calling add in LinkedList, line 393")
call Ndw(N6,C6,"when calling add in LinkedList, line 393")
call Ndw(N6,V6,"when calling add in LinkedList, line 393")
call Ndw(N6,B6,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[8]=N6
set M6=R2I(70)
set w7=R2I(30)
set u7=R2I(30)
set r7=R2I(10)
set s7=R2I(126)
set t7=R2I(84.000007629)
set Cb[Xb]="when calling asList in Multiboards, line 33"
set Xb=Xb+1
set i7=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(i7,M6,"when calling add in LinkedList, line 393")
call Ndw(i7,w7,"when calling add in LinkedList, line 393")
call Ndw(i7,u7,"when calling add in LinkedList, line 393")
call Ndw(i7,r7,"when calling add in LinkedList, line 393")
call Ndw(i7,s7,"when calling add in LinkedList, line 393")
call Ndw(i7,t7,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Zc[9]=i7
set Uc[0]=4
set Uc[1]=0
set Ic[0]=4
set Ic[1]=1
set Pc[0]=1
set Pc[1]=4
set Ac[0]=1
set Ac[1]=5
set Dc[0]=1
set Dc[1]=6
set Hc[0]=2
set Hc[1]=6
set Jc[0]=2
set Jc[1]=3
set S7=lww("Food","when calling stringToIndex in Multiboards, line 56")
set c7=lww("0","when calling stringToIndex in Multiboards, line 56")
set o7=lww("|","when calling stringToIndex in Multiboards, line 56")
set O7=lww("Income","when calling stringToIndex in Multiboards, line 56")
set l7=lww("0","when calling stringToIndex in Multiboards, line 56")
set b7=lww(" ","when calling stringToIndex in Multiboards, line 56")
set Cb[Xb]="when calling asList in Multiboards, line 56"
set Xb=Xb+1
set y7=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(y7,S7,"when calling add in LinkedList, line 393")
call Ndw(y7,c7,"when calling add in LinkedList, line 393")
call Ndw(y7,o7,"when calling add in LinkedList, line 393")
call Ndw(y7,O7,"when calling add in LinkedList, line 393")
call Ndw(y7,l7,"when calling add in LinkedList, line 393")
call Ndw(y7,b7,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[0]=y7
set p7=lww("Iron","when calling stringToIndex in Multiboards, line 57")
set e7=lww("0","when calling stringToIndex in Multiboards, line 57")
set q7=lww("|","when calling stringToIndex in Multiboards, line 57")
set a7=lww("Upkeep","when calling stringToIndex in Multiboards, line 57")
set n7=lww("0","when calling stringToIndex in Multiboards, line 57")
set d7=lww(" ","when calling stringToIndex in Multiboards, line 57")
set Cb[Xb]="when calling asList in Multiboards, line 57"
set Xb=Xb+1
set f7=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(f7,p7,"when calling add in LinkedList, line 393")
call Ndw(f7,e7,"when calling add in LinkedList, line 393")
call Ndw(f7,q7,"when calling add in LinkedList, line 393")
call Ndw(f7,a7,"when calling add in LinkedList, line 393")
call Ndw(f7,n7,"when calling add in LinkedList, line 393")
call Ndw(f7,d7,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[1]=f7
set R7=lww("Stone","when calling stringToIndex in Multiboards, line 58")
set T7=lww("0","when calling stringToIndex in Multiboards, line 58")
set Y7=lww("|","when calling stringToIndex in Multiboards, line 58")
set G7=lww(" ","when calling stringToIndex in Multiboards, line 58")
set g7=lww(" ","when calling stringToIndex in Multiboards, line 58")
set h7=lww(" ","when calling stringToIndex in Multiboards, line 58")
set Cb[Xb]="when calling asList in Multiboards, line 58"
set Xb=Xb+1
set F7=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(F7,R7,"when calling add in LinkedList, line 393")
call Ndw(F7,T7,"when calling add in LinkedList, line 393")
call Ndw(F7,Y7,"when calling add in LinkedList, line 393")
call Ndw(F7,G7,"when calling add in LinkedList, line 393")
call Ndw(F7,g7,"when calling add in LinkedList, line 393")
call Ndw(F7,h7,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[2]=F7
set k7=lww(" ","when calling stringToIndex in Multiboards, line 60")
set j7=lww(" ","when calling stringToIndex in Multiboards, line 60")
set x7=lww("                           City info","when calling stringToIndex in Multiboards, line 60")
set v7=lww(" ","when calling stringToIndex in Multiboards, line 60")
set m7=lww(" ","when calling stringToIndex in Multiboards, line 60")
set Q7=lww(" ","when calling stringToIndex in Multiboards, line 60")
set Cb[Xb]="when calling asList in Multiboards, line 60"
set Xb=Xb+1
set W7=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(W7,k7,"when calling add in LinkedList, line 393")
call Ndw(W7,j7,"when calling add in LinkedList, line 393")
call Ndw(W7,x7,"when calling add in LinkedList, line 393")
call Ndw(W7,v7,"when calling add in LinkedList, line 393")
call Ndw(W7,m7,"when calling add in LinkedList, line 393")
call Ndw(W7,Q7,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[3]=W7
set E7=lww("Tax","when calling stringToIndex in Multiboards, line 61")
set Z7=lww("0","when calling stringToIndex in Multiboards, line 61")
set U7=lww(" ","when calling stringToIndex in Multiboards, line 61")
set I7=lww("|","when calling stringToIndex in Multiboards, line 61")
set P7=lww(" ","when calling stringToIndex in Multiboards, line 61")
set A7=lww(" ","when calling stringToIndex in Multiboards, line 61")
set Cb[Xb]="when calling asList in Multiboards, line 61"
set Xb=Xb+1
set D7=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(D7,E7,"when calling add in LinkedList, line 393")
call Ndw(D7,Z7,"when calling add in LinkedList, line 393")
call Ndw(D7,U7,"when calling add in LinkedList, line 393")
call Ndw(D7,I7,"when calling add in LinkedList, line 393")
call Ndw(D7,P7,"when calling add in LinkedList, line 393")
call Ndw(D7,A7,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[4]=D7
set H7=lww("Public order","when calling stringToIndex in Multiboards, line 62")
set J7=lww("0","when calling stringToIndex in Multiboards, line 62")
set K7=lww(" ","when calling stringToIndex in Multiboards, line 62")
set L7=lww("|","when calling stringToIndex in Multiboards, line 62")
set X7=lww(" ","when calling stringToIndex in Multiboards, line 62")
set C7=lww(" ","when calling stringToIndex in Multiboards, line 62")
set Cb[Xb]="when calling asList in Multiboards, line 62"
set Xb=Xb+1
set V7=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(V7,H7,"when calling add in LinkedList, line 393")
call Ndw(V7,J7,"when calling add in LinkedList, line 393")
call Ndw(V7,K7,"when calling add in LinkedList, line 393")
call Ndw(V7,L7,"when calling add in LinkedList, line 393")
call Ndw(V7,X7,"when calling add in LinkedList, line 393")
call Ndw(V7,C7,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[5]=V7
set B7=lww("Population","when calling stringToIndex in Multiboards, line 63")
set N7=lww("0","when calling stringToIndex in Multiboards, line 63")
set M7=lww(" ","when calling stringToIndex in Multiboards, line 63")
set w8=lww("|","when calling stringToIndex in Multiboards, line 63")
set u8=lww(" ","when calling stringToIndex in Multiboards, line 63")
set r8=lww(" ","when calling stringToIndex in Multiboards, line 63")
set Cb[Xb]="when calling asList in Multiboards, line 63"
set Xb=Xb+1
set s8=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(s8,B7,"when calling add in LinkedList, line 393")
call Ndw(s8,N7,"when calling add in LinkedList, line 393")
call Ndw(s8,M7,"when calling add in LinkedList, line 393")
call Ndw(s8,w8,"when calling add in LinkedList, line 393")
call Ndw(s8,u8,"when calling add in LinkedList, line 393")
call Ndw(s8,r8,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[6]=s8
set t8=lww(" ","when calling stringToIndex in Multiboards, line 64")
set i8=lww(" ","when calling stringToIndex in Multiboards, line 64")
set S8=lww(" ","when calling stringToIndex in Multiboards, line 64")
set c8=lww("|","when calling stringToIndex in Multiboards, line 64")
set o8=lww(" ","when calling stringToIndex in Multiboards, line 64")
set O8=lww(" ","when calling stringToIndex in Multiboards, line 64")
set Cb[Xb]="when calling asList in Multiboards, line 64"
set Xb=Xb+1
set l8=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(l8,t8,"when calling add in LinkedList, line 393")
call Ndw(l8,i8,"when calling add in LinkedList, line 393")
call Ndw(l8,S8,"when calling add in LinkedList, line 393")
call Ndw(l8,c8,"when calling add in LinkedList, line 393")
call Ndw(l8,o8,"when calling add in LinkedList, line 393")
call Ndw(l8,O8,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[7]=l8
set b8=lww(" ","when calling stringToIndex in Multiboards, line 65")
set y8=lww(" ","when calling stringToIndex in Multiboards, line 65")
set p8=lww(" ","when calling stringToIndex in Multiboards, line 65")
set e8=lww("|","when calling stringToIndex in Multiboards, line 65")
set q8=lww(" ","when calling stringToIndex in Multiboards, line 65")
set a8=lww(" ","when calling stringToIndex in Multiboards, line 65")
set Cb[Xb]="when calling asList in Multiboards, line 65"
set Xb=Xb+1
set n8=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(n8,b8,"when calling add in LinkedList, line 393")
call Ndw(n8,y8,"when calling add in LinkedList, line 393")
call Ndw(n8,p8,"when calling add in LinkedList, line 393")
call Ndw(n8,e8,"when calling add in LinkedList, line 393")
call Ndw(n8,q8,"when calling add in LinkedList, line 393")
call Ndw(n8,a8,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[8]=n8
set d8=lww(" ","when calling stringToIndex in Multiboards, line 66")
set f8=lww(" ","when calling stringToIndex in Multiboards, line 66")
set R8=lww(" ","when calling stringToIndex in Multiboards, line 66")
set T8=lww("|","when calling stringToIndex in Multiboards, line 66")
set Y8=lww(" ","when calling stringToIndex in Multiboards, line 66")
set G8=lww(" ","when calling stringToIndex in Multiboards, line 66")
set Cb[Xb]="when calling asList in Multiboards, line 66"
set Xb=Xb+1
set g8=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(g8,d8,"when calling add in LinkedList, line 393")
call Ndw(g8,f8,"when calling add in LinkedList, line 393")
call Ndw(g8,R8,"when calling add in LinkedList, line 393")
call Ndw(g8,T8,"when calling add in LinkedList, line 393")
call Ndw(g8,Y8,"when calling add in LinkedList, line 393")
call Ndw(g8,G8,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Kc[9]=g8
set Xb=Xb-1
return true
endfunction
function qFw takes nothing returns boolean
set Xb=0
return h8("Multiboards, line 1")
endfunction
function eL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990327 then
return false
endif
return true
endfunction
function qL takes nothing returns boolean
if not eL() then
return false
endif
return true
endfunction
function qP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990322,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990105,0)
endfunction
function eU takes nothing returns boolean
if GetResearched()!=1378890037 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890037,true)!=1 then
return false
endif
return true
endfunction
function qU takes nothing returns boolean
if not eU() then
return false
endif
return true
endfunction
function eW takes nothing returns boolean
if GetResearched()!=1378889800 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889800,true)!=2 then
return false
endif
return true
endfunction
function qW takes nothing returns boolean
if not eW() then
return false
endif
return true
endfunction
function qX takes nothing returns boolean
return true
endfunction
function qZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989560,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989579,0)
endfunction
function qww takes nothing returns boolean
return true
endfunction
function uE takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function rE takes nothing returns boolean
if not uE() then
return false
endif
return true
endfunction
function Fnw takes integer Gnw,unit gnw,string hnw returns nothing
set Cb[Xb]=hnw
set Xb=Xb+1
if mO[Gnw]==0 then
if Gnw==0 then
call q1("Nullpointer exception when calling ArrayQueue.enqueue","when calling error in DummyRecycler, line 55")
else
call q1("Called ArrayQueue.enqueue on invalid object.","when calling error in DummyRecycler, line 55")
endif
endif
set Cb[Xb]="when calling enqueue in DummyRecycler, line 55"
set Xb=Xb+1
if bb[Gnw]<6 then
set bb[Gnw]=bb[Gnw]+1
set lb[Gnw]=ModuloInteger(lb[Gnw]+1,6)
else
call q1("Queue Overflow","when calling error in DummyRecycler, line 61")
endif
set Xb=Xb-1-1
endfunction
function W3 takes real j3,real x3,player v3,real m3 returns unit
local unit Q3=CreateUnit(v3,2019849581,j3,x3,m3*57.295779513)
call SetUnitX(Q3,j3)
call SetUnitY(Q3,x3)
call UnitAddAbility(Q3,1097691750)
call UnitRemoveAbility(Q3,1097691750)
call UnitAddAbility(Q3,1097625443)
set SR=Q3
set Q3=null
return SR
endfunction
function Xcw takes string Kcw returns integer
local integer Lcw
set Cb[Xb]=Kcw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_ArrayQueue in DummyRecycler, line 49"
set Xb=Xb+1
if xO==0 then
if vO<32768 then
set vO=vO+1
set Lcw=vO
set mO[Lcw]=626
else
call q1("Out of memory: Could not create ArrayQueue.","when calling error in DummyRecycler, line 49")
set Lcw=0
endif
else
set xO=xO-1
set Lcw=jO[xO]
set mO[Lcw]=626
endif
set Xb=Xb-1
set lb[Lcw]=0
set bb[Lcw]=0
set Xb=Xb-1
return Lcw
endfunction
function k3 takes string Y3 returns boolean
local integer G3
local integer g3
local integer h3
local integer F3
set Cb[Xb]=Y3
set Xb=Xb+1
set NS=360*1./8
call CreateTimer()
set G3=0
set g3=7
loop
exitwhen G3>g3
set MS[G3]=Xcw("when calling new_ArrayQueue in DummyRecycler, line 140")
set h3=0
set F3=5
loop
exitwhen h3>F3
call Fnw(MS[G3],W3(vc,mc,tS,G3*NS*0.017453293),"when calling enqueue in DummyRecycler, line 142")
set h3=h3+1
endloop
set G3=G3+1
endloop
set Xb=Xb-1
return true
endfunction
function rFw takes nothing returns boolean
set Xb=0
return k3("DummyRecycler, line 1")
endfunction
function rH takes nothing returns nothing
local integer CD=1
local integer VD=1747988787
local player BD=GetOwningPlayer(GetConstructedStructure())
local rect uH=bj_mapInitialPlayableArea
local location wH=Location(GetRectCenterX(uH),GetRectCenterY(uH))
local location ND=Location(GetLocationX(wH)+100000000.00,GetLocationY(wH)+1000000000.00)
local real MD=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set CD=CD-1
exitwhen CD<0
call CreateUnitAtLocSaveLast(BD,VD,ND,MD)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call UnitRemoveAbility(bj_lastCreatedUnit,1093677905)
call ShowUnit(bj_lastCreatedUnit,false)
set e[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]=true
set BD=null
set ND=null
set wH=null
set uH=null
endfunction
function rL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function rU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989825,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989817,0)
endfunction
function rW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989082,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989072,0)
endfunction
function rj takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988792 then
return false
endif
return true
endfunction
function rkw takes nothing returns nothing
set Xb=0
set Cb[Xb]="ClosureEvents, line 292"
set Xb=Xb+1
call PV("when calling generalEventCallback in ClosureEvents, line 292")
set Xb=Xb-1
endfunction
function rx takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988793 then
return false
endif
return true
endfunction
function s1 takes nothing returns boolean
set tc=InitHashtable()
return true
endfunction
function s9 takes nothing returns boolean
return true
endfunction
function rD takes nothing returns boolean
if GetResearched()!=1378890052 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890052,true)!=2 then
return false
endif
return true
endfunction
function sD takes nothing returns boolean
if not rD() then
return false
endif
return true
endfunction
function sE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989812,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989811,0)
endfunction
function initialize takes nothing returns nothing
local integer i_2=0
local integer temp=qo
loop
exitwhen i_2>temp
set i_2=i_2+1
endloop
endfunction
function sFw takes nothing returns boolean
set Xb=0
set Cb[Xb]="StringUtils, line 1"
set Xb=Xb+1
set qo=127
call initialize()
call lww("","when calling stringToIndex in StringUtils, line 167")
set Xb=Xb-1
return true
endfunction
function rK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990356 then
return false
endif
return true
endfunction
function sK takes nothing returns boolean
if not rK() then
return false
endif
return true
endfunction
function rQ takes nothing returns boolean
if GetResearched()!=1378889802 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889802,true)!=1 then
return false
endif
return true
endfunction
function sQ takes nothing returns boolean
if not rQ() then
return false
endif
return true
endfunction
function skw takes nothing returns nothing
set Xb=0
set Cb[Xb]="ClosureEvents, line 293"
set Xb=Xb+1
call PV("when calling generalEventCallback in ClosureEvents, line 293")
set Xb=Xb-1
endfunction
function t4 takes nothing returns boolean
return true
endfunction
function t9 takes nothing returns boolean
return true
endfunction
function tD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990601,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990599,0)
endfunction
function J9 takes string I9 returns boolean
local integer P9
local integer A9
local integer D9
local integer H9
set Cb[Xb]=I9
set Xb=Xb+1
set oo=CreateGroup()
set Oo=CreateUnit(tS,2019849581,0.,0.,0)
if Oo==null then
set I9=""
set P9=2019849581
set A9=0
loop
exitwhen A9>3
set D9=ModuloInteger(P9,256)
set P9=P9/256
set I9=SubString(".................................!.#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~.................................................................................................................................",D9,D9+1)+I9
set A9=A9+1
endloop
call q1("DUMMY_UNITID ("+I9+") not added correctly to the map.","when calling error in Preloader, line 52")
endif
set Cb[Xb]="when calling alloc_Preloader_CallbackSingle_line54 in Preloader, line 54"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set H9=RO
set TO[H9]=651
else
call q1("Out of memory: Could not create Preloader_CallbackSingle_line54.","when calling error in Preloader, line 54")
set H9=0
endif
else
set fO=fO-1
set H9=dO[fO]
set TO[H9]=651
endif
set Xb=Xb-1
set Cb[Xb]="when calling nullTimer in Preloader, line 54"
set Xb=Xb+1
call yB(0.,H9,"when calling doAfter in ClosureTimers, line 33")
set Xb=Xb-1-1
return true
endfunction
function tFw takes nothing returns boolean
set Xb=0
return J9("Preloader, line 1")
endfunction
function tK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function tM takes nothing returns boolean
local trigger wM=CreateTrigger()
local trigger uM=wM
local playerunitevent rM=EVENT_PLAYER_UNIT_SPELL_EFFECT
local integer sM=0
loop
call TriggerRegisterPlayerUnitEvent(uM,Player(sM),rM,null)
set sM=sM+1
exitwhen sM==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(wM,Condition(Af))
call TriggerAddAction(wM,Df)
set wM=null
set uM=null
set rM=null
return true
endfunction
function tQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651824,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651825,0)
endfunction
function sY takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989045 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function tY takes nothing returns boolean
if not sY() then
return false
endif
return true
endfunction
function Maw takes integer Vaw,unit Baw,string Naw returns nothing
set Cb[Xb]=Naw
set Xb=Xb+1
if kO[Vaw]==0 then
if Vaw==0 then
call q1("Nullpointer exception when calling OnCastListener.fire","when calling error in ClosureEvents, line 56")
else
call q1("Called OnCastListener.fire on invalid object.","when calling error in ClosureEvents, line 56")
endif
endif
set Xb=Xb-1
endfunction
function LV takes string AV returns nothing
local unit DV
local integer HV
local integer JV
local integer KV
set Cb[Xb]=AV
set Xb=Xb+1
set DV=GetTriggerUnit()
set HV=GetSpellAbilityId()
if Bnw(WS,GetHandleId(DV),"when calling has in ClosureEvents, line 189") then
set JV=cdw(WS,GetHandleId(DV),"when calling get in ClosureEvents, line 190")
loop
exitwhen JV==0
if Sb[JV]==-1 or Sb[JV]==HV then
call Maw(JV,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 193")
endif
set JV=tb[JV]
endloop
endif
if Bnw(QS,HV,"when calling has in ClosureEvents, line 195") then
set KV=cdw(QS,HV,"when calling get in ClosureEvents, line 196")
loop
exitwhen KV==0
if cb[KV]==null or cb[KV]==DV then
call Maw(KV,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 199")
endif
set KV=tb[KV]
endloop
endif
set Xb=Xb-1
set DV=null
endfunction
function tkw takes nothing returns nothing
set Xb=0
set Cb[Xb]="ClosureEvents, line 308"
set Xb=Xb+1
call LV("when calling onSpellEffect in ClosureEvents, line 308")
set Xb=Xb-1
endfunction
function u0w takes nothing returns boolean
return true
endfunction
function Xfw takes integer hfw,integer Ffw,integer kfw,integer jfw,integer xfw,integer vfw,integer mfw,integer Qfw,integer Wfw,integer Efw,integer Zfw,integer Ufw,integer Ifw,integer Pfw,integer Afw,integer Dfw,integer Hfw,integer Jfw,string Kfw returns integer
local integer Lfw
set Cb[Xb]=Kfw
set Xb=Xb+1
set Lfw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(Lfw,hfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Ffw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,kfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,jfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,xfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,vfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,mfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Qfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Wfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Efw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Zfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Ufw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Ifw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Pfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Afw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Dfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Hfw,"when calling add in LinkedList, line 393")
call Ndw(Lfw,Jfw,"when calling add in LinkedList, line 393")
set Xb=Xb-1
return Lfw
endfunction
function BYw takes integer mYw,integer QYw,integer WYw,integer EYw,integer ZYw,integer UYw,integer IYw,integer PYw,integer AYw,integer DYw,integer HYw,integer JYw,integer KYw,integer LYw,integer XYw,integer CYw,string VYw returns nothing
set Cb[Xb]=VYw
set Xb=Xb+1
call SaveInteger(ac,mYw,eb[mYw],QYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,QYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],WYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,WYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],EYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,EYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],ZYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,ZYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],UYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,UYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],IYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,IYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],PYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,PYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],AYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,AYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],DYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,DYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],HYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,HYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],JYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,JYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],KYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,KYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],LYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,LYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],XYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,XYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
call SaveInteger(ac,mYw,eb[mYw],CYw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[mYw]==0 then
if mYw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(mYw,CYw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[mYw]=eb[mYw]+1
set Xb=Xb-1
endfunction
function Ogw takes integer NYw,integer MYw,integer wGw,integer uGw,integer rGw,integer sGw,integer tGw,integer iGw,integer SGw,integer cGw,integer oGw,integer OGw,integer lGw,integer bGw,integer yGw,integer pGw,string eGw returns nothing
local integer qGw
local hashtable aGw
local integer nGw
local integer dGw
local hashtable fGw
local integer RGw
local integer TGw
local hashtable YGw
local integer GGw
local integer gGw
local hashtable hGw
local integer FGw
local integer kGw
local hashtable jGw
local integer xGw
local integer vGw
local hashtable mGw
local integer QGw
local integer WGw
local hashtable EGw
local integer ZGw
local integer UGw
local hashtable IGw
local integer PGw
local integer AGw
local hashtable DGw
local integer HGw
local integer JGw
local hashtable KGw
local integer LGw
local integer XGw
local hashtable CGw
local integer VGw
local integer BGw
local hashtable NGw
local integer MGw
local integer wgw
local hashtable ugw
local integer rgw
local integer sgw
local hashtable tgw
local integer igw
local integer Sgw
local hashtable cgw
local integer ogw
set Cb[Xb]=eGw
set Xb=Xb+1
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set qGw=LoadInteger(nc,NYw,MYw)
set Xb=Xb-1
if qGw<=0 then
set aGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set nGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(aGw,NYw,MYw,nGw)
call Qhw(NYw,MYw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set dGw=LoadInteger(nc,NYw,wGw)
set Xb=Xb-1
if dGw<=0 then
set fGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set RGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(fGw,NYw,wGw,RGw)
call Qhw(NYw,wGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set TGw=LoadInteger(nc,NYw,uGw)
set Xb=Xb-1
if TGw<=0 then
set YGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set GGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(YGw,NYw,uGw,GGw)
call Qhw(NYw,uGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set gGw=LoadInteger(nc,NYw,rGw)
set Xb=Xb-1
if gGw<=0 then
set hGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set FGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(hGw,NYw,rGw,FGw)
call Qhw(NYw,rGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set kGw=LoadInteger(nc,NYw,sGw)
set Xb=Xb-1
if kGw<=0 then
set jGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set xGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(jGw,NYw,sGw,xGw)
call Qhw(NYw,sGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set vGw=LoadInteger(nc,NYw,tGw)
set Xb=Xb-1
if vGw<=0 then
set mGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set QGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(mGw,NYw,tGw,QGw)
call Qhw(NYw,tGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set WGw=LoadInteger(nc,NYw,iGw)
set Xb=Xb-1
if WGw<=0 then
set EGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ZGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(EGw,NYw,iGw,ZGw)
call Qhw(NYw,iGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set UGw=LoadInteger(nc,NYw,SGw)
set Xb=Xb-1
if UGw<=0 then
set IGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set PGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(IGw,NYw,SGw,PGw)
call Qhw(NYw,SGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set AGw=LoadInteger(nc,NYw,cGw)
set Xb=Xb-1
if AGw<=0 then
set DGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set HGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(DGw,NYw,cGw,HGw)
call Qhw(NYw,cGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set JGw=LoadInteger(nc,NYw,oGw)
set Xb=Xb-1
if JGw<=0 then
set KGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set LGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(KGw,NYw,oGw,LGw)
call Qhw(NYw,oGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set XGw=LoadInteger(nc,NYw,OGw)
set Xb=Xb-1
if XGw<=0 then
set CGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set VGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(CGw,NYw,OGw,VGw)
call Qhw(NYw,OGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set BGw=LoadInteger(nc,NYw,lGw)
set Xb=Xb-1
if BGw<=0 then
set NGw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set MGw=eb[NYw]
set Xb=Xb-1
call SaveInteger(NGw,NYw,lGw,MGw)
call Qhw(NYw,lGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set wgw=LoadInteger(nc,NYw,bGw)
set Xb=Xb-1
if wgw<=0 then
set ugw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set rgw=eb[NYw]
set Xb=Xb-1
call SaveInteger(ugw,NYw,bGw,rgw)
call Qhw(NYw,bGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set sgw=LoadInteger(nc,NYw,yGw)
set Xb=Xb-1
if sgw<=0 then
set tgw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set igw=eb[NYw]
set Xb=Xb-1
call SaveInteger(tgw,NYw,yGw,igw)
call Qhw(NYw,yGw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Sgw=LoadInteger(nc,NYw,pGw)
set Xb=Xb-1
if Sgw<=0 then
set cgw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[NYw]==0 then
if NYw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ogw=eb[NYw]
set Xb=Xb-1
call SaveInteger(cgw,NYw,pGw,ogw)
call Qhw(NYw,pGw,"when calling add in HashSet, line 13")
endif
set Xb=Xb-1
set aGw=null
set fGw=null
set YGw=null
set hGw=null
set jGw=null
set mGw=null
set EGw=null
set IGw=null
set DGw=null
set KGw=null
set CGw=null
set NGw=null
set ugw=null
set tgw=null
set cgw=null
endfunction
function kgw takes integer lgw,integer bgw,integer ygw,integer pgw,integer egw,integer qgw,integer agw,integer ngw,integer dgw,integer fgw,integer Rgw,integer Tgw,integer Ygw,integer Ggw,integer ggw,integer hgw,string Fgw returns nothing
set Cb[Xb]=Fgw
set Xb=Xb+1
if ZO[lgw]==0 then
if lgw==0 then
call q1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call q1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if ZO[lgw]<=695 then
call BYw(lgw,bgw,ygw,pgw,egw,qgw,agw,ngw,dgw,fgw,Rgw,Tgw,Ygw,Ggw,ggw,hgw,"when calling add in HashList, line 25")
else
call Ogw(lgw,bgw,ygw,pgw,egw,qgw,agw,ngw,dgw,fgw,Rgw,Tgw,Ygw,Ggw,ggw,hgw,"when calling add in HashList, line 25")
endif
set Xb=Xb-1
endfunction
function mOw takes string xOw returns integer
local integer vOw
set Cb[Xb]=xOw
set Xb=Xb+1
set Cb[Xb]="when calling alloc_HashList in HashList, line 105"
set Xb=Xb+1
if WO==0 then
if EO<32768 then
set EO=EO+1
set vOw=EO
set ZO[vOw]=695
else
call q1("Out of memory: Could not create HashList.","when calling error in HashList, line 8")
set vOw=0
endif
else
set WO=WO-1
set vOw=QO[WO]
set ZO[vOw]=695
endif
set Xb=Xb-1
set eb[vOw]=0
set Xb=Xb-1
return vOw
endfunction
function uhw takes integer jgw,integer xgw,integer vgw,integer mgw,integer Qgw,integer Wgw,integer Egw,integer Zgw,integer Ugw,integer Igw,integer Pgw,integer Agw,integer Dgw,integer Hgw,integer Jgw,integer Kgw,integer Lgw,integer Xgw,integer Cgw,integer Vgw,integer Bgw,integer Ngw,string Mgw returns integer
local integer whw
set Cb[Xb]=Mgw
set Xb=Xb+1
set whw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(whw,jgw,"when calling add in LinkedList, line 393")
call Ndw(whw,xgw,"when calling add in LinkedList, line 393")
call Ndw(whw,vgw,"when calling add in LinkedList, line 393")
call Ndw(whw,mgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Qgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Wgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Egw,"when calling add in LinkedList, line 393")
call Ndw(whw,Zgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Ugw,"when calling add in LinkedList, line 393")
call Ndw(whw,Igw,"when calling add in LinkedList, line 393")
call Ndw(whw,Pgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Agw,"when calling add in LinkedList, line 393")
call Ndw(whw,Dgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Hgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Jgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Kgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Lgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Xgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Cgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Vgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Bgw,"when calling add in LinkedList, line 393")
call Ndw(whw,Ngw,"when calling add in LinkedList, line 393")
set Xb=Xb-1
return whw
endfunction
function qTw takes integer uTw,integer rTw,integer sTw,integer tTw,integer iTw,integer STw,integer cTw,integer oTw,integer OTw,integer lTw,integer bTw,integer yTw,integer pTw,string eTw returns nothing
set Cb[Xb]=eTw
set Xb=Xb+1
call SaveInteger(ac,uTw,eb[uTw],rTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,rTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],sTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,sTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],tTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,tTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],iTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,iTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],STw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,STw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],cTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,cTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],oTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,oTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],OTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,OTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],lTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,lTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],bTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,bTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],yTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,yTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
call SaveInteger(ac,uTw,eb[uTw],pTw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[uTw]==0 then
if uTw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(uTw,pTw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[uTw]=eb[uTw]+1
set Xb=Xb-1
endfunction
function qYw takes integer aTw,integer nTw,integer dTw,integer fTw,integer RTw,integer TTw,integer YTw,integer GTw,integer gTw,integer hTw,integer FTw,integer kTw,integer jTw,string xTw returns nothing
local integer vTw
local hashtable mTw
local integer QTw
local integer WTw
local hashtable ETw
local integer ZTw
local integer UTw
local hashtable ITw
local integer PTw
local integer ATw
local hashtable DTw
local integer HTw
local integer JTw
local hashtable KTw
local integer LTw
local integer XTw
local hashtable CTw
local integer VTw
local integer BTw
local hashtable NTw
local integer MTw
local integer wYw
local hashtable uYw
local integer rYw
local integer sYw
local hashtable tYw
local integer iYw
local integer SYw
local hashtable cYw
local integer oYw
local integer OYw
local hashtable lYw
local integer bYw
local integer yYw
local hashtable pYw
local integer eYw
set Cb[Xb]=xTw
set Xb=Xb+1
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set vTw=LoadInteger(nc,aTw,nTw)
set Xb=Xb-1
if vTw<=0 then
set mTw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set QTw=eb[aTw]
set Xb=Xb-1
call SaveInteger(mTw,aTw,nTw,QTw)
call Qhw(aTw,nTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set WTw=LoadInteger(nc,aTw,dTw)
set Xb=Xb-1
if WTw<=0 then
set ETw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ZTw=eb[aTw]
set Xb=Xb-1
call SaveInteger(ETw,aTw,dTw,ZTw)
call Qhw(aTw,dTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set UTw=LoadInteger(nc,aTw,fTw)
set Xb=Xb-1
if UTw<=0 then
set ITw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set PTw=eb[aTw]
set Xb=Xb-1
call SaveInteger(ITw,aTw,fTw,PTw)
call Qhw(aTw,fTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ATw=LoadInteger(nc,aTw,RTw)
set Xb=Xb-1
if ATw<=0 then
set DTw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set HTw=eb[aTw]
set Xb=Xb-1
call SaveInteger(DTw,aTw,RTw,HTw)
call Qhw(aTw,RTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set JTw=LoadInteger(nc,aTw,TTw)
set Xb=Xb-1
if JTw<=0 then
set KTw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set LTw=eb[aTw]
set Xb=Xb-1
call SaveInteger(KTw,aTw,TTw,LTw)
call Qhw(aTw,TTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set XTw=LoadInteger(nc,aTw,YTw)
set Xb=Xb-1
if XTw<=0 then
set CTw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set VTw=eb[aTw]
set Xb=Xb-1
call SaveInteger(CTw,aTw,YTw,VTw)
call Qhw(aTw,YTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set BTw=LoadInteger(nc,aTw,GTw)
set Xb=Xb-1
if BTw<=0 then
set NTw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set MTw=eb[aTw]
set Xb=Xb-1
call SaveInteger(NTw,aTw,GTw,MTw)
call Qhw(aTw,GTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set wYw=LoadInteger(nc,aTw,gTw)
set Xb=Xb-1
if wYw<=0 then
set uYw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set rYw=eb[aTw]
set Xb=Xb-1
call SaveInteger(uYw,aTw,gTw,rYw)
call Qhw(aTw,gTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set sYw=LoadInteger(nc,aTw,hTw)
set Xb=Xb-1
if sYw<=0 then
set tYw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set iYw=eb[aTw]
set Xb=Xb-1
call SaveInteger(tYw,aTw,hTw,iYw)
call Qhw(aTw,hTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set SYw=LoadInteger(nc,aTw,FTw)
set Xb=Xb-1
if SYw<=0 then
set cYw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set oYw=eb[aTw]
set Xb=Xb-1
call SaveInteger(cYw,aTw,FTw,oYw)
call Qhw(aTw,FTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set OYw=LoadInteger(nc,aTw,kTw)
set Xb=Xb-1
if OYw<=0 then
set lYw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set bYw=eb[aTw]
set Xb=Xb-1
call SaveInteger(lYw,aTw,kTw,bYw)
call Qhw(aTw,kTw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set yYw=LoadInteger(nc,aTw,jTw)
set Xb=Xb-1
if yYw<=0 then
set pYw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[aTw]==0 then
if aTw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set eYw=eb[aTw]
set Xb=Xb-1
call SaveInteger(pYw,aTw,jTw,eYw)
call Qhw(aTw,jTw,"when calling add in HashSet, line 13")
endif
set Xb=Xb-1
set mTw=null
set ETw=null
set ITw=null
set DTw=null
set KTw=null
set CTw=null
set NTw=null
set uYw=null
set tYw=null
set cYw=null
set lYw=null
set pYw=null
endfunction
function vYw takes integer aYw,integer nYw,integer dYw,integer fYw,integer RYw,integer TYw,integer YYw,integer GYw,integer gYw,integer hYw,integer FYw,integer kYw,integer jYw,string xYw returns nothing
set Cb[Xb]=xYw
set Xb=Xb+1
if ZO[aYw]==0 then
if aYw==0 then
call q1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call q1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if ZO[aYw]<=695 then
call qTw(aYw,nYw,dYw,fYw,RYw,TYw,YYw,GYw,gYw,hYw,FYw,kYw,jYw,"when calling add in HashList, line 25")
else
call qYw(aYw,nYw,dYw,fYw,RYw,TYw,YYw,GYw,gYw,hYw,FYw,kYw,jYw,"when calling add in HashList, line 25")
endif
set Xb=Xb-1
endfunction
function DRw takes integer SRw,integer cRw,integer oRw,integer ORw,integer lRw,integer bRw,integer yRw,integer pRw,integer eRw,string qRw returns nothing
local integer aRw
local hashtable nRw
local integer dRw
local integer fRw
local hashtable RRw
local integer TRw
local integer YRw
local hashtable GRw
local integer gRw
local integer hRw
local hashtable FRw
local integer kRw
local integer jRw
local hashtable xRw
local integer vRw
local integer mRw
local hashtable QRw
local integer WRw
local integer ERw
local hashtable ZRw
local integer URw
local integer IRw
local hashtable PRw
local integer ARw
set Cb[Xb]=qRw
set Xb=Xb+1
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set aRw=LoadInteger(nc,SRw,cRw)
set Xb=Xb-1
if aRw<=0 then
set nRw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set dRw=eb[SRw]
set Xb=Xb-1
call SaveInteger(nRw,SRw,cRw,dRw)
call Qhw(SRw,cRw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set fRw=LoadInteger(nc,SRw,oRw)
set Xb=Xb-1
if fRw<=0 then
set RRw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set TRw=eb[SRw]
set Xb=Xb-1
call SaveInteger(RRw,SRw,oRw,TRw)
call Qhw(SRw,oRw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set YRw=LoadInteger(nc,SRw,ORw)
set Xb=Xb-1
if YRw<=0 then
set GRw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set gRw=eb[SRw]
set Xb=Xb-1
call SaveInteger(GRw,SRw,ORw,gRw)
call Qhw(SRw,ORw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set hRw=LoadInteger(nc,SRw,lRw)
set Xb=Xb-1
if hRw<=0 then
set FRw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set kRw=eb[SRw]
set Xb=Xb-1
call SaveInteger(FRw,SRw,lRw,kRw)
call Qhw(SRw,lRw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set jRw=LoadInteger(nc,SRw,bRw)
set Xb=Xb-1
if jRw<=0 then
set xRw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set vRw=eb[SRw]
set Xb=Xb-1
call SaveInteger(xRw,SRw,bRw,vRw)
call Qhw(SRw,bRw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set mRw=LoadInteger(nc,SRw,yRw)
set Xb=Xb-1
if mRw<=0 then
set QRw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set WRw=eb[SRw]
set Xb=Xb-1
call SaveInteger(QRw,SRw,yRw,WRw)
call Qhw(SRw,yRw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ERw=LoadInteger(nc,SRw,pRw)
set Xb=Xb-1
if ERw<=0 then
set ZRw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set URw=eb[SRw]
set Xb=Xb-1
call SaveInteger(ZRw,SRw,pRw,URw)
call Qhw(SRw,pRw,"when calling add in HashSet, line 13")
endif
set Cb[Xb]="when calling count in HashSet, line 11"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call q1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set IRw=LoadInteger(nc,SRw,eRw)
set Xb=Xb-1
if IRw<=0 then
set PRw=dc
set Cb[Xb]="when calling size in HashSet, line 12"
set Xb=Xb+1
if ZO[SRw]==0 then
if SRw==0 then
call q1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call q1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ARw=eb[SRw]
set Xb=Xb-1
call SaveInteger(PRw,SRw,eRw,ARw)
call Qhw(SRw,eRw,"when calling add in HashSet, line 13")
endif
set Xb=Xb-1
set nRw=null
set RRw=null
set GRw=null
set FRw=null
set xRw=null
set QRw=null
set ZRw=null
set PRw=null
endfunction
function iRw takes integer Cfw,integer Vfw,integer Bfw,integer Nfw,integer Mfw,integer wRw,integer uRw,integer rRw,integer sRw,string tRw returns nothing
set Cb[Xb]=tRw
set Xb=Xb+1
call SaveInteger(ac,Cfw,eb[Cfw],Vfw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[Cfw]==0 then
if Cfw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(Cfw,Vfw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[Cfw]=eb[Cfw]+1
call SaveInteger(ac,Cfw,eb[Cfw],Bfw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[Cfw]==0 then
if Cfw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(Cfw,Bfw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[Cfw]=eb[Cfw]+1
call SaveInteger(ac,Cfw,eb[Cfw],Nfw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[Cfw]==0 then
if Cfw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(Cfw,Nfw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[Cfw]=eb[Cfw]+1
call SaveInteger(ac,Cfw,eb[Cfw],Mfw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[Cfw]==0 then
if Cfw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(Cfw,Mfw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[Cfw]=eb[Cfw]+1
call SaveInteger(ac,Cfw,eb[Cfw],wRw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[Cfw]==0 then
if Cfw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(Cfw,wRw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[Cfw]=eb[Cfw]+1
call SaveInteger(ac,Cfw,eb[Cfw],uRw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[Cfw]==0 then
if Cfw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(Cfw,uRw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[Cfw]=eb[Cfw]+1
call SaveInteger(ac,Cfw,eb[Cfw],rRw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[Cfw]==0 then
if Cfw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(Cfw,rRw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[Cfw]=eb[Cfw]+1
call SaveInteger(ac,Cfw,eb[Cfw],sRw)
set Cb[Xb]="when calling incrOccurences in HashList, line 28"
set Xb=Xb+1
if ZO[Cfw]==0 then
if Cfw==0 then
call q1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call q1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call qOw(Cfw,sRw,"when calling incrOccurences in HashList, line 18")
set Xb=Xb-1
set eb[Cfw]=eb[Cfw]+1
set Xb=Xb-1
endfunction
function wTw takes integer HRw,integer JRw,integer KRw,integer LRw,integer XRw,integer CRw,integer VRw,integer BRw,integer NRw,string MRw returns nothing
set Cb[Xb]=MRw
set Xb=Xb+1
if ZO[HRw]==0 then
if HRw==0 then
call q1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call q1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if ZO[HRw]<=695 then
call iRw(HRw,JRw,KRw,LRw,XRw,CRw,VRw,BRw,NRw,"when calling add in HashList, line 25")
else
call DRw(HRw,JRw,KRw,LRw,XRw,CRw,VRw,BRw,NRw,"when calling add in HashList, line 25")
endif
set Xb=Xb-1
endfunction
function muw takes string wuw returns boolean
local integer uuw
local integer ruw
local integer suw
local integer tuw
local integer iuw
local integer Suw
local integer cuw
local integer ouw
local integer Ouw
local integer luw
local integer buw
local integer yuw
local integer puw
local integer euw
local integer quw
local integer auw
local integer nuw
local integer duw
local integer fuw
local integer Ruw
local integer Tuw
local integer Yuw
local integer Guw
local integer guw
local integer huw
local integer Fuw
local integer kuw
local integer juw
local integer xuw
local integer vuw
set Cb[Xb]=wuw
set Xb=Xb+1
set Cb[Xb]="when calling asList in Units, line 113"
set Xb=Xb+1
set Suw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(Suw,1747989317,"when calling add in LinkedList, line 393")
call Ndw(Suw,1747989305,"when calling add in LinkedList, line 393")
call Ndw(Suw,1747989316,"when calling add in LinkedList, line 393")
call Ndw(Suw,1747989315,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Jo=Suw
set Ko=KOw("when calling new_HashMap in Units, line 114")
set Lo[0]=Xfw(1747988528,1747988528,1747988528,1747988528,1747988528,1747988528,1747988532,1747988532,1747988532,1747988532,1211118401,1747989058,1747989058,1747989058,1747989058,1747989058,1747989058,1747988790,"when calling asList in Units, line 121")
set Lo[1]=Xfw(1747990339,1747990339,1747990339,1747990339,1747990339,1747990339,1747990340,1747990340,1747990340,1747990340,1211119699,1747990593,1747990593,1747990593,1747990593,1747990593,1747990593,1747988790,"when calling asList in Units, line 127")
set Lo[2]=Xfw(1747990087,1747990087,1747990087,1747990087,1747990087,1747990087,1747990088,1747990088,1747990088,1747990088,1211119701,1747989817,1747989817,1747989817,1747989817,1747989817,1747989817,1747988790,"when calling asList in Units, line 134")
set Lo[3]=Xfw(1747989558,1747989558,1747989558,1747989558,1747989558,1747989558,1747989575,1747989575,1747989575,1747989575,1211119700,1747989571,1747989571,1747989571,1747989571,1747989571,1747989571,1747988790,"when calling asList in Units, line 141")
set uuw=mOw("when calling new_HashList in Units, line 150")
call wTw(uuw,1747989558,1747990339,1747990087,1747988528,1747989575,1747990340,1747990088,1747988532,"when calling add in Units, line 151")
set Xo=uuw
set ruw=mOw("when calling new_HashList in Units, line 163")
call vYw(ruw,1747988529,1747988530,1747988531,1747990326,1747990327,1747990328,1747990084,1747990087,1747990086,1747989590,1747989591,1747989592,"when calling add in Units, line 164")
set Co=ruw
set suw=mOw("when calling new_HashList in Units, line 179")
call vYw(suw,1747989059,1747989060,1747988844,1747990351,1747990352,1747990356,1747989331,1747990350,1747989809,1747990353,1747990354,1747990355,"when calling add in Units, line 180")
set Vo=suw
set tuw=mOw("when calling new_HashList in Units, line 195")
call kgw(tuw,1747988529,1747988530,1747988531,1747990326,1747990327,1747990328,1747990084,1747990087,1747990086,1747989590,1747989591,1747989592,1747989555,1747989297,1747989325,"when calling add in Units, line 196")
set Bo=tuw
set Cb[Xb]="when calling asList in Units, line 205"
set Xb=Xb+1
set cuw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(cuw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(cuw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(cuw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(cuw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(cuw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(cuw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(cuw,1747988790,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set No[0]=cuw
set Cb[Xb]="when calling asList in Units, line 206"
set Xb=Xb+1
set ouw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(ouw,1747989326,"when calling add in LinkedList, line 393")
call Ndw(ouw,1747989326,"when calling add in LinkedList, line 393")
call Ndw(ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(ouw,1747988790,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set No[1]=ouw
set Cb[Xb]="when calling asList in Units, line 207"
set Xb=Xb+1
set Ouw=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(Ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747989321,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747989326,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747989326,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747989326,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747989326,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747989337,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747989337,"when calling add in LinkedList, line 393")
call Ndw(Ouw,1747988790,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set No[2]=Ouw
set luw=GetHandleId(gu)
set buw=GetHandleId(kw)
set yuw=GetHandleId(ew)
set puw=GetHandleId(qw)
set euw=GetHandleId(Ow)
set quw=GetHandleId(hu)
set auw=GetHandleId(Yu)
set nuw=GetHandleId(Vw)
set duw=GetHandleId(q)
set fuw=GetHandleId(Gu)
set Ruw=GetHandleId(a)
set Tuw=GetHandleId(fw)
set Yuw=GetHandleId(dw)
set Guw=GetHandleId(Rw)
set guw=GetHandleId(ow)
set huw=GetHandleId(lw)
set Fuw=GetHandleId(bw)
set kuw=GetHandleId(yw)
set juw=GetHandleId(pw)
set xuw=GetHandleId(aw)
set vuw=GetHandleId(d)
set Mo=uhw(luw,buw,yuw,puw,euw,quw,auw,nuw,duw,fuw,Ruw,Tuw,Yuw,Guw,guw,huw,Fuw,kuw,juw,xuw,vuw,GetHandleId(n),"when calling asList in Units, line 210")
set iuw=Ko
call rdw(iuw,1747989317,15,"when calling put in Units, line 237")
call rdw(iuw,1747989305,50,"when calling put in Units, line 238")
call rdw(iuw,1747989316,25,"when calling put in Units, line 239")
call rdw(iuw,1747989315,40,"when calling put in Units, line 240")
set Xb=Xb-1
return true
endfunction
function uFw takes nothing returns boolean
set Xb=0
return muw("Units, line 1")
endfunction
function wL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988530 then
return false
endif
return true
endfunction
function uL takes nothing returns boolean
if not wL() then
return false
endif
return true
endfunction
function uP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990324,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990325,0)
endfunction
function wU takes nothing returns boolean
if GetResearched()!=1378889818 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889818,true)!=1 then
return false
endif
return true
endfunction
function uU takes nothing returns boolean
if not wU() then
return false
endif
return true
endfunction
function wW takes nothing returns boolean
if GetResearched()!=1378889801 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889801,true)!=2 then
return false
endif
return true
endfunction
function uW takes nothing returns boolean
if not wW() then
return false
endif
return true
endfunction
function uZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651841,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651831,0)
endfunction
function ukw takes nothing returns nothing
set Xb=0
set Cb[Xb]="ClosureEvents, line 291"
set Xb=Xb+1
call PV("when calling generalEventCallback in ClosureEvents, line 291")
set Xb=Xb-1
endfunction
function uv takes nothing returns nothing
local player Hx=GetOwningPlayer(GetSpellTargetUnit())
local playerstate Jx=PLAYER_STATE_RESOURCE_GOLD
local playerstate Kx
local playerstate Lx
local player Xx
local force Cx
local location Vx
local real Bx
local real Nx
local player Mx
local force wv
if Jx==PLAYER_STATE_RESOURCE_GOLD then
set Kx=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Hx,Kx,GetPlayerState(Hx,Kx)+500)
elseif Jx==PLAYER_STATE_RESOURCE_LUMBER then
set Lx=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Hx,Lx,GetPlayerState(Hx,Lx)+500)
endif
call SetPlayerState(Hx,Jx,GetPlayerState(Hx,Jx)+500)
call RemoveUnit(GetSpellAbilityUnit())
set Xx=GetOwningPlayer(GetSpellTargetUnit())
set Cx=CreateForce()
call ForceAddPlayer(Cx,Xx)
if IsPlayerInForce(GetLocalPlayer(),Cx) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1234")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set Mx=GetOwningPlayer(GetSpellTargetUnit())
set wv=CreateForce()
call ForceAddPlayer(wv,Mx)
set Vx=y
set Bx=GetLocationX(Vx)
set Nx=GetLocationY(Vx)
if IsPlayerInForce(GetLocalPlayer(),wv) then
call PingMinimap(Bx,Nx,2.00)
endif
call RemoveLocation(y)
set Hx=null
set Jx=null
set Kx=null
set Lx=null
set Xx=null
set Cx=null
set Vx=null
set Mx=null
set wv=null
endfunction
function v1 takes nothing returns boolean
return true
endfunction
function xE takes nothing returns boolean
if GetResearched()!=1378889807 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889807,true)!=2 then
return false
endif
return true
endfunction
function vE takes nothing returns boolean
if not xE() then
return false
endif
return true
endfunction
function jF takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function xF takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988792 then
return false
endif
if not jF() then
return false
endif
return true
endfunction
function vF takes nothing returns boolean
if not xF() then
return false
endif
return true
endfunction
function g5 takes string R5 returns boolean
local integer T5
local integer Y5
local timer G5
set Cb[Xb]=R5
set Xb=Xb+1
set Cb[Xb]="when calling alloc_MultiboardCityUpdate_CallbackSingle_line18 in MultiboardCityUpdate, line 18"
set Xb=Xb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set T5=RO
set TO[T5]=648
else
call q1("Out of memory: Could not create MultiboardCityUpdate_CallbackSingle_line18.","when calling error in MultiboardCityUpdate, line 18")
set T5=0
endif
else
set fO=fO-1
set T5=dO[fO]
set TO[T5]=648
endif
set Xb=Xb-1
call yB(0.01,T5,"when calling doAfter in MultiboardCityUpdate, line 18")
set Cb[Xb]="when calling alloc_MultiboardCityUpdate_CallbackPeriodic_line25 in MultiboardCityUpdate, line 25"
set Xb=Xb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set Y5=gO
set hO[Y5]=637
else
call q1("Out of memory: Could not create MultiboardCityUpdate_CallbackPeriodic_line25.","when calling error in MultiboardCityUpdate, line 25")
set Y5=0
endif
else
set GO=GO-1
set Y5=YO[GO]
set hO[Y5]=637
endif
set Xb=Xb-1
set Cb[Xb]="when calling doPeriodically in MultiboardCityUpdate, line 25"
set Xb=Xb+1
set G5=Cww("when calling getTimer in ClosureTimers, line 57")
set Cb[Xb]="when calling doPeriodically in ClosureTimers, line 57"
set Xb=Xb+1
call anw(Y5,G5,1.0,"when calling start in ClosureTimers, line 45")
set Xb=Xb-1-1-1
set G5=null
return true
endfunction
function vFw takes nothing returns boolean
set Xb=0
return g5("MultiboardCityUpdate, line 1")
endfunction
function vL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function vU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989815,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989838,0)
endfunction
function vW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651843,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651842,0)
endfunction
function wFw takes nothing returns boolean
set Xb=0
set Cb[Xb]="TimerUtils, line 1"
set Xb=Xb+1
set Uo=gqw("when calling new_Table in TimerUtils, line 12")
call CreateTimer()
call CreateTrigger()
set Xb=Xb-1
return true
endfunction
function wI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989826,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989828,0)
endfunction
function MI takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function wP takes nothing returns boolean
if not MI() then
return false
endif
return true
endfunction
function wX takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function ME takes nothing returns boolean
if GetResearched()!=1378889809 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889809,true)!=1 then
return false
endif
return true
endfunction
function wZ takes nothing returns boolean
if not ME() then
return false
endif
return true
endfunction
function Muw takes string Kuw returns nothing
local unit Luw
local integer Xuw
local player Cuw
local integer Vuw
local integer Buw
local boolean Nuw
set Cb[Xb]=Kuw
set Xb=Xb+1
set Luw=GetEnteringUnit()
set Xuw=GetPlayerId(GetOwningPlayer(Luw))
set Cuw=wo[Xuw]
if GetPlayerSlotState(Cuw)==PLAYER_SLOT_STATE_PLAYING then
set Nuw=GetPlayerController(Cuw)==MAP_CONTROL_USER
else
set Nuw=false
endif
if Nuw and(not IsUnitType(Luw,UNIT_TYPE_STRUCTURE)) then
set Vuw=Mc[Xuw]
set Buw=-GetUnitLevel(Luw)
set Cb[Xb]="when calling changeUpkeep in Upkeep, line 25"
set Xb=Xb+1
if yl[Vuw]==0 then
if Vuw==0 then
call q1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call q1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Hb[Vuw]=Hb[Vuw]+Buw
set Xb=Xb-1
endif
set Xb=Xb-1
set Luw=null
set Cuw=null
endfunction
function wkw takes nothing returns nothing
set Xb=0
call Muw("Upkeep, line 21")
endfunction
function wrw takes nothing returns boolean
call Location(0.,0.)
return true
endfunction
function x1 takes nothing returns boolean
return true
endfunction
function g2 takes string y2 returns boolean
local playerunitevent p2
local playerunitevent e2
local integer q2
local integer a2
local integer n2
local integer d2
local integer f2
local integer R2
local integer T2
local integer Y2
local integer G2
set Cb[Xb]=y2
set Xb=Xb+1
set Qc=KOw("when calling new_HashMap in MassControl, line 7")
set q2=R2I(500000)
set a2=R2I(700000)
set n2=R2I(1000000)
set Cb[Xb]="when calling asList in MassControl, line 8"
set Xb=Xb+1
set d2=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(d2,q2,"when calling add in LinkedList, line 393")
call Ndw(d2,a2,"when calling add in LinkedList, line 393")
call Ndw(d2,n2,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Wc=d2
set Cb[Xb]="when calling asList in MassControl, line 14"
set Xb=Xb+1
set f2=hbw("when calling new_LinkedList in LinkedList, line 391")
call Ndw(f2,1211118401,"when calling add in LinkedList, line 393")
call Ndw(f2,1211119699,"when calling add in LinkedList, line 393")
call Ndw(f2,1211119701,"when calling add in LinkedList, line 393")
call Ndw(f2,1211119700,"when calling add in LinkedList, line 393")
set Xb=Xb-1
set Ec=f2
set p2=EVENT_PLAYER_UNIT_SPELL_CAST
set Cb[Xb]="when calling alloc_MassControl_EventListener_line22 in MassControl, line 22"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set R2=iO
set SO[R2]=673
else
call q1("Out of memory: Could not create MassControl_EventListener_line22.","when calling error in MassControl, line 22")
set R2=0
endif
else
set tO=tO-1
set R2=sO[tO]
set SO[R2]=673
endif
set Xb=Xb-1
set ub[R2]=0
set rb[R2]=0
set sb[R2]=0
set Cb[Xb]="when calling add in MassControl, line 22"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set T2=vS[GetHandleId(p2)]
if T2==0 then
set T2=aV(p2,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[R2]=T2
if ES[ub[R2]]!=0 then
set sb[ES[ub[R2]]]=R2
set rb[R2]=ES[ub[R2]]
endif
set ES[ub[R2]]=R2
set Xb=Xb-1
set e2=EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER
set Cb[Xb]="when calling alloc_MassControl_EventListener_line32 in MassControl, line 32"
set Xb=Xb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set Y2=iO
set SO[Y2]=674
else
call q1("Out of memory: Could not create MassControl_EventListener_line32.","when calling error in MassControl, line 32")
set Y2=0
endif
else
set tO=tO-1
set Y2=sO[tO]
set SO[Y2]=674
endif
set Xb=Xb-1
set ub[Y2]=0
set rb[Y2]=0
set sb[Y2]=0
set Cb[Xb]="when calling add in MassControl, line 32"
set Xb=Xb+1
set Cb[Xb]="when calling toIntId in ClosureEvents, line 112"
set Xb=Xb+1
set G2=vS[GetHandleId(e2)]
if G2==0 then
set G2=aV(e2,"when calling registerEventId in ClosureEvents, line 229")
endif
set Xb=Xb-1
set ub[Y2]=G2
if ES[ub[Y2]]!=0 then
set sb[ES[ub[Y2]]]=Y2
set rb[Y2]=ES[ub[Y2]]
endif
set ES[ub[Y2]]=Y2
set Xb=Xb-1-1
set p2=null
set e2=null
return true
endfunction
function xFw takes nothing returns boolean
set Xb=0
return g2("MassControl, line 1")
endfunction
function xG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989047 then
return false
endif
return true
endfunction
function xH takes nothing returns nothing
local integer YH=1
local integer GH=1752461175
local player gH=GetOwningPlayer(GetTriggerUnit())
local rect jH=bj_mapInitialPlayableArea
local location kH=Location(GetRectCenterX(jH),GetRectCenterY(jH))
local location hH=Location(GetLocationX(kH)+100000000.00,GetLocationY(kH)+100000000.00)
local real FH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set YH=YH-1
exitwhen YH<0
call CreateUnitAtLocSaveLast(gH,GH,hH,FH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set gH=null
set hH=null
set kH=null
set jH=null
endfunction
function jL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989592 then
return false
endif
return true
endfunction
function xL takes nothing returns boolean
if not jL() then
return false
endif
return true
endfunction
function xP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990584,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990593,0)
endfunction
function jU takes nothing returns boolean
if GetResearched()!=1378890034 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890034,true)!=1 then
return false
endif
return true
endfunction
function xU takes nothing returns boolean
if not jU() then
return false
endif
return true
endfunction
function xV takes nothing returns nothing
call TriggerRegisterUnitEvent(kS,Do[Ho-1],EVENT_UNIT_DAMAGED)
endfunction
function jW takes nothing returns boolean
if GetResearched()!=1378889812 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889812,true)!=1 then
return false
endif
return true
endfunction
function xW takes nothing returns boolean
if not jW() then
return false
endif
return true
endfunction
function xZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989574,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989573,0)
endfunction
function xg takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990089 then
return false
endif
return true
endfunction
function xh takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989078 then
return false
endif
return true
endfunction
function xk takes nothing returns nothing
local player dk=GetOwningPlayer(GetSpellTargetUnit())
local playerstate fk=PLAYER_STATE_RESOURCE_GOLD
local playerstate Rk
local playerstate Tk
local player Yk
local force Gk
local location gk
local real hk
local real Fk
local player kk
local force jk
if fk==PLAYER_STATE_RESOURCE_GOLD then
set Rk=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(dk,Rk,GetPlayerState(dk,Rk)+250)
elseif fk==PLAYER_STATE_RESOURCE_LUMBER then
set Tk=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(dk,Tk,GetPlayerState(dk,Tk)+250)
endif
call SetPlayerState(dk,fk,GetPlayerState(dk,fk)+250)
call RemoveUnit(GetSpellAbilityUnit())
set Yk=GetOwningPlayer(GetSpellTargetUnit())
set Gk=CreateForce()
call ForceAddPlayer(Gk,Yk)
if IsPlayerInForce(GetLocalPlayer(),Gk) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1230")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set kk=GetOwningPlayer(GetSpellTargetUnit())
set jk=CreateForce()
call ForceAddPlayer(jk,kk)
set gk=y
set hk=GetLocationX(gk)
set Fk=GetLocationY(gk)
if IsPlayerInForce(GetLocalPlayer(),jk) then
call PingMinimap(hk,Fk,2.00)
endif
call RemoveLocation(y)
set dk=null
set fk=null
set Rk=null
set Tk=null
set Yk=null
set Gk=null
set gk=null
set kk=null
set jk=null
endfunction
function bA takes nothing returns boolean
if GetResearched()!=1378890053 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890053,true)!=2 then
return false
endif
return true
endfunction
function yA takes nothing returns boolean
if not bA() then
return false
endif
return true
endfunction
function bJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989325 then
return false
endif
return true
endfunction
function yJ takes nothing returns boolean
if not bJ() then
return false
endif
return true
endfunction
function yX takes nothing returns boolean
return true
endfunction
function yg takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989046 then
return false
endif
return true
endfunction
function yh takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990073 then
return false
endif
return true
endfunction
function bm takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function ym takes nothing returns boolean
if not bm() then
return false
endif
return true
endfunction
function yR takes nothing returns nothing
set w=null
set u=null
set s=null
set t=null
set i=null
set S=null
set c=null
set o=null
set O=null
set l=null
set b=null
set y=null
set q=null
set a=null
set n=null
set d=null
set f=null
set R=null
set T=null
set Y=null
set G=null
set g=null
set h=null
set F=null
set k=null
set j=null
set x=null
set v=null
set m=null
set Q=null
set W=null
set E=null
set Z=null
set U=null
set I=null
set P=null
set A=null
set D=null
set H=null
set J=null
set K=null
set L=null
set X=null
set C=null
set V=null
set B=null
set N=null
set M=null
set ww=null
set uw=null
set rw=null
set sw=null
set tw=null
set iw=null
set Sw=null
set cw=null
set ow=null
set Ow=null
set lw=null
set bw=null
set yw=null
set pw=null
set ew=null
set qw=null
set aw=null
set nw=null
set dw=null
set fw=null
set Rw=null
set Tw=null
set Yw=null
set Gw=null
set gw=null
set hw=null
set Fw=null
set kw=null
set jw=null
set xw=null
set vw=null
set mw=null
set Qw=null
set Ww=null
set Ew=null
set Zw=null
set Uw=null
set Iw=null
set Pw=null
set Aw=null
set Dw=null
set Hw=null
set Jw=null
set Kw=null
set Lw=null
set Xw=null
set Cw=null
set Vw=null
set Bw=null
set Nw=null
set Mw=null
set wu=null
set uu=null
set ru=null
set su=null
set tu=null
set iu=null
set Su=null
set cu=null
set ou=null
set Ou=null
set lu=null
set bu=null
set yu=null
set pu=null
set eu=null
set qu=null
set au=null
set nu=null
set du=null
set fu=null
set Ru=null
set Tu=null
set Yu=null
set Gu=null
set gu=null
set hu=null
set Fu=null
set ku=null
set ju=null
set xu=null
set vu=null
set mu=null
set Qu=null
set Wu=null
set Eu=null
set Zu=null
set Uu=null
set Iu=null
set Pu=null
set Au=null
set Du=null
set Hu=null
set Ju=null
set Ku=null
set Lu=null
set Xu=null
set Cu=null
set Vu=null
set Bu=null
set Nu=null
set Mu=null
set wr=null
set ur=null
set rr=null
set sr=null
set tr=null
set ir=null
set Sr=null
set cr=null
set lr=null
set br=null
set yr=null
set pr=null
set er=null
set qr=null
set ar=null
set nr=null
set dr=null
set fr=null
set Rr=null
set Tr=null
set Yr=null
set Gr=null
set gr=null
set hr=null
set Fr=null
set kr=null
set jr=null
set xr=null
set vr=null
set mr=null
set Qr=null
set Wr=null
set Er=null
set Zr=null
set Ur=null
set Ir=null
set Pr=null
set Ar=null
set Dr=null
set Hr=null
set Jr=null
set Kr=null
set Lr=null
set Xr=null
set Cr=null
set Vr=null
set Br=null
set Nr=null
set Mr=null
set ws=null
set us=null
set rs=null
set ss=null
set ts=null
set is=null
set Ss=null
set cs=null
set os=null
set Os=null
set ls=null
set bs=null
set ys=null
set ps=null
set es=null
set qs=null
set as=null
set ns=null
set ds=null
set fs=null
set Rs=null
set Ts=null
set Ys=null
set Gs=null
set gs=null
set hs=null
set Fs=null
set ks=null
set js=null
set xs=null
set vs=null
set ms=null
set Qs=null
set Ws=null
set Es=null
set Zs=null
set Us=null
set Is=null
set Ps=null
set As=null
set Ds=null
set Hs=null
set Js=null
set Ks=null
set Ls=null
set Xs=null
set Cs=null
set Vs=null
set Bs=null
set Ns=null
set Ms=null
set wt=null
set ut=null
set rt=null
set st=null
set tt=null
set St=null
set ct=null
set ot=null
set Ot=null
set lt=null
set bt=null
set yt=null
set pt=null
set et=null
set qt=null
set at=null
set nt=null
set dt=null
set ft=null
set Rt=null
set Tt=null
set Yt=null
set Gt=null
set gt=null
set ht=null
set Ft=null
set kt=null
set jt=null
set xt=null
set vt=null
set mt=null
set Qt=null
set Wt=null
set Et=null
set Zt=null
set Ut=null
set It=null
set Pt=null
set At=null
set Dt=null
set Ht=null
set Jt=null
set Kt=null
set Lt=null
set Xt=null
set Ct=null
set Vt=null
set Bt=null
set Nt=null
set Mt=null
set wi=null
set ui=null
set ri=null
set si=null
set ti=null
set ii=null
set Si=null
set ci=null
set oi=null
set Oi=null
set li=null
set bi=null
set yi=null
set pi=null
set ei=null
set qi=null
set ai=null
set ni=null
set di=null
set fi=null
set Ri=null
set Ti=null
set Yi=null
set Gi=null
set gi=null
set hi=null
set Fi=null
set ki=null
set ji=null
set xi=null
set vi=null
set mi=null
set Qi=null
set Wi=null
set Ei=null
set Zi=null
set Ui=null
set Ii=null
set Pi=null
set Ai=null
set Di=null
set Hi=null
set Ji=null
set Ki=null
set Li=null
set Xi=null
set Ci=null
set Vi=null
set Bi=null
set Ni=null
set Mi=null
set wS=null
set uS=null
set rS=null
set Gy=function WT
set gy=function IT
set hy=function DT
set Fy=function KT
set ky=function NT
set jy=function tY
set xy=function lY
set vy=function aY
set my=function YY
set Qy=function jY
set Wy=function EY
set Ey=function DY
set Zy=function KY
set Uy=function BY
set Iy=function NY
set Py=function bG
set Ay=function gG
set Dy=function mG
set Hy=function xG
set Jy=function HG
set Ky=function BG
set Ly=function CG
set Xy=function cg
set Cy=function eg
set Vy=function yg
set By=function gg
set Ny=function mg
set My=function xg
set wp=function Hg
set up=function Bg
set rp=function Cg
set sp=function ch
set tp=function eh
set ip=function yh
set Sp=function gh
set cp=function mh
set op=function xh
set Op=function Hh
set lp=function Bh
set bp=function Ch
set yp=function cF
set pp=function eF
set ep=function dF
set qp=function YF
set ap=function FF
set np=function vF
set dp=function JF
set fp=function NF
set Rp=function lk
set Tp=function nk
set Yp=function xk
set Gp=function Uk
set gp=function Bk
set hp=function rj
set Fp=function ej
set kp=function fj
set jp=function mj
set xp=function Uj
set vp=function Bj
set mp=function rx
set Qp=function ex
set Wp=function Tx
set Ep=function Wx
set Zp=function Dx
set Up=function uv
set Ip=function cv
set Pp=function fv
set Ap=function gv
set Dp=function Uv
set Hp=function Jv
set Jp=function Kv
set Kp=function Nv
set Lp=function Mv
set Xp=function im
set Cp=function Sm
set Vp=function ym
set Bp=function pm
set Np=function fm
set Mp=function Rm
set we=function Fm
set ue=function km
set re=function Wm
set se=function Em
set te=function Dm
set ie=function Hm
set Se=function Vm
set ce=function Bm
set oe=function sQ
set Oe=function tQ
set le=function lQ
set be=function bQ
set ye=function nQ
set pe=function dQ
set ee=function gQ
set qe=function hQ
set ae=function mQ
set ne=function QQ
set de=function PQ
set fe=function AQ
set Re=function XQ
set Te=function CQ
set Ye=function uW
set Ge=function rW
set ge=function oW
set he=function OW
set Fe=function qW
set ke=function aW
set je=function YW
set xe=function GW
set ve=function xW
set me=function vW
set Qe=function UW
set We=function IW
set Ee=function JW
set Ze=function KW
set Ue=function CW
set Ie=function VW
set Pe=function rE
set Ae=function sE
set De=function OE
set He=function lE
set Je=function aE
set Ke=function nE
set Le=function GE
set Xe=function gE
set Ce=function vE
set Ve=function mE
set Be=function IE
set Ne=function PE
set Me=function LE
set wq=function XE
set uq=function wZ
set rq=function uZ
set sq=function cZ
set tq=function oZ
set iq=function eZ
set Sq=function qZ
set cq=function TZ
set oq=function YZ
set Oq=function jZ
set lq=function xZ
set bq=function ZZ
set yq=function UZ
set pq=function JZ
set eq=function KZ
set qq=function BZ
set aq=function NZ
set nq=function uU
set dq=function rU
set fq=function oU
set Rq=function OU
set Tq=function qU
set Yq=function aU
set Gq=function YU
set gq=function GU
set hq=function xU
set Fq=function vU
set kq=function UU
set jq=function IU
set xq=function KU
set vq=function LU
set mq=function MU
set Qq=function wI
set Wq=function SI
set Eq=function cI
set Zq=function pI
set Uq=function eI
set Iq=function RI
set Pq=function TI
set Aq=function kI
set Dq=function jI
set Hq=function EI
set Jq=function ZI
set Kq=function HI
set Lq=function JI
set Xq=function VI
set Cq=function BI
set Vq=function wP
set Bq=function uP
set Nq=function cP
set Mq=function oP
set wa=function eP
set ua=function qP
set ra=function TP
set sa=function YP
set ta=function jP
set ia=function xP
set Sa=function ZP
set ca=function UP
set oa=function JP
set Oa=function KP
set la=function NP
set ba=function MP
set ya=function iA
set pa=function SA
set ea=function yA
set qa=function pA
set aa=function fA
set na=function RA
set da=function FA
set fa=function kA
set Ra=function WA
set Ta=function EA
set Ya=function DA
set Ga=function HA
set ga=function VA
set ha=function BA
set Fa=function sD
set ka=function tD
set ja=function lD
set xa=function bD
set va=function nD
set ma=function dD
set Qa=function GD
set Wa=function gD
set Ea=function kD
set Za=function jD
set Ua=function FD
set Ia=function ED
set Pa=function AD
set Aa=function XD
set Da=function rH
set Ha=function oH
set Ja=function aH
set Ka=function TH
set La=function xH
set Xa=function ZH
set Ca=function KH
set Va=function NH
set Ba=function SJ
set Na=function yJ
set Ma=function pJ
set wn=function fJ
set un=function RJ
set rn=function FJ
set sn=function kJ
set tn=function WJ
set Sn=function EJ
set cn=function DJ
set on=function HJ
set On=function VJ
set ln=function BJ
set bn=function sK
set yn=function tK
set pn=function lK
set en=function bK
set qn=function nK
set an=function dK
set nn=function gK
set dn=function hK
set fn=function mK
set Rn=function QK
set Tn=function PK
set Yn=function AK
set Gn=function XK
set gn=function CK
set hn=function uL
set Fn=function rL
set kn=function oL
set jn=function OL
set xn=function qL
set vn=function aL
set mn=function YL
set Qn=function GL
set Wn=function xL
set En=function vL
set Zn=function UL
set Un=function IL
set In=function KL
set Pn=function LL
set An=function ML
set Dn=function wX
set Hn=function AT
set Jn=function Sv
set Kn=function c0w
set Ln=function x1
set Xn=function qww
set Cn=function pX
set Vn=function wrw
set Bn=function E2
set Nn=function E9
set Mn=function V9
set wd=function eX
set ud=function n1
set rd=function i4
set sd=function s1
set td=function Z2
set id=function u0w
set Sd=function gww_2
set cd=function U9
set od=function Lhw
set Od=function g1
set ld=function v1
set bd=function Prw
set yd=function Xhw
set pd=function XV
set ed=function Chw
set qd=function Bhw
set ad=function yX
set nd=function qX
set dd=function aX
set fd=function F8
set Rd=function F1
set Td=function Nhw
set Yd=function Mhw
set Gd=function wFw
set gd=function cB
set hd=function hww
set Fd=function T3
set kd=function j1
set jd=function t9
set xd=function pww
set vd=function eww
set md=function mww_2
set Qd=function Qww
set Wd=function uFw
set Ed=function Www
set Zd=function b2
set Ud=function rFw
set Id=function sFw
set Pd=function s9
set Ad=function tFw
set Dd=function iFw
set Hd=function SFw
set Jd=function Eww
set Kd=function cFw
set Ld=function h2
set Xd=function a1
set Cd=function Gww
set Vd=function oFw
set Bd=function j0w
set Nd=function eFw
set Md=function qFw
set wf=function Z9
set uf=function S4
set rf=function aFw
set sf=function nFw
set tf=function dFw
set Sf=function fFw
set cf=function RFw
set of=function k1
set Of=function TFw
set lf=function KB
set bf=function YFw
set yf=function GFw
set pf=function gFw
set ef=function tM
set qf=function hFw
set af=function FFw
set nf=function kFw
set df=function t4
set ff=function jFw
set Rf=function xFw
set Tf=function vFw
set Yf=function mFw
set Gf=function QFw
set gf=function WFw
set hf=function EFw
set Ff=function ZFw
set kf=function UFw
set jf=function IFw
set xf=function PFw
set vf=function NX
set mf=function AFw
set Qf=function xV
set Wf=function DFw
set Ef=function HFw
set Zf=function KFw
set Uf=function JN
set If=function LFw
set Pf=function h1
set Af=function XFw
set Df=function CFw
set Hf=function d1
set Jf=function l2
set Kf=function VFw
set Lf=function NFw
set Xf=function MFw
set Cf=function wkw
set Vf=function ukw
set Bf=function rkw
set Nf=function skw
set Mf=function tkw
set wR=function ckw
set uR=function n9
set rR=function f9
set sR=function R9
set tR=function Skw
set iR=function BFw
endfunction
function main takes nothing returns nothing
local trigger OX
local trigger lX
local trigger bX
call yR()
call SetCameraBounds((-30720.0)+GetCameraMargin(CAMERA_MARGIN_LEFT),(-30720.0)+GetCameraMargin(CAMERA_MARGIN_BOTTOM),30720.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),30720.0-GetCameraMargin(CAMERA_MARGIN_TOP),(-30720.0)+GetCameraMargin(CAMERA_MARGIN_LEFT),30720.0-GetCameraMargin(CAMERA_MARGIN_TOP),30720.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),(-30720.0)+GetCameraMargin(CAMERA_MARGIN_BOTTOM))
call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl","Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
call NewSoundEnvironment("Default")
call SetAmbientDaySound("LordaeronSummerDay")
call SetAmbientNightSound("LordaeronSummerNight")
call SetMapMusic("Music",true,0)
set fs=CreateSound("Sound\\Interface\\Warning.wav",false,false,false,10,10,"")
call SetSoundParamsFromLabel(fs,"Warning")
call SetSoundDuration(fs,1903)
set q=Rect(11872.0,-24096.0,13376.0,-18304.0)
set a=Rect(14080.0,-30720.0,16256.0,-25664.0)
set n=Rect(12096.0,-26240.0,14944.0,-23776.0)
set d=Rect(-17120.0,15936.0,-15520.0,17408.0)
call Rect(-29824.0,-30080.0,-29312.0,-28672.0)
call Rect(-29216.0,-30112.0,-28672.0,-28672.0)
call Rect(-25984.0,-29760.0,-24992.0,-29504.0)
call Rect(-25984.0,-30080.0,-25472.0,-29824.0)
call Rect(-25984.0,-30400.0,-25472.0,-30144.0)
call Rect(-26464.0,-30048.0,-26176.0,-29056.0)
call Rect(-25440.0,-30368.0,-25184.0,-29856.0)
call Rect(-25184.0,-30368.0,-24928.0,-29856.0)
call Rect(-24672.0,-29568.0,-24064.0,-28800.0)
call Rect(-24704.0,-30208.0,-24064.0,-29696.0)
set f=Rect(-17408.0,22016.0,-17056.0,22368.0)
set R=Rect(-19072.0,17728.0,-18688.0,18080.0)
set T=Rect(-22464.0,22208.0,-22112.0,22560.0)
set Y=Rect(-3776.0,4416.0,-3392.0,4768.0)
set G=Rect(-3872.0,1664.0,-3456.0,2016.0)
set g=Rect(-416.0,-2592.0,-128.0,-2272.0)
set h=Rect(4992.0,-2016.0,5344.0,-1696.0)
set F=Rect(2528.0,-3168.0,2848.0,-2880.0)
set k=Rect(7744.0,-2528.0,8096.0,-2208.0)
set j=Rect(-17504.0,18080.0,-17056.0,18496.0)
set x=Rect(1024.0,-1120.0,1376.0,-800.0)
set v=Rect(-3328.0,8096.0,-2848.0,8512.0)
set m=Rect(-4704.0,11488.0,-4416.0,11776.0)
set Q=Rect(-640.0,8288.0,-160.0,8704.0)
set W=Rect(-5184.0,17120.0,-4832.0,17440.0)
set E=Rect(-96.0,12448.0,224.0,12768.0)
set Z=Rect(-2272.0,13536.0,-1984.0,13856.0)
set U=Rect(7008.0,1984.0,7456.0,2432.0)
set I=Rect(4032.0,3744.0,4416.0,4064.0)
set P=Rect(4000.0,5216.0,4320.0,5536.0)
set A=Rect(-576.0,2880.0,-224.0,3232.0)
set D=Rect(-8288.0,19776.0,-7936.0,20160.0)
set H=Rect(-6464.0,21184.0,-6080.0,21568.0)
set J=Rect(-7904.0,22048.0,-7488.0,22464.0)
set K=Rect(-5344.0,14304.0,-4960.0,14720.0)
set L=Rect(2880.0,32.0,3264.0,352.0)
set X=Rect(608.0,15680.0,992.0,16096.0)
set C=Rect(-2496.0,15872.0,-2112.0,16224.0)
set V=Rect(1056.0,10848.0,1344.0,11136.0)
set B=Rect(1600.0,6784.0,1984.0,7136.0)
set N=Rect(224.0,19296.0,544.0,19648.0)
set M=Rect(2784.0,22592.0,3200.0,22944.0)
set ww=Rect(-1984.0,19008.0,-1600.0,19360.0)
set uw=Rect(3008.0,18048.0,3392.0,18400.0)
call Rect(-28544.0,-30080.0,-28064.0,-29344.0)
call Rect(-27744.0,-30080.0,-27456.0,-29760.0)
set rw=Rect(4224.0,19488.0,4608.0,19776.0)
set sw=Rect(13056.0,4960.0,13408.0,5280.0)
set tw=Rect(5696.0,24768.0,6048.0,25088.0)
set iw=Rect(3328.0,26816.0,3680.0,27168.0)
set Sw=Rect(8608.0,26144.0,9024.0,26528.0)
set cw=Rect(6656.0,21248.0,7008.0,21600.0)
set ow=Rect(-16640.0,10368.0,-13504.0,13056.0)
set Ow=Rect(-18944.0,5312.0,-16864.0,7328.0)
set lw=Rect(-28032.0,-1120.0,-22464.0,640.0)
set bw=Rect(-27264.0,2784.0,-26208.0,3328.0)
set yw=Rect(-26912.0,-4320.0,-23872.0,-2976.0)
set pw=Rect(-19328.0,-288.0,-18592.0,1568.0)
set ew=Rect(-11936.0,7616.0,-448.0,11424.0)
set qw=Rect(-1664.0,1216.0,6848.0,7776.0)
set aw=Rect(-5472.0,24704.0,-3232.0,27616.0)
set nw=Rect(3744.0,10880.0,4064.0,11232.0)
set dw=Rect(-12064.0,11392.0,-8832.0,16576.0)
set fw=Rect(-8832.0,10176.0,23520.0,17760.0)
set Rw=Rect(4384.0,17728.0,23424.0,27040.0)
set Tw=Rect(-10688.0,17536.0,-10304.0,17888.0)
set Yw=Rect(-10688.0,-9312.0,-10336.0,-9024.0)
set Gw=Rect(17280.0,9280.0,17632.0,9632.0)
set gw=Rect(8352.0,12192.0,8672.0,12512.0)
set hw=Rect(5952.0,18400.0,6304.0,18688.0)
set Fw=Rect(9120.0,19872.0,9408.0,20192.0)
set kw=Rect(23328.0,-14080.0,30688.0,17792.0)
set jw=Rect(13984.0,-288.0,14336.0,0.0)
set xw=Rect(10624.0,-7552.0,11008.0,-7200.0)
set vw=Rect(15168.0,-5792.0,15552.0,-5408.0)
set mw=Rect(15328.0,-7712.0,15648.0,-7424.0)
set Qw=Rect(12640.0,-7104.0,12992.0,-6752.0)
set Ww=Rect(17056.0,-8800.0,17376.0,-8512.0)
set Ew=Rect(18432.0,-608.0,18784.0,-320.0)
set Zw=Rect(13760.0,-11168.0,14112.0,-10752.0)
set Uw=Rect(16768.0,-16416.0,17120.0,-16032.0)
set Iw=Rect(18880.0,-7616.0,19232.0,-7296.0)
set Pw=Rect(6816.0,-6752.0,7136.0,-6464.0)
set Aw=Rect(12512.0,-4064.0,12832.0,-3712.0)
set Dw=Rect(9056.0,-4576.0,9344.0,-4288.0)
set Hw=Rect(-26464.0,-8896.0,-26144.0,-8544.0)
set Jw=Rect(-21632.0,-8544.0,-21248.0,-8224.0)
set Kw=Rect(-16928.0,-8224.0,-16608.0,-7904.0)
set Lw=Rect(-10112.0,-11424.0,-9760.0,-11136.0)
set Xw=Rect(-7680.0,-16416.0,-7328.0,-16128.0)
set Cw=Rect(288.0,-17760.0,608.0,-17472.0)
set Vw=Rect(9248.0,-21376.0,9984.0,-20640.0)
set Bw=Rect(24704.0,-27648.0,25088.0,-27264.0)
set Nw=Rect(10816.0,-18688.0,11168.0,-18304.0)
set Mw=Rect(13056.0,-18016.0,13408.0,-17760.0)
set wu=Rect(12096.0,-21024.0,12448.0,-20704.0)
set uu=Rect(15680.0,5600.0,16032.0,5920.0)
set ru=Rect(6944.0,7648.0,7264.0,7968.0)
set su=Rect(5824.0,12256.0,6176.0,12576.0)
set tu=Rect(11200.0,7712.0,11552.0,8064.0)
set iu=Rect(12480.0,11136.0,12832.0,11456.0)
set Su=Rect(14880.0,22944.0,15200.0,23232.0)
set cu=Rect(11392.0,16768.0,11744.0,17088.0)
set ou=Rect(23840.0,96.0,24128.0,384.0)
set Ou=Rect(19488.0,11168.0,19808.0,11488.0)
set lu=Rect(20672.0,2528.0,21056.0,2848.0)
set bu=Rect(23776.0,2368.0,24160.0,2720.0)
set yu=Rect(18336.0,-13408.0,18624.0,-13120.0)
set pu=Rect(17056.0,-11648.0,17376.0,-11264.0)
set eu=Rect(15488.0,-17696.0,15840.0,-17376.0)
set qu=Rect(24896.0,-8480.0,25248.0,-8128.0)
set au=Rect(16480.0,-14368.0,16768.0,-14048.0)
set nu=Rect(17088.0,-19744.0,17440.0,-19456.0)
set du=Rect(22720.0,-10432.0,23072.0,-10048.0)
set fu=Rect(20672.0,-23232.0,21056.0,-22848.0)
set Ru=Rect(19904.0,-5920.0,20256.0,-5632.0)
set Tu=Rect(18624.0,-3936.0,18976.0,-3616.0)
set Yu=Rect(-13632.0,-14816.0,-12192.0,-13376.0)
set Gu=Rect(17760.0,-10400.0,23360.0,-1344.0)
set gu=Rect(12384.0,-5984.0,13824.0,-4352.0)
set hu=Rect(-10944.0,3968.0,-7680.0,5120.0)
set Fu=Rect(-6528.0,7808.0,-6176.0,8160.0)
set ku=Rect(-8864.0,6912.0,-8448.0,7264.0)
set ju=Rect(-11680.0,14304.0,-11264.0,14752.0)
set xu=Rect(-9760.0,12928.0,-9472.0,13280.0)
set vu=Rect(-7552.0,16928.0,-7232.0,17248.0)
set mu=Rect(-17472.0,-3328.0,-17120.0,-2976.0)
call Rect(-24576.0,-1376.0,-24224.0,-1024.0)
set Qu=Rect(23392.0,10912.0,23712.0,11232.0)
set Wu=Rect(17280.0,19456.0,17632.0,19808.0)
set Eu=Rect(-16896.0,24032.0,-16544.0,24352.0)
set Zu=Rect(-15904.0,25952.0,-15520.0,26304.0)
set Uu=Rect(-17312.0,26624.0,-16896.0,27008.0)
set Iu=Rect(-16096.0,20352.0,-15712.0,20768.0)
set Pu=Rect(-20448.0,21440.0,-20064.0,21792.0)
set Au=Rect(-22560.0,19808.0,-22272.0,20128.0)
set Du=Rect(-18752.0,19520.0,-18400.0,19872.0)
set Hu=Rect(-16128.0,16896.0,-15808.0,17248.0)
set Ju=Rect(-17952.0,15904.0,-17632.0,16224.0)
set Ku=Rect(-19936.0,16352.0,-19648.0,16672.0)
set Lu=Rect(-17248.0,12448.0,-16928.0,12832.0)
set Xu=Rect(-13728.0,11968.0,-13408.0,12352.0)
set Cu=Rect(-15232.0,10624.0,-14880.0,10976.0)
set Vu=Rect(-13856.0,7872.0,-13568.0,8256.0)
set Bu=Rect(-16192.0,5824.0,-15840.0,6208.0)
set Nu=Rect(-16864.0,3392.0,-16576.0,3776.0)
set Mu=Rect(-18880.0,5568.0,-18528.0,5920.0)
set wr=Rect(-20288.0,1216.0,-19936.0,1600.0)
set ur=Rect(-17216.0,352.0,-16896.0,736.0)
set rr=Rect(-24512.0,3744.0,-24128.0,4064.0)
set sr=Rect(-22720.0,2368.0,-22432.0,2752.0)
set tr=Rect(-23552.0,-256.0,-23200.0,128.0)
set ir=Rect(-25376.0,1312.0,-25056.0,1632.0)
set Sr=Rect(-28736.0,-192.0,-28352.0,160.0)
set cr=Rect(-21024.0,2944.0,-20704.0,3360.0)
set lr=Rect(-13792.0,2144.0,-13440.0,2592.0)
set br=Rect(-13568.0,14912.0,-13216.0,15296.0)
set yr=Rect(-12736.0,16128.0,-12352.0,16512.0)
set pr=Rect(-10880.0,3360.0,-10528.0,3712.0)
set er=Rect(-10048.0,5280.0,-9696.0,5600.0)
set qr=Rect(-6880.0,3936.0,-6560.0,4256.0)
set ar=Rect(-8224.0,3040.0,-7904.0,3392.0)
set nr=Rect(-8960.0,1760.0,-8608.0,2176.0)
set dr=Rect(-6624.0,1088.0,-6304.0,1472.0)
set fr=Rect(-7296.0,-960.0,-6944.0,-544.0)
set Rr=Rect(-23712.0,-4704.0,-23392.0,-4416.0)
set Tr=Rect(-25184.0,-3168.0,-24864.0,-2848.0)
set Yr=Rect(-21888.0,-4416.0,-21536.0,-4032.0)
set Gr=Rect(-20928.0,-2304.0,-20576.0,-1888.0)
set gr=Rect(-7776.0,11040.0,-7456.0,11392.0)
set hr=Rect(-11648.0,7072.0,-11296.0,7360.0)
set Fr=Rect(-13728.0,4992.0,-13408.0,5376.0)
set kr=Rect(-5152.0,21696.0,-4832.0,22080.0)
set jr=Rect(-5248.0,24416.0,-4960.0,24768.0)
set xr=Rect(-6688.0,28096.0,-6368.0,28480.0)
set vr=Rect(-9024.0,26496.0,-8736.0,26880.0)
set mr=Rect(-10048.0,28224.0,-9696.0,28576.0)
set Qr=Rect(-1408.0,23776.0,-1152.0,24096.0)
set Wr=Rect(-2720.0,26176.0,-2432.0,26560.0)
set Er=Rect(-28032.0,-2944.0,-27680.0,-2560.0)
set Zr=Rect(-29760.0,-10016.0,-29408.0,-9632.0)
set Ur=Rect(15296.0,-26976.0,15648.0,-26624.0)
set Ir=Rect(-20544.0,12032.0,-20160.0,12416.0)
set Pr=Rect(-18368.0,10624.0,-18016.0,11008.0)
set Ar=Rect(-10880.0,-576.0,-10528.0,-224.0)
set Dr=Rect(-11104.0,-4768.0,-10816.0,-4448.0)
set Hr=Rect(-5728.0,-2912.0,-5440.0,-2560.0)
set Jr=Rect(-3904.0,-6720.0,-3552.0,-6336.0)
set Kr=Rect(-3616.0,-3040.0,-3328.0,-2688.0)
set Lr=Rect(-7200.0,-8000.0,-6880.0,-7616.0)
set Xr=Rect(-5504.0,-9344.0,-5248.0,-9056.0)
set Cr=Rect(-11616.0,10848.0,-11296.0,11168.0)
set Vr=Rect(-1792.0,-320.0,-1440.0,64.0)
set Br=Rect(3232.0,-7488.0,3552.0,-7136.0)
set Nr=Rect(8224.0,-10496.0,8512.0,-10208.0)
set Mr=Rect(1344.0,29280.0,1696.0,29632.0)
set ws=Rect(10848.0,-2144.0,11136.0,-1824.0)
set us=Rect(-26496.0,-1568.0,-26144.0,-1248.0)
set rs=Rect(-27168.0,2528.0,-26880.0,2816.0)
set ss=Rect(-2016.0,27552.0,-1696.0,27936.0)
set ts=Rect(-3488.0,23040.0,-3200.0,23392.0)
set is=Rect(2016.0,-7904.0,2336.0,-7584.0)
set Ss=Rect(640.0,-5760.0,992.0,-5376.0)
set cs=Rect(5216.0,-12384.0,5504.0,-12064.0)
set os=Rect(18272.0,-17504.0,18656.0,-17056.0)
set Os=Rect(26848.0,-11680.0,27168.0,-11360.0)
set ls=Rect(6464.0,-4672.0,6816.0,-4288.0)
set bs=Rect(20672.0,21312.0,21024.0,21696.0)
set ys=Rect(-1824.0,5792.0,-1440.0,6144.0)
set ps=Rect(-23264.0,-8992.0,-22944.0,-8704.0)
set es=Rect(-13504.0,-8640.0,-13184.0,-8384.0)
set qs=Rect(26048.0,-2848.0,26400.0,-2528.0)
set as=Rect(28864.0,-3360.0,29152.0,-3040.0)
set ns=Rect(28064.0,2592.0,28352.0,2880.0)
set ds=Rect(27488.0,-5984.0,27808.0,-5664.0)
call mT()
call QT()
call InitBlizzard()
call eR()
call iX()
set lX=Ts
if TriggerEvaluate(lX) then
call TriggerExecute(lX)
endif
set bX=wt
if TriggerEvaluate(bX) then
call TriggerExecute(bX)
endif
set OX=CreateTrigger()
call TriggerAddCondition(OX,Condition(Kn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Real.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ln))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Integer.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Xn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package String.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Cn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Angle.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Vn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Vectors.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Bn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Maths.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Nn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Player.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Mn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Printing.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(wd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Basics.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ud))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package GameTimer.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(rd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MagicFunctions.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(sd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ErrorHandling.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(td))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Matrices.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(id))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Quaternion.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Sd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Table.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(cd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Playercolor.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(od))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Colors.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Od))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Group.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ld))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Lightning.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(bd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package WeatherEffects.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(yd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TypeCasting.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(pd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureForGroups.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ed))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LinkedList.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(qd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Abilities.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ad))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package AbilityIds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(nd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Bootleg.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(dd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Buildings.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(fd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MutliboardTools.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Rd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package HashList.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Td))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package EventHelper.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Yd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package RegisterEvents.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Gd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TimerUtils.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(gd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureTimers.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(hd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TargetsAllowed.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Fd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Doodads.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(kd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Icons.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(jd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Objects.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(xd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Sounds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(vd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Soundsets.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(md))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Textures.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Qd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UI.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Wd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Units.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ed))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UnitIds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Zd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MapBounds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ud))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DummyRecycler.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Id))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package StringUtils.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Pd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ObjectIds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ad))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Preloader.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Dd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ObjectIdGenerator.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Hd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OnUnitEnterLeave.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Jd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UnitIndexer.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Kd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureEvents.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ld))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MathTools.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Xd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Forces.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Cd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Strings.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Vd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityBaseTaxes.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Bd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Revolts.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Nd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package City.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Md))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Multiboards.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(wf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package PlayerStats.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(uf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Main.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(rf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CastleCapture.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(sf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityBuilded.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(tf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityManage.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Sf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityModifiers.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(cf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Clerics.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(of))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package HashSet.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Of))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package VoteKick.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(lf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Commands.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(bf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Credits.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(yf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Economy.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(pf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DateTime.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ef))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Diplomacy.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(qf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Garissons.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(af))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LimitEncampments.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(nf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LimitMercenaryCamps.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(df))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Logarithm.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ff))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MainInit.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Rf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MassControl.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Tf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MultiboardCityUpdate.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Yf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package NoShipsNearRivers.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Gf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package NoStarvationOnBoat.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(gf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OnPlayerLeave.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(hf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OreCapture.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ff))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package RangeChecks.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(kf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Religion.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(jf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Taxation.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(xf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Upkeep.")
endif
call TriggerClearConditions(OX)
call DestroyTrigger(OX)
set OX=null
set lX=null
set bX=null
endfunction
function SX takes nothing returns nothing
call SetPlayerStartLocation(Player(0),0)
call ForcePlayerStartLocation(Player(0),0)
call SetPlayerColor(Player(0),ConvertPlayerColor(0))
call SetPlayerRacePreference(Player(0),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(0),false)
call SetPlayerController(Player(0),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(1),1)
call ForcePlayerStartLocation(Player(1),1)
call SetPlayerColor(Player(1),ConvertPlayerColor(1))
call SetPlayerRacePreference(Player(1),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(1),false)
call SetPlayerController(Player(1),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(2),2)
call ForcePlayerStartLocation(Player(2),2)
call SetPlayerColor(Player(2),ConvertPlayerColor(2))
call SetPlayerRacePreference(Player(2),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(2),false)
call SetPlayerController(Player(2),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(3),3)
call ForcePlayerStartLocation(Player(3),3)
call SetPlayerColor(Player(3),ConvertPlayerColor(3))
call SetPlayerRacePreference(Player(3),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(3),false)
call SetPlayerController(Player(3),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(4),4)
call ForcePlayerStartLocation(Player(4),4)
call SetPlayerColor(Player(4),ConvertPlayerColor(4))
call SetPlayerRacePreference(Player(4),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(4),false)
call SetPlayerController(Player(4),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(5),5)
call ForcePlayerStartLocation(Player(5),5)
call SetPlayerColor(Player(5),ConvertPlayerColor(5))
call SetPlayerRacePreference(Player(5),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(5),false)
call SetPlayerController(Player(5),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(6),6)
call ForcePlayerStartLocation(Player(6),6)
call SetPlayerColor(Player(6),ConvertPlayerColor(6))
call SetPlayerRacePreference(Player(6),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(6),false)
call SetPlayerController(Player(6),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(7),7)
call ForcePlayerStartLocation(Player(7),7)
call SetPlayerColor(Player(7),ConvertPlayerColor(7))
call SetPlayerRacePreference(Player(7),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(7),false)
call SetPlayerController(Player(7),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(8),8)
call ForcePlayerStartLocation(Player(8),8)
call SetPlayerColor(Player(8),ConvertPlayerColor(8))
call SetPlayerRacePreference(Player(8),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(8),false)
call SetPlayerController(Player(8),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(9),9)
call ForcePlayerStartLocation(Player(9),9)
call SetPlayerColor(Player(9),ConvertPlayerColor(9))
call SetPlayerRacePreference(Player(9),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(9),false)
call SetPlayerController(Player(9),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(10),10)
call ForcePlayerStartLocation(Player(10),10)
call SetPlayerColor(Player(10),ConvertPlayerColor(10))
call SetPlayerRacePreference(Player(10),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(10),false)
call SetPlayerController(Player(10),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(11),11)
call ForcePlayerStartLocation(Player(11),11)
call SetPlayerColor(Player(11),ConvertPlayerColor(11))
call SetPlayerRacePreference(Player(11),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(11),false)
call SetPlayerController(Player(11),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(12),12)
call ForcePlayerStartLocation(Player(12),12)
call SetPlayerColor(Player(12),ConvertPlayerColor(12))
call SetPlayerRacePreference(Player(12),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(12),false)
call SetPlayerController(Player(12),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(13),13)
call ForcePlayerStartLocation(Player(13),13)
call SetPlayerColor(Player(13),ConvertPlayerColor(13))
call SetPlayerRacePreference(Player(13),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(13),false)
call SetPlayerController(Player(13),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(14),14)
call ForcePlayerStartLocation(Player(14),14)
call SetPlayerColor(Player(14),ConvertPlayerColor(14))
call SetPlayerRacePreference(Player(14),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(14),false)
call SetPlayerController(Player(14),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(15),15)
call ForcePlayerStartLocation(Player(15),15)
call SetPlayerColor(Player(15),ConvertPlayerColor(15))
call SetPlayerRacePreference(Player(15),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(15),false)
call SetPlayerController(Player(15),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(16),16)
call ForcePlayerStartLocation(Player(16),16)
call SetPlayerColor(Player(16),ConvertPlayerColor(16))
call SetPlayerRacePreference(Player(16),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(16),false)
call SetPlayerController(Player(16),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(17),17)
call ForcePlayerStartLocation(Player(17),17)
call SetPlayerColor(Player(17),ConvertPlayerColor(17))
call SetPlayerRacePreference(Player(17),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(17),false)
call SetPlayerController(Player(17),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(18),18)
call ForcePlayerStartLocation(Player(18),18)
call SetPlayerColor(Player(18),ConvertPlayerColor(18))
call SetPlayerRacePreference(Player(18),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(18),false)
call SetPlayerController(Player(18),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(19),19)
call ForcePlayerStartLocation(Player(19),19)
call SetPlayerColor(Player(19),ConvertPlayerColor(19))
call SetPlayerRacePreference(Player(19),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(19),false)
call SetPlayerController(Player(19),MAP_CONTROL_USER)
endfunction
function cX takes nothing returns nothing
call SetPlayerTeam(Player(0),0)
call SetPlayerTeam(Player(1),0)
call SetPlayerTeam(Player(2),0)
call SetPlayerTeam(Player(3),0)
call SetPlayerTeam(Player(4),0)
call SetPlayerTeam(Player(5),0)
call SetPlayerTeam(Player(6),0)
call SetPlayerTeam(Player(7),0)
call SetPlayerTeam(Player(8),0)
call SetPlayerTeam(Player(9),0)
call SetPlayerTeam(Player(10),0)
call SetPlayerTeam(Player(11),0)
call SetPlayerTeam(Player(12),1)
call SetPlayerTeam(Player(13),1)
call SetPlayerTeam(Player(14),1)
call SetPlayerTeam(Player(15),1)
call SetPlayerTeam(Player(16),1)
call SetPlayerTeam(Player(17),1)
call SetPlayerTeam(Player(18),1)
call SetPlayerTeam(Player(19),1)
endfunction
function oX takes nothing returns nothing
call SetStartLocPrioCount(0,19)
call SetStartLocPrio(0,0,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,9,10,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,10,11,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,11,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,12,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,13,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,14,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,15,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(1,9)
call SetStartLocPrio(1,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(2,9)
call SetStartLocPrio(2,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(3,9)
call SetStartLocPrio(3,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(4,9)
call SetStartLocPrio(4,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(5,9)
call SetStartLocPrio(5,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(6,9)
call SetStartLocPrio(6,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(7,9)
call SetStartLocPrio(7,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(8,9)
call SetStartLocPrio(8,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(9,9)
call SetStartLocPrio(9,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(10,16)
call SetStartLocPrio(10,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,10,12,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,11,13,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,12,14,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,13,15,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,14,16,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,15,17,MAP_LOC_PRIO_LOW)
call SetStartLocPrioCount(11,19)
call SetStartLocPrio(11,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,10,10,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,11,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,12,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,13,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,14,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,15,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(12,5)
call SetStartLocPrio(12,0,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,1,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,2,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(13,5)
call SetStartLocPrio(13,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,1,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,2,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(14,5)
call SetStartLocPrio(14,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,2,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(15,5)
call SetStartLocPrio(15,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,2,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(16,5)
call SetStartLocPrio(16,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,2,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,3,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(17,5)
call SetStartLocPrio(17,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,2,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,3,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,4,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(18,1)
call SetStartLocPrio(18,0,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(19,1)
call SetStartLocPrio(19,0,18,MAP_LOC_PRIO_HIGH)
endfunction
function config takes nothing returns nothing
call SetMapName("TRIGSTR_001")
call SetMapDescription("TRIGSTR_003")
call SetPlayers(20)
call SetTeams(20)
call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
call DefineStartLocation(0,320.0,5184.0)
call DefineStartLocation(1,320.0,5184.0)
call DefineStartLocation(2,320.0,5184.0)
call DefineStartLocation(3,320.0,5184.0)
call DefineStartLocation(4,320.0,5184.0)
call DefineStartLocation(5,320.0,5184.0)
call DefineStartLocation(6,320.0,5184.0)
call DefineStartLocation(7,320.0,5184.0)
call DefineStartLocation(8,320.0,5184.0)
call DefineStartLocation(9,320.0,5184.0)
call DefineStartLocation(10,320.0,5184.0)
call DefineStartLocation(11,320.0,5184.0)
call DefineStartLocation(12,320.0,5184.0)
call DefineStartLocation(13,320.0,5184.0)
call DefineStartLocation(14,320.0,5184.0)
call DefineStartLocation(15,320.0,5184.0)
call DefineStartLocation(16,320.0,5184.0)
call DefineStartLocation(17,320.0,5184.0)
call DefineStartLocation(18,320.0,5184.0)
call DefineStartLocation(19,320.0,5184.0)
call SX()
call cX()
call oX()
endfunction
